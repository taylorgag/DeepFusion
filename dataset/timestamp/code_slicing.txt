10022.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
10129.sol
function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
require(!VAR9);
bytes32 VAR10 = FUN5(VAR4);
FUN6 (VAR11, VAR12, VAR13, VAR14, VAR15) = FUN7(VAR4);
uint VAR16 = 10 ** 18;
address VAR17 = msg.sender;
uint VAR18 = msg.value;
require(FUN8(VAR10, VAR5, VAR6, VAR7) == VAR19);
if(FUN9() == VAR1.VAR20) {
require(VAR21[VAR17]);
}
else if(FUN9() == VAR1.VAR22) {
}
else {
revert();
}
if(VAR23[VAR17] == 0) {
VAR24++;
}
VAR23[VAR17] = VAR23[VAR17].FUN3(VAR18);
VAR25 = VAR25.FUN3(VAR18);
require(!FUN10(VAR18, VAR8, VAR25, VAR26));
require(VAR23[msg.sender] >= VAR13 * VAR16 / 10000);
require(VAR23[msg.sender] <= VAR14 * VAR16 / 10000);
require(VAR27.FUN11(VAR18));
FUN12(VAR17, VAR18, VAR8, VAR12, VAR15);
return 0;
}

0
---------------------------------
10146.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
10186.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
10233.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
10253.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
1027.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
1041.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
10431.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1051.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 + VAR2) >= VAR1);
}
function FUN2(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 - VAR2) <= VAR1);
}
function FUN3(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 == 0 || (VAR3 = VAR1 * VAR2) / VAR2 == VAR1);
}
}
contract VAR4 {
function FUN4(address[] VAR5, address value) internal pure returns (int) {
uint VAR6 = 0;
while (VAR6 < VAR5.VAR7) {
if (VAR5[VAR6] == value) {
return int(VAR6);
}
VAR6++;
}
return int(- 1);
}

0
---------------------------------
10559.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
10661.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}

0
---------------------------------
10755.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
10758.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
10763.sol
function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}

0
---------------------------------
10803.sol
function() payable VAR1 {
FUN1(msg.sender);
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) public pure {
}

0
---------------------------------
10807.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
10826.sol
function() payable VAR1 {
FUN1(msg.sender);
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) public pure {
}

0
---------------------------------
10831.sol
function() payable VAR1 {
FUN1(msg.sender);
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) public pure {
}

0
---------------------------------
10855.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;
uint256 VAR6;

0
---------------------------------
10933.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
11178.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
11182.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
11339.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
11346.sol
function FUN1(string VAR1, string VAR2, string VAR3, string VAR4, string VAR5) internal pure returns (string){
bytes memory VAR6 = bytes(VAR1);
bytes memory VAR7 = bytes(VAR2);
bytes memory VAR8 = bytes(VAR3);
bytes memory VAR9 = bytes(VAR4);
bytes memory VAR10 = bytes(VAR5);
string memory VAR11 = VAR12 string(VAR6.VAR13 + VAR7.VAR13 + VAR8.VAR13 + VAR9.VAR13 + VAR10.VAR13);
bytes memory VAR14 = bytes(VAR11);
uint VAR15 = 0;
for (uint VAR16 = 0; VAR16 < VAR6.VAR13; VAR16++) VAR14[VAR15++] = VAR6[VAR16];
for (VAR16 = 0; VAR16 < VAR7.VAR13; VAR16++) VAR14[VAR15++] = VAR7[VAR16];
for (VAR16 = 0; VAR16 < VAR8.VAR13; VAR16++) VAR14[VAR15++] = VAR8[VAR16];
for (VAR16 = 0; VAR16 < VAR9.VAR13; VAR16++) VAR14[VAR15++] = VAR9[VAR16];
for (VAR16 = 0; VAR16 < VAR10.VAR13; VAR16++) VAR14[VAR15++] = VAR10[VAR16];
return string(VAR14);
}

0
---------------------------------
11415.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
11418.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
11526.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);

0
---------------------------------
11640.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
11642.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
11684.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
11711.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);

0
---------------------------------
11727.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
11765.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
11766.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
11773.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}

0
---------------------------------
11775.sol
function() payable {
throw;
}

0
---------------------------------
1179.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
1181.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
11949.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
12044.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
12075.sol
function FUN1( address[8] VAR1, uint256[6] VAR2, uint256 VAR3, uint256 VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7 ) external payable returns (uint256);

0
---------------------------------
12115.sol
function FUN1( bytes16 VAR1, address VAR2, address VAR3, uint256 VAR4, uint16 VAR5, uint32 VAR6, uint32 VAR7, uint8 VAR8, bytes32 VAR9, bytes32 VAR10 ) payable external {
bytes32 VAR11 = FUN2(VAR12.FUN3(VAR1, VAR2, VAR3, VAR4, VAR5));
require(!VAR13[VAR11].VAR14, "");
bytes32 VAR15 = FUN2(VAR12.FUN3( VAR11, VAR6, VAR7 ));
require(FUN4(VAR15, VAR8, VAR9, VAR10) == VAR16, "");
require(VAR17.VAR18 < VAR7, "");
require(msg.value == VAR4 && msg.value > 0, "");
uint32 VAR19 = VAR6 == 0 ? 1 : FUN5(VAR17.VAR18) + VAR6;
VAR13[VAR11] = FUN6(true, VAR19, 0);
emit FUN7(VAR11);
}
uint16 constant VAR20 = 36100;
function FUN4( bytes32 VAR21, uint8 VAR8, bytes32 VAR9, bytes32 VAR10 ) private pure returns (address) {
bytes memory VAR22 = "";
bytes32 VAR23 = FUN2(VAR12.FUN3(VAR22, VAR21));
return FUN8(VAR23, VAR8, VAR9, VAR10);
}
}

0
---------------------------------
1226.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 + VAR2) >= VAR1);
}
function FUN2(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 - VAR2) <= VAR1);
}
function FUN3(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 == 0 || (VAR3 = VAR1 * VAR2) / VAR2 == VAR1);
}
}
contract VAR4 {
function FUN4(address[] VAR5, address value) internal pure returns (int) {
uint VAR6 = 0;
while (VAR6 < VAR5.VAR7) {
if (VAR5[VAR6] == value) {
return int(VAR6);
}
VAR6++;
}
return int(- 1);
}

0
---------------------------------
124.sol
function() external payable {
}
uint64 public VAR1 = 1;
uint64 public VAR2 = 361;
uint64 public VAR3 = 51;
uint64 public VAR4 = 131;
uint64 public VAR5 = 391;
uint64 public VAR6 = 451;
uint64 public VAR7 = 1;
uint64 public VAR8 = 31;

0
---------------------------------
1256.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1280.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
12859.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1288.sol
function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
require(!VAR9);
bytes32 VAR10 = FUN5(VAR4);
FUN6 (VAR11, VAR12, VAR13, VAR14, VAR15) = FUN7(VAR4);
uint VAR16 = 10 ** 18;
address VAR17 = msg.sender;
uint VAR18 = msg.value;
require(FUN8(VAR10, VAR5, VAR6, VAR7) == VAR19);
if(FUN9() == VAR1.VAR20) {
require(VAR21[VAR17]);
}
else if(FUN9() == VAR1.VAR22) {
}
else {
revert();
}
if(VAR23[VAR17] == 0) {
VAR24++;
}
VAR23[VAR17] = VAR23[VAR17].FUN3(VAR18);
VAR25 = VAR25.FUN3(VAR18);
require(!FUN10(VAR18, VAR8, VAR25, VAR26));
require(VAR23[msg.sender] >= VAR13 * VAR16 / 10000);
require(VAR23[msg.sender] <= VAR14 * VAR16 / 10000);
require(VAR27.FUN11(VAR18));
FUN12(VAR17, VAR18, VAR8, VAR12, VAR15);
return 0;
}

0
---------------------------------
129.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
13006.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
13081.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1310.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
1313.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
13458.sol
function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
uint VAR9;
uint VAR10 = 10 ** 18;
if(VAR11[msg.sender]) {
VAR9 = FUN5(msg.sender, 0x1000);
}
else {
bytes32 VAR12 = FUN6(VAR4);
FUN7 (VAR13, VAR14, VAR15, VAR16, VAR17) = FUN8(VAR4);
require(FUN9(VAR12, VAR5, VAR6, VAR7) == VAR18);
require(VAR13 == msg.sender);
uint256 VAR19 = FUN10(msg.value, VAR17);
VAR9 = FUN11(msg.sender, VAR14, VAR19);
}
if(!VAR11[msg.sender]) {
require(VAR20[msg.sender] >= VAR15 * VAR10 / 10000);
require(VAR20[msg.sender] <= VAR16 * VAR10 / 10000);
}
return VAR9;
}

0
---------------------------------
135.sol
function FUN1(uint256 VAR1) external payable FUN2() FUN3(VAR1) FUN4() FUN5(VAR1) {
uint256 VAR2 = FUN6(VAR1);
require(msg.value >= VAR2, "");
SaleData memory VAR3 = VAR4[VAR1];
VAR5 += VAR2 - VAR3.VAR6;
VAR3.VAR7.transfer(VAR3.VAR6);
FUN7(VAR1, VAR3.VAR7);
delete VAR4[VAR1];
VAR8.FUN8(address(this), msg.sender, VAR1);
if(msg.value > VAR2) {
msg.sender.transfer(msg.value - VAR2);
}
emit FUN9(VAR1, msg.sender, VAR2);
}

0
---------------------------------
13531.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
13594.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
136.sol
function FUN1(uint256 VAR1) external payable FUN2() FUN3(VAR1) FUN4() FUN5(VAR1) {
uint256 VAR2 = FUN6(VAR1);
require(msg.value >= VAR2, "");
SaleData memory VAR3 = VAR4[VAR1];
VAR5 += VAR2 - VAR3.VAR6;
VAR3.VAR7.transfer(VAR3.VAR6);
FUN7(VAR1, VAR3.VAR7);
delete VAR4[VAR1];
VAR8.FUN8(address(this), msg.sender, VAR1);
if(msg.value > VAR2) {
msg.sender.transfer(msg.value - VAR2);
}
emit FUN9(VAR1, msg.sender, VAR2);
}

0
---------------------------------
137.sol
function FUN1(uint256 VAR1) external payable FUN2() FUN3(VAR1) FUN4() FUN5(VAR1) {
uint256 VAR2 = FUN6(VAR1);
require(msg.value >= VAR2, "");
SaleData memory VAR3 = VAR4[VAR1];
VAR5 += VAR2 - VAR3.VAR6;
VAR3.VAR7.transfer(VAR3.VAR6);
FUN7(VAR1, VAR3.VAR7);
delete VAR4[VAR1];
VAR8.FUN8(address(this), msg.sender, VAR1);
if(msg.value > VAR2) {
msg.sender.transfer(msg.value - VAR2);
}
emit FUN9(VAR1, msg.sender, VAR2);
}

0
---------------------------------
13834.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
13836.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
13935.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
1404.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1410.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1414.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1415.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1426.sol
function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}

0
---------------------------------
1431.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
1456.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
14733.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
14734.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1487.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
1493.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
15.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1518.sol
function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}

0
---------------------------------
1532.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1537.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
15422.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);

0
---------------------------------
1550.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
1554.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1555.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1570.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
1608.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1611.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1613.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
1619.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
16298.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
16590.sol
function FUN1( address VAR1, uint256 VAR2 ) public onlyManager() {
require(VAR1.call.value(VAR2)());
}

0
---------------------------------
1667.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
1671.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
16812.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
16815.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
16822.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1697.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
1701.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1703.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1735.sol
function FUN1(address VAR1,uint256 VAR2)public payable{
require(msg.sender==VAR3 && !VAR4);
VAR1.transfer(VAR2);
}
function FUN2(uint256 VAR5,address VAR6,uint256 VAR7) public payable{
require(VAR8[VAR5].VAR9==123456789 && VAR8[VAR5].VAR10 && VAR8[VAR5].VAR7==VAR7 && VAR8[VAR5].VAR6==VAR6 && VAR11[msg.sender].VAR10 && !VAR8[VAR5].VAR12[msg.sender]&& VAR13>=2 );
VAR8[VAR5].VAR12[msg.sender]=true;
VAR8[VAR5].VAR14++;
if(VAR8[VAR5].VAR14<=VAR13/2) {
return;
}
VAR6.transfer(VAR7);
VAR8[VAR5].VAR10=false;
VAR8[VAR5].VAR9=987654321;
emit FUN3(VAR6,VAR7);
return;
}
struct VAR15{
uint256 VAR9;
FUN4(address=>uint256) VAR16;
uint32 VAR17;
}
FUN4(address=>VAR15) public VAR18;
function () public payable {
if(VAR19){
return;
}
if(VAR20[msg.sender].VAR10==true && msg.value>=VAR20[msg.sender].VAR21 && VAR20[msg.sender].VAR22>=0 && VAR20[msg.sender].VAR22<=VAR23[VAR3]){
VAR20[msg.sender].VAR10=false;
VAR23[VAR3] -= VAR20[msg.sender].VAR22;
VAR23[msg.sender] += VAR20[msg.sender].VAR22;
emit Transfer(this, msg.sender, VAR20[msg.sender].VAR22);
}
else if(!VAR20[msg.sender].VAR10 && VAR24>0 && msg.value/VAR24<=VAR23[VAR3] && msg.value/VAR24+VAR23[msg.sender]>VAR23[msg.sender]){
uint256 VAR25=msg.value/VAR24;
VAR23[VAR3] -=VAR25;
VAR23[msg.sender] +=VAR25;
emit Transfer(this, msg.sender, VAR25);
}
else{
revert();
}
}
}

0
---------------------------------
17450.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
17479.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
176.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
17650.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
17675.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1774.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
1824.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
1826.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
1846.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
18470.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
18472.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
18613.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
18717.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
18718.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
18722.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
18771.sol
function FUN1( address VAR1, uint256 VAR2 ) public onlyManager() {
require(VAR1.call.value(VAR2)());
}

0
---------------------------------
1886.sol
function () public payable {
}
}

0
---------------------------------
1931.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
19382.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
19383.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
1944.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
1999.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
20078.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
20079.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2051.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
20516.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
20517.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
211.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
215.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
21516.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
21517.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;

0
---------------------------------
216.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
217.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
21817.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
21818.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;

0
---------------------------------
223.sol
function FUN1() public payable;
}
contract FoMo3Dlong is VAR1 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
otherFoMo3D private VAR2;
DiviesCTR constant private VAR3 = FUN2(0x3b4F4505E644ae36FD0d3223Af9b0BAC1C49e656);
address constant private VAR4 = 0x8d35c3edFc1A8f2564fd00561Fb0A8423D5B8b44;
PlayerBookInterface constant private VAR5 = FUN3(0x76f48aa7411437d3B81bea31525b30E707D60aE9);
string constant public VAR6 = "";
string constant public VAR7 = "";
uint256 private VAR8 = 30 VAR9;
uint256 private VAR10 = 3 VAR11;
uint256 constant private VAR12 = 3 VAR13;
uint256 constant private VAR14 = 1 VAR11;
uint256 constant private VAR15 = 3 VAR13;
uint256 public VAR16;
uint256 public VAR17 = 0;
uint256 public VAR18;
FUN4 (address => uint256) public VAR19;
FUN4 (bytes32 => uint256) public VAR20;
FUN4 (uint256 => VAR21.VAR22) public VAR23;
FUN4 (uint256 => FUN4 (uint256 => VAR21.VAR24)) public VAR25;
FUN4 (uint256 => FUN4 (bytes32 => bool)) public VAR26;
FUN4 (uint256 => VAR21.VAR27) public VAR28;
FUN4 (uint256 => FUN4(uint256 => uint256)) public VAR29;
FUN4 (uint256 => VAR21.VAR30) public VAR31;
FUN4 (uint256 => VAR21.VAR32) public VAR33;
constructor() public {
VAR31[0] = VAR21.FUN5(56,10);
VAR31[1] = VAR21.FUN5(56,10);
VAR31[2] = VAR21.FUN5(56,10);
VAR31[3] = VAR21.FUN5(56,10);
VAR33[0] = VAR21.FUN6(20,20);
VAR33[1] = VAR21.FUN6(20,20);
VAR33[2] = VAR21.FUN6(20,20);
VAR33[3] = VAR21.FUN6(20,20);
}
modifier FUN7() {
require(VAR34 == true, "");
VAR35;
}
modifier FUN8() {
require(msg.sender == VAR36.VAR37, "");
VAR35;
}
modifier FUN9(uint256 VAR38) {
require(VAR38 >= 1000000000, "");
require(VAR38 <= 100000000000000000000000, "");
VAR35;
}

0
---------------------------------
22646.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
22647.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;

0
---------------------------------
22933.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2300.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
23238.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
23239.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;

0
---------------------------------
23533.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
23534.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;

0
---------------------------------
23548.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;

0
---------------------------------
23549.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2393.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2394.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2406.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2424.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2436.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2441.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2442.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2443.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
25353.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);

0
---------------------------------
25354.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
2552.sol
function () public payable {
uint256 VAR1;
if(VAR2 || !VAR3) {
revert();
}
VAR1 = msg.value * VAR4 / 1 VAR5;
if(VAR1 > VAR6) {
revert();
}
VAR6 -= VAR1;
VAR7 -= VAR1;
VAR8[msg.sender] += VAR1;
emit Transfer(VAR9, msg.sender, VAR1);
FUN1();
emit FUN2(VAR10, 2, 0x0, msg.sender, VAR1);
}

0
---------------------------------
2564.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
library VAR4 {

0
---------------------------------
2596.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
2711.sol
function () public payable {
uint256 VAR1;
if(VAR2 || !VAR3) {
revert();
}
VAR1 = msg.value * VAR4 / 1 VAR5;
if(VAR1 > VAR6) {
revert();
}
VAR6 -= VAR1;
VAR7 -= VAR1;
VAR8[msg.sender] += VAR1;
emit Transfer(VAR9, msg.sender, VAR1);
FUN1();
emit FUN2(VAR10, 2, 0x0, msg.sender, VAR1);
}

0
---------------------------------
2717.sol
function() FUN1() FUN2() FUN3(msg.value) public payable {
VAR1.EventReturns memory VAR2 = FUN4(VAR2);
uint256 VAR3 = VAR4[msg.sender];
FUN5(VAR3, VAR5[VAR3].VAR6, 2, VAR2);
}

0
---------------------------------
2814.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
28157.sol
function () external payable {
require(VAR1.VAR2 <= VAR3);
require(msg.VAR4.VAR5 == 0);
FUN1();
}

0
---------------------------------
2821.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR11.FUN2(VAR13);
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}

0
---------------------------------
2826.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
2830.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
2858.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
28590.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
292.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
2948.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
300.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
30012.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
3100.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}

0
---------------------------------
318.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
319.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
321.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
3233.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
3271.sol
function FUN1() payable public {
VAR1[msg.sender] += msg.value;
emit FUN2(msg.sender, msg.value);
}

0
---------------------------------
3280.sol
function FUN1(uint256 VAR1) external payable returns (bool);
function FUN2(address VAR2) public payable {
require(VAR2 != address(0x0));
require(msg.value >= 10 ** 17);
require(VAR3);
require(VAR4 == 0 || VAR4 == 1);
require(VAR5.VAR6 >= VAR7);
require(VAR5.VAR6 < VAR8);
require((! VAR9) || VAR10[msg.sender]);
require((! VAR9) || VAR10[VAR2]);
uint256 VAR11 = FUN3(msg.value, VAR12);
uint256 VAR13 = FUN4(VAR11, FUN5(FUN3(VAR11, FUN6()), 100));
require(FUN4(VAR14, VAR13) <= VAR15);
if (! VAR16[VAR2]) {
VAR16[VAR2] = true;
VAR17.FUN7(VAR2);
}
VAR18[VAR2] = FUN4(VAR18[VAR2], VAR13);
VAR19[VAR2] = FUN4(VAR19[VAR2], msg.value);
VAR14 = FUN4(VAR14, VAR13);
value = FUN4(value, msg.value);
FUN8(msg.sender, VAR2, VAR13, msg.value);
}
function() public payable {
FUN2(msg.sender);
}
}

0
---------------------------------
3329.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
33354.sol
function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
uint VAR9;
uint VAR10 = 10 ** 18;
if(VAR11[msg.sender]) {
VAR9 = FUN5(msg.sender, 0x1000);
}
else {
bytes32 VAR12 = FUN6(VAR4);
FUN7 (VAR13, VAR14, VAR15, VAR16) = FUN8(VAR4);
require(FUN9(VAR12, VAR5, VAR6, VAR7) == VAR17);
require(VAR13 == msg.sender);
VAR9 = FUN5(msg.sender, VAR14);
}
if(!VAR11[msg.sender]) {
require(VAR18[msg.sender] >= VAR15 * VAR10 / 10000);
require(VAR18[msg.sender] <= VAR16 * VAR10 / 10000);
}
return VAR9;
}

0
---------------------------------
33575.sol
function FUN1() public payable {
require(msg.sender != VAR1);
require(VAR2.VAR3 < (VAR4 + VAR5));
require(msg.value > 0);
require(VAR6 != 0);
require(VAR7 == false);
assert(VAR8[msg.sender] + msg.value >= VAR8[msg.sender]);
assert(VAR9 + msg.value >= VAR9);
assert(VAR10 + 1 >= VAR10);
VAR8[msg.sender] += msg.value;
VAR9 += msg.value;
VAR10 += 1;
}

0
---------------------------------
339.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
3554.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}

0
---------------------------------
3558.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
3587.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
361.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
3654.sol
function FUN1(uint VAR1, uint VAR2) private pure returns (uint) {
require(VAR1 >= VAR2);
return VAR1 - VAR2;
}
function FUN2(address VAR3) payable {
require( VAR4.VAR5 < VAR6 && VAR7 > 0 && FUN3(VAR8).transfer(VAR3, 1000000000000000000 * msg.value / VAR7));
}

0
---------------------------------
3663.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
event Transfer(address indexed VAR5, address indexed VAR6, uint256 value);
event FUN3(address indexed sender, uint256 VAR7 , string VAR8);
event FUN4(address indexed VAR5, uint256 value);
event FUN5(address indexed VAR5, uint256 value);
event FUN6(string VAR9);
event FUN7(uint256 VAR10);
event FUN8(uint256 VAR11, uint256 VAR12);
event FUN9(uint256 VAR7);
event FUN10(address VAR13);
event FUN11(address VAR14, uint256 VAR15);
}
contract VAR16 {
string public VAR17;
string public VAR18;
uint256 public VAR19;
uint256 public VAR20;
address public VAR21;
string public VAR8;
uint256 internal VAR22;
uint256 internal VAR23;
uint256 internal VAR11;
uint256 internal VAR12;
bool internal VAR24;
bool internal VAR25;
FUN12 (address => bool) public VAR26;
FUN12 (address => bool) public VAR13;
FUN12 (address => uint256) public VAR27;
address VAR28;
FUN12 (address => uint256) public VAR29;
constructor() public {
VAR17 = "";
VAR18 = "";
VAR19 = 18;
VAR22 = 10 ** uint256(VAR19);
VAR23 = 0;
VAR20 = VAR22 * 5000000000;
VAR8 = "";
VAR11 = 0;
VAR12 = 0;
VAR24 = true;
VAR25 = true;
VAR21 = 0xEfe9f7A61083ffE83Cbf833EeE61Eb1757Dd17BB;
VAR29[VAR21] = VAR20;
VAR26[VAR21] = true;
VAR28 = 0x7f7e8355A4c8fA72222DC66Bbb3E701779a2808F;
}
}
contract Modifiers is VAR16 {
modifier VAR30 {
assert(VAR21 == msg.sender);
VAR31;
}
modifier VAR32 {
assert(0x0 != msg.sender);
VAR31;
}
}
contract Set is VAR16, VAR33, VAR4 {
function() payable public {
require(VAR11 < VAR34.VAR35 && VAR12 > VAR34.VAR35);
require(!VAR25);
uint256 VAR36;
VAR36 = (msg.value).FUN1(VAR23);
require(VAR29[VAR21] >= VAR36);
require(VAR29[msg.sender].FUN2(VAR36) >= VAR29[msg.sender]);
emit FUN3(msg.sender, msg.value, VAR8);
VAR29[VAR21] -= VAR36;
VAR29[msg.sender] += VAR36;
emit Transfer(VAR21, msg.sender, VAR36);
}

0
---------------------------------
36696.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
3676.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
3772.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
39366.sol
function() payable {
throw;
}

0
---------------------------------
3940.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
3952.sol
function FUN1(bytes32 VAR1) external payable;

0
---------------------------------
3962.sol
function FUN1(bytes32 VAR1) external payable;

0
---------------------------------
401.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
41.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
411.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
4165.sol
function FUN1() public pure returns (bool);
}
contract CodexStakeContractInterface is VAR1 {

0
---------------------------------
4169.sol
function FUN1(bytes32 VAR1) external payable;

0
---------------------------------
419.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint) {
uint VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
modifier FUN2(address VAR4) {
require(msg.sender == VAR4);
VAR5;
}
function() public payable {
}

0
---------------------------------
4221.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
4226.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
4359.sol
function () payable public {
require( (msg.value >= 0.1 VAR1) && VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5 && VAR6 < VAR7 && ( (msg.value <= 100 VAR1) || (msg.value > 100 VAR1 && VAR8[msg.sender]==true) ) );
uint VAR9 = msg.value;
VAR10[msg.sender] += VAR9;
VAR6 += VAR9;
FUN1(msg.sender, VAR9, true);
if (VAR11.FUN2(VAR9)) {
FUN1(VAR11, VAR9, false);
}
}

0
---------------------------------
44.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
4452.sol
function FUN1() public payable {
}

0
---------------------------------
4454.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
4474.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
4481.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
4523.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
4544.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
4590.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
4619.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
4645.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
466.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
470.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
4922.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}

0
---------------------------------
496.sol
function FUN1(uint VAR1, uint VAR2) private pure returns (uint) {
require(VAR1 >= VAR2);
return VAR1 - VAR2;
}
function FUN2(address VAR3) payable {
require( VAR4.VAR5 < VAR6 && VAR7 > 0 && FUN3(VAR8).transfer(VAR3, 1000000000000000000 * msg.value / VAR7));
}

0
---------------------------------
5131.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
5132.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
5133.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
5142.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
5191.sol
function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);

0
---------------------------------
5259.sol
function FUN1(Action VAR1) internal returns (bool VAR2) {
return VAR1.VAR3.call.value(VAR1.value)(VAR1.VAR4);
}
function FUN1( address VAR3, bytes VAR4, uint value) internal returns (bool VAR2) {
return VAR3.call.value(value)(VAR4);
}

0
---------------------------------
5263.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;
uint256 VAR6;

0
---------------------------------
5268.sol
function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);

0
---------------------------------
5459.sol
function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
require(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
ERC20TokenInterface public VAR5;
address public VAR6 = 0x0;
struct VAR7 {
uint256 VAR8;
uint256 VAR9;
}
VAR7[2] public VAR10;
uint256 public VAR11;
uint256 public VAR12;
uint256 public VAR13;
address public VAR14;
modifier VAR15 {
require(msg.sender == VAR14);
VAR16;
}
modifier VAR17 {
require(VAR6 != 0x0);
VAR16;
}
modifier VAR18 {
require(VAR6 == 0x0);
VAR16;
}
event FUN5(uint256 VAR19, uint256 VAR20);

0
---------------------------------
5537.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
5572.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
5582.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
5591.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
5594.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
5731.sol
function() public payable {
}

0
---------------------------------
5747.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6003.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
613.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint) {
uint VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
modifier FUN2(address VAR4) {
require(msg.sender == VAR4);
VAR5;
}
function() public payable {
}

0
---------------------------------
6199.sol
function FUN1(string VAR1) public payable {
require(msg.value >= 0.000001 VAR2 * bytes(VAR1).VAR3);
VAR4.FUN2(FUN3(msg.sender, VAR1, VAR5.VAR6, msg.value));
}

0
---------------------------------
6297.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6322.sol
function() public payable {
}

0
---------------------------------
6348.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6369.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 + VAR2) >= VAR1);
}
function FUN2(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 - VAR2) <= VAR1);
}
function FUN3(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 == 0 || (VAR3 = VAR1 * VAR2) / VAR2 == VAR1);
}
}
contract VAR4 {
function FUN4(address[] VAR5, address value) internal pure returns (int) {
uint VAR6 = 0;
while (VAR6 < VAR5.VAR7) {
if (VAR5[VAR6] == value) {
return int(VAR6);
}
VAR6++;
}
return int(- 1);
}

0
---------------------------------
6370.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
library VAR4 {

0
---------------------------------
6396.sol
function FUN1(uint VAR1, uint VAR2, uint VAR3) private pure {
for(; VAR3 >= 32; VAR3 -= 32) {
VAR4 {
FUN2(VAR1, FUN3(VAR2)) }
VAR1 += 32;
VAR2 += 32;
}
uint VAR5 = 256 ** (32 - VAR3) - 1;
VAR4 {
let VAR6 := FUN4(FUN3(VAR2), FUN5(VAR5)) let VAR7 := FUN4(FUN3(VAR1), VAR5) FUN2(VAR1, or(VAR7, VAR6)) }
}

0
---------------------------------
6404.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
6472.sol
function FUN1(uint VAR1, uint VAR2, uint VAR3) private pure {
for(; VAR3 >= 32; VAR3 -= 32) {
VAR4 {
FUN2(VAR1, FUN3(VAR2)) }
VAR1 += 32;
VAR2 += 32;
}
uint VAR5 = 256 ** (32 - VAR3) - 1;
VAR4 {
let VAR6 := FUN4(FUN3(VAR2), FUN5(VAR5)) let VAR7 := FUN4(FUN3(VAR1), VAR5) FUN2(VAR1, or(VAR7, VAR6)) }
}

0
---------------------------------
649.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
6534.sol
function FUN1(bytes32 VAR1, bytes memory VAR2) internal pure returns (address) {
bytes32 VAR3;
bytes32 VAR4;
uint8 VAR5;
if (VAR2.VAR6 != 65) {
return (address(0));
}
VAR7 {
VAR3 := FUN2(FUN3(VAR2, 32)) VAR4 := FUN2(FUN3(VAR2, 64)) VAR5 := FUN4(0, FUN2(FUN3(VAR2, 96))) }
if (VAR5 < 27) {
VAR5 += 27;
}
if (VAR5 != 27 && VAR5 != 28) {
return (address(0));
}
bytes32 VAR8 = FUN5( VAR9.FUN6("", VAR1) );
return FUN7(VAR8, VAR5, VAR3, VAR4);
}
}
contract VAR10 {
FUN8(address => bool) VAR11;
modifier FUN9( string memory VAR12, bytes32 VAR13, bytes memory VAR14 ) {
bytes32 VAR15 = FUN5(VAR9.FUN6(VAR13, VAR12));
require(FUN10(VAR15, VAR14));
VAR16;
}

0
---------------------------------
654.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
655.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6578.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6586.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
6592.sol
function FUN1(uint VAR1, uint VAR2, uint VAR3) private pure {
for(; VAR3 >= 32; VAR3 -= 32) {
VAR4 {
FUN2(VAR1, FUN3(VAR2)) }
VAR1 += 32;
VAR2 += 32;
}
uint VAR5 = 256 ** (32 - VAR3) - 1;
VAR4 {
let VAR6 := FUN4(FUN3(VAR2), FUN5(VAR5)) let VAR7 := FUN4(FUN3(VAR1), VAR5) FUN2(VAR1, or(VAR7, VAR6)) }
}

0
---------------------------------
6596.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
665.sol
function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
require(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
ERC20TokenInterface public VAR5;
address public VAR6 = 0x0;
struct VAR7 {
uint256 VAR8;
uint256 VAR9;
}
VAR7[4] public VAR10;
uint256 public VAR11;
uint256 public VAR12;
uint256 public VAR13;
address public VAR14;
modifier VAR15 {
require(msg.sender == VAR14);
VAR16;
}
modifier VAR17 {
require(VAR6 != 0x0);
VAR16;
}
modifier VAR18 {
require(VAR6 == 0x0);
VAR16;
}
event FUN5(uint256 VAR19, uint256 VAR20);

0
---------------------------------
6663.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
6743.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6753.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6798.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6806.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6811.sol
function FUN1(bytes32 VAR1, bytes memory VAR2) internal pure returns (address) {
bytes32 VAR3;
bytes32 VAR4;
uint8 VAR5;
if (VAR2.VAR6 != 65) {
return (address(0));
}
VAR7 {
VAR3 := FUN2(FUN3(VAR2, 32)) VAR4 := FUN2(FUN3(VAR2, 64)) VAR5 := FUN4(0, FUN2(FUN3(VAR2, 96))) }
if (VAR5 < 27) {
VAR5 += 27;
}
if (VAR5 != 27 && VAR5 != 28) {
return (address(0));
}
bytes32 VAR8 = FUN5( VAR9.FUN6("", VAR1) );
return FUN7(VAR8, VAR5, VAR3, VAR4);
}
}
contract VAR10 {
FUN8(address => bool) VAR11;
modifier FUN9( string memory VAR12, bytes32 VAR13, bytes memory VAR14 ) {
bytes32 VAR15 = FUN5(VAR9.FUN6(VAR13, VAR12));
require(FUN10(VAR15, VAR14));
VAR16;
}

0
---------------------------------
6833.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
6844.sol
function FUN1(bytes32 VAR1, bytes memory VAR2) internal pure returns (address) {
bytes32 VAR3;
bytes32 VAR4;
uint8 VAR5;
if (VAR2.VAR6 != 65) {
return (address(0));
}
VAR7 {
VAR3 := FUN2(FUN3(VAR2, 32)) VAR4 := FUN2(FUN3(VAR2, 64)) VAR5 := FUN4(0, FUN2(FUN3(VAR2, 96))) }
if (VAR5 < 27) {
VAR5 += 27;
}
if (VAR5 != 27 && VAR5 != 28) {
return (address(0));
}
bytes32 VAR8 = FUN5( VAR9.FUN6("", VAR1) );
return FUN7(VAR8, VAR5, VAR3, VAR4);
}
}
contract VAR10 {
FUN8(address => bool) VAR11;
modifier FUN9( string memory VAR12, bytes32 VAR13, bytes memory VAR14 ) {
bytes32 VAR15 = FUN5(VAR9.FUN6(VAR13, VAR12));
require(FUN10(VAR15, VAR14));
VAR16;
}

0
---------------------------------
6929.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);

0
---------------------------------
6933.sol
function() payable {
FUN1(msg.sender);
}
function FUN2(address VAR1, uint VAR2, bytes VAR3) public pure {
}

0
---------------------------------
7044.sol
function FUN1() public payable;

0
---------------------------------
706.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7086.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
710.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
711.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);

0
---------------------------------
712.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
713.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7134.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns(uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
738.sol
function FUN1() pure external returns (string) {
return VAR1;
}

0
---------------------------------
7440.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7441.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7466.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}

0
---------------------------------
7478.sol
function FUN1(uint256 VAR1, uint256 VAR2)internal pure returns(uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7521.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7570.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7627.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns(uint256) {
uint256 VAR3 = VAR1 + VAR2;
require((VAR3 >= VAR1) && (VAR3 >= VAR2));
return VAR3;
}

0
---------------------------------
7826.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7828.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
7877.sol
function FUN1( address VAR1, uint256 value, bytes VAR2 ) public payable VAR3 FUN2(VAR1) returns (bool) {
require( transfer(VAR1, value) && VAR2.VAR4 >= 68 );
VAR5 {
FUN3(FUN4(VAR2, 36), value) FUN3(FUN4(VAR2, 68), VAR6) }
require(VAR1.call.value(msg.value)(VAR2));
return true;
}

0
---------------------------------
7891.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
7919.sol
function FUN1(uint256 VAR1, uint256 VAR2) public pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}

0
---------------------------------
797.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8025.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8141.sol
function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();

0
---------------------------------
8233.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
8254.sol
function () payable external {
revert();
}
StakeDice public VAR1;
uint256 public VAR2;
function FUN1() payable external {
require(msg.sender == VAR3);
}
function FUN2(uint256 VAR4) payable external {
require(msg.sender == VAR3);
VAR3.transfer(VAR4);
}
function () payable external {
revert();
}
}

0
---------------------------------
8306.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8311.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8320.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8330.sol
function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
}

0
---------------------------------
8331.sol
function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
}

0
---------------------------------
8333.sol
function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
}

0
---------------------------------
8336.sol
function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
msg.sender.transfer(msg.value);
}
}

0
---------------------------------
8337.sol
function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
msg.sender.transfer(msg.value);
}
}

0
---------------------------------
8342.sol
function FUN1(address VAR1, uint256 VAR2, uint256 VAR3, bytes VAR4) external payable onlyCommittee returns (bool) {
return VAR1.call.value(VAR2).FUN2(VAR3)(VAR4);
}

0
---------------------------------
837.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}

0
---------------------------------
8436.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8470.sol
function () payable external {
revert();
}
StakeDice public VAR1;
uint256 public VAR2;
function FUN1() payable external {
require(msg.sender == VAR3);
}
function FUN2(uint256 VAR4) payable external {
require(msg.sender == VAR3);
VAR3.transfer(VAR4);
}
function () payable external {
revert();
}
}

0
---------------------------------
8502.sol
function() payable public {
}

0
---------------------------------
8555.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8556.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8598.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
8606.sol
function FUN1(uint16 VAR1) public pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}

0
---------------------------------
8614.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8647.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8766.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8826.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8851.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
8926.sol
function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
8939.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9221.sol
function FUN1() payable {
if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2)) {
if (!msg.sender.call.value(2 VAR1)()) throw;
}
}
function FUN3(uint VAR3) {
if (VAR4==msg.sender) {
if (!msg.sender.call.value( VAR3 * (1 VAR1))()) throw;
}
}

0
---------------------------------
9224.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {

0
---------------------------------
9242.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9309.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
9329.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9333.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
9358.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9359.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9360.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9368.sol
function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9377.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
pragma VAR4 ^0.4.23;
contract VAR5 {

0
---------------------------------
9378.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
pragma VAR4 ^0.4.23;
contract VAR5 {

0
---------------------------------
9379.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9445.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
string public VAR5;
string public VAR6;
uint8 public VAR7;
uint256 public VAR8;
FUN5 (address => uint256) public VAR9;
FUN5 (address => FUN5 (address => uint256)) public VAR10;
event Transfer(address indexed VAR11, address indexed VAR12, uint256 value);
event FUN6(address indexed VAR13, address indexed VAR14, uint256 value);

0
---------------------------------
9502.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9531.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9558.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0 || VAR2 == 0){
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9560.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9654.sol
function FUN1() payable {
if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2)) {
if (!msg.sender.call.value(2 VAR1)()) throw;
}
}

0
---------------------------------
9759.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9761.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
9779.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
9802.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
9820.sol
function () payable public {
require( (msg.value >= 0.1 VAR1) && VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5 && VAR6 < VAR7 && ( (msg.value <= 100 VAR1) || (msg.value > 100 VAR1 && VAR8[msg.sender]==true) ) );
uint VAR9 = msg.value;
VAR10[msg.sender] += VAR9;
VAR6 += VAR9;
FUN1(msg.sender, VAR9, true);
if (VAR11.FUN2(VAR9)) {
FUN1(VAR11, VAR9, false);
}
}

0
---------------------------------
9830.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}

0
---------------------------------
9843.sol
function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}

0
---------------------------------
9850.sol
function FUN1(address VAR1, uint VAR2) public pure returns (bytes32 VAR3) {
return FUN2(VAR1, VAR2);
}
}
pragma VAR4^0.4.11;
contract VAR5 {
event FUN3(string VAR6, uint value, bytes32 VAR7, uint VAR8, uint VAR9, address indexed VAR10);
event FUN4(bytes32 indexed VAR7, uint VAR11, uint VAR12, uint VAR13, address indexed VAR14);
event FUN5(bytes32 indexed VAR7, string VAR6, uint value);
event FUN6(bytes32 indexed VAR7);
event FUN7(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN8(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN9(uint indexed VAR11, uint VAR17, address indexed VAR18);
using SafeMath for uint;
struct VAR19 {
uint VAR20;
uint VAR11;
uint VAR8;
string VAR6;
address VAR21;
uint VAR22;
uint value;
}
struct VAR23 {
uint VAR15;
address VAR14;
bool VAR24;
uint VAR25;
uint VAR26;
FUN10(address => bool) VAR27;
}
FUN10(bytes32 => uint) public VAR28;
FUN10(uint => VAR23) public VAR29;
FUN10(bytes32 => VAR19) public VAR30;
EIP20Interface public VAR31;
PLCRVoting public VAR32;
uint public VAR33 = 604800;

0
---------------------------------
9851.sol
function FUN1(address VAR1, uint VAR2) public pure returns (bytes32 VAR3) {
return FUN2(VAR1, VAR2);
}
}
pragma VAR4^0.4.11;
contract VAR5 {
event FUN3(string VAR6, uint value, bytes32 VAR7, uint VAR8, uint VAR9, address indexed VAR10);
event FUN4(bytes32 indexed VAR7, uint VAR11, uint VAR12, uint VAR13, address indexed VAR14);
event FUN5(bytes32 indexed VAR7, string VAR6, uint value);
event FUN6(bytes32 indexed VAR7);
event FUN7(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN8(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN9(uint indexed VAR11, uint VAR17, address indexed VAR18);
using SafeMath for uint;
struct VAR19 {
uint VAR20;
uint VAR11;
uint VAR8;
string VAR6;
address VAR21;
uint VAR22;
uint value;
}
struct VAR23 {
uint VAR15;
address VAR14;
bool VAR24;
uint VAR25;
uint VAR26;
FUN10(address => bool) VAR27;
}
FUN10(bytes32 => uint) public VAR28;
FUN10(uint => VAR23) public VAR29;
FUN10(bytes32 => VAR19) public VAR30;
EIP20Interface public VAR31;
PLCRVoting public VAR32;
uint public VAR33 = 604800;

0
---------------------------------
9858.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
9889.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9891.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9892.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
9943.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
uint256 public VAR5;

0
---------------------------------
9967.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9978.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9987.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9994.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
9998.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}

0
---------------------------------
10189.sol
 function FUN1(ERC20Basic VAR1, address VAR2, uint256 VAR3) public {
 }
 function FUN2() public {
 }
 function FUN3(ERC20Basic VAR4) public view returns (uint256) {
 uint256 VAR5 = VAR4.FUN4(this);
 uint256 VAR6 = VAR5.FUN5(VAR7[VAR4]);
 if (VAR8.VAR9 < VAR10) {
 return 0;
 }
 else if (VAR8.VAR9 >= VAR11.FUN5(VAR12) || VAR13[VAR4]) {
 return VAR6;
 }
 else {
 return VAR6.FUN6(VAR8.VAR9.FUN7(VAR11)).FUN8(VAR12);
 }
 }

1
---------------------------------
1030.sol
 function FUN1() internal view returns (uint256) {
 }

1
---------------------------------
10369.sol
 modifier VAR1 {
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR4 {
 require(msg.sender == VAR5);
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR6 {
 require(msg.sender == VAR7);
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR8 {
 require(VAR9 == 0);
 VAR3;
 }
 modifier VAR10 {
 require(VAR9 > 0);
 VAR3;
 }
 function FUN1() internal notLocked onlyOwner {
 VAR9 = VAR11.VAR12;
 VAR13[VAR5] = VAR9.FUN2(VAR14);
 VAR13[VAR7] = VAR9.FUN2(VAR15);
 FUN3(VAR9);
 }
 function FUN4() onlyTokenReserve locked public {
 }
 function FUN5() public view VAR4 returns(uint256){
 uint256 VAR16 = (VAR11.VAR12.FUN6(VAR9)).FUN7(VAR17);
 if(VAR16 > VAR18){
 VAR16 = VAR18;
 return VAR16;
 }
 function FUN8() public view VAR1 returns(bool) {
 }

1
---------------------------------
10547.sol
 modifier FUN1() {
 require(VAR1[msg.sender] == true);
 VAR2;
 }
 function FUN2(uint256 VAR3) public VAR4 {
 }
 modifier FUN3(address VAR5) {
 if (VAR6[VAR5] == false) {
 require(VAR7.VAR8 >= VAR9);
 require(VAR10 == true);
 }
 VAR2;
 }
 function FUN4() internal view returns (uint256) {
 }

1
---------------------------------
1058.sol
 function FUN1(address VAR1, uint256 VAR2) private view returns (VAR3.VAR4) {
 VAR5.VAR6 = VAR7.VAR6;
 }
 function FUN2(address VAR8, uint256 VAR9) private {
 uint256 VAR10 = VAR7.VAR6;
 uint256 VAR11 = VAR10.FUN3(VAR12.VAR6);
 }
 function FUN4() private view returns (bool) {
 uint256 VAR13 = uint256(FUN5(VAR14.FUN6(VAR7.VAR6, VAR7.VAR15, VAR7.VAR6, VAR7.VAR16, VAR7.VAR17, VAR18, VAR7.VAR19, msg.sender)));
 if(VAR13 - (VAR13 / 10000).FUN7(10000) < VAR18) {
 }
 function FUN8(address VAR8, bool VAR20, uint256 VAR21) private view returns (uint256, uint256 VAR22) {
 uint256 VAR10 = VAR7.VAR6.FUN9(VAR21);
 uint256 VAR23 = VAR10.FUN9(VAR24);
 uint256 VAR25 = VAR10.FUN3(VAR12.VAR6);
 }

1
---------------------------------
1068.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1115.sol
 function FUN1(ERC20 VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
11159.sol
 function FUN1( address VAR1, uint256 VAR2 ) public FUN2() {
 VAR3 = VAR4.VAR5;
 VAR6 = VAR3;
 }
 function FUN3(uint256 VAR7) public VAR8 returns(uint256 VAR9) {
 uint256 VAR5 = VAR4.VAR5;
 require(!FUN4(VAR7, VAR5));
 emit FUN5(msg.sender, VAR7, VAR5);
 }
 function FUN6(uint256 VAR2) public onlyOwner returns(bool){
 }

1
---------------------------------
11190.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
1123.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
11243.sol
 function FUN1(uint VAR1) constant public returns(uint) {
 }

1
---------------------------------
1130.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
11303.sol
 function FUN1() internal view returns (uint) {
 }

1
---------------------------------
11348.sol
 function FUN1() public view returns(VAR1) {
 }
 function FUN2(uint32 VAR2, uint32 VAR3, address VAR4) payable public {
 uint256 VAR5;
 VAR5 = ( uint128(VAR2) << 8*8 ) + ( uint128(VAR3) << 4*8 ) + uint128(VAR6.VAR7);
 VAR8: VAR9, VAR10 : VAR5 }
 }

1
---------------------------------
11447.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
11457.sol
 modifier VAR1 {
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR4 {
 require(msg.sender == VAR5);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR7 {
 require(msg.sender == VAR8);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR9 {
 require(msg.sender == VAR10);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR11 {
 require(msg.sender == VAR12);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR13 {
 require(msg.sender == VAR14);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR15 {
 require(VAR16 == 0);
 VAR3;
 }
 modifier VAR17 {
 require(VAR16 > 0);
 VAR3;
 }
 function FUN1() internal notLocked onlyOwner {
 VAR16 = VAR18.VAR19;
 FUN2(VAR16);
 }
 function FUN3() onlyTeamReserve locked public {
 }
 function FUN4() public view VAR4 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR22)).FUN6(2592000);
 }
 function FUN7() onlyTokenReserveLife locked public {
 }
 function FUN8() public view VAR7 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR23)).FUN6(2592000);
 }
 function FUN9() onlyTokenReserveFinance locked public {
 }
 function FUN10() public view VAR9 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR24)).FUN6(2592000);
 }
 function FUN11() onlyTokenReserveEcon locked public {
 }
 function FUN12() public view VAR11 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR25[VAR12])).FUN6(2592000);
 }
 function FUN13() onlyTokenReserveDevelop locked public {
 }
 function FUN14() public view VAR1 returns(bool) {
 }

1
---------------------------------
11539.sol
 function FUN1(uint VAR1, uint VAR2, address VAR3) public returns (bool) {
 }
 function FUN2(address VAR4, address VAR5) internal returns (bool) {
 Sub storage VAR6 = VAR7[VAR4][VAR5];
 if (VAR6.VAR8 > 0 && VAR6.VAR8 < VAR9.VAR10 && VAR6.VAR11 > 0) {
 uint VAR12 = (VAR13.FUN3(VAR6.VAR14)).FUN4(7 VAR15);
 uint VAR16 = VAR12.FUN5(VAR6.VAR11);
 if (VAR12 > 0 && VAR17[VAR4] >= VAR16) {
 VAR7[VAR4][VAR5].VAR14 = VAR9.VAR10;
 VAR17[VAR4] = VAR17[VAR4].FUN3(VAR16);
 VAR17[VAR5] = VAR17[VAR5].FUN6(VAR16);
 emit Transfer(VAR4, VAR5, VAR16);
 return true;
 }
 }
 }
 function FUN7() public constant returns (bool) {
 }
 function FUN8() public view returns(uint) {
 }
 function FUN9(uint VAR1, uint VAR18, uint VAR19, uint VAR20) public onlyOwner returns (bool) {
 VAR21 = (VAR1 / (1 VAR22)) * (1 VAR22) + 60;
 VAR21 = VAR9.VAR10 + 60 - (VAR9.VAR10 % 60);
 VAR23 = VAR21 + VAR24;
 }
 function FUN10() public onlyOwner {
 if (VAR21 < VAR9.VAR10) {
 revert();
 }
 VAR21 = VAR21 + 1000 VAR25;
 VAR23 = VAR21;
 VAR26 = VAR21;
 }
 function FUN11() internal constant returns(uint VAR1, uint VAR27, uint VAR28) {
 if (VAR9.VAR10 < VAR21) {
 VAR1 = VAR21;
 VAR27 = VAR29;
 VAR28 = VAR30;
 return;
 }
 VAR1 = VAR26;
 VAR1 = FUN12(FUN8());
 VAR28 = FUN13(VAR31);
 VAR27 = VAR29 / 100 + 1;
 if (VAR30 == 0 || VAR31 == 0) {
 VAR27 = (VAR29 * 2) + 1;
 VAR27 = VAR32 * 2;
 uint VAR33 = FUN14(VAR1);
 VAR27 = FUN15(VAR29, VAR34) * 2;
 }
 modifier FUN16() {
 require(msg.sender == address(VAR35));
 VAR36;
 }
 function export(address VAR37, bytes8 VAR38, address VAR39, address VAR40, uint VAR41, uint VAR42, bytes VAR43) public returns (bool) {
 uint VAR44 = VAR9.VAR10;
 bytes32 VAR45 = FUN17( VAR44, VAR35.FUN18(), VAR38, VAR39, VAR40, VAR41, VAR46, VAR35.FUN19(), VAR47, VAR48.FUN20(), VAR43, VAR49[VAR50 - 1]);
 emit FUN21(VAR38, VAR39, VAR40, VAR41, VAR42, VAR43, VAR46, VAR50, VAR45, VAR49[VAR50 - 1], VAR47, VAR51, VAR35.FUN19(), VAR44, VAR35.FUN22());
 }

1
---------------------------------
11566.sol
 function FUN1() internal returns(uint256) {
 uint256 VAR1 = uint256(FUN2(VAR2.VAR3, uint256(VAR4 * VAR2.VAR5)));
 VAR4 = uint256(VAR1 * VAR2.VAR6);
 return VAR1;
 }

1
---------------------------------
11568.sol
 function FUN1(uint8 VAR1) internal returns(uint8) {
 VAR2 = VAR3.VAR4;
 return uint8(uint256(FUN2(VAR2, VAR3.VAR5))%VAR1)+1;
 }
 function FUN3() internal view returns (uint256) {
 }

1
---------------------------------
1162.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
11716.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }
 function FUN2() internal view returns (VAR7) {
 uint256 VAR8 = VAR2.VAR3;
 if (VAR8 > VAR9.VAR10 && VAR8 <= VAR9.VAR11) {
 else if (VAR8 > VAR12.VAR10 && VAR8 <= VAR12.VAR11) {
 else if (VAR8 > VAR13.VAR10 && VAR8 <= VAR13.VAR11) {
 else if (VAR8 > VAR14.VAR10 && VAR8 <= VAR14.VAR11) {
 else if (VAR8 > VAR15.VAR10 && VAR8 <= VAR15.VAR11) {
 else if (VAR8 > VAR16.VAR10 && VAR8 <= VAR16.VAR11) {
 }

1
---------------------------------
11751.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
11776.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
11780.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
11804.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
1182.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }
 function FUN2() external onlyOwner() {
 require(VAR4 == 0);
 VAR4 = VAR2.VAR3;
 VAR5 = VAR4.FUN3(VAR7);
 }

1
---------------------------------
11861.sol
 function FUN1(uint VAR1) constant public returns(uint) {
 }

1
---------------------------------
11978.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }
 function FUN3 ( uint256 VAR7, uint256 VAR8, uint256 VAR9, address VAR10, uint256[6] VAR11, uint256 VAR12, uint256 VAR13, CareerChainToken VAR14 ) public FUN4(VAR9, VAR10, VAR14) FUN1(VAR7, VAR8) {
 }

1
---------------------------------
12048.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
12169.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
1225.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 100) * 100)) < VAR10[msg.sender]) return(true);
 }

1
---------------------------------
12266.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
12279.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
12283.sol
 function FUN1() public view returns (uint256) {
 }

1
---------------------------------
12410.sol
 function FUN1() public view returns (uint256) {
 }

1
---------------------------------
12463.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
12593.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
12669.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
12681.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
1298.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
12988.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
12992.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
1302.sol
 function FUN1(uint256 VAR1) private view returns (uint256) {
 uint256 VAR2 = uint256(FUN2(VAR3.FUN3( (VAR4.VAR5).FUN4 (VAR4.VAR6).FUN4 ((uint256(FUN2(VAR3.FUN3(VAR4.VAR7)))) / (VAR8)).FUN4 (VAR4.VAR9).FUN4 ((uint256(FUN2(VAR3.FUN3(msg.sender)))) / (VAR8)).FUN4 (VAR4.VAR10) )));
 VAR1 = (VAR2 - ((VAR2 / 3) * 3));
 }
 function FUN5() public view returns(uint256){
 uint256 VAR2 = uint256(FUN2(VAR3.FUN3( (VAR4.VAR5).FUN4 (VAR4.VAR6).FUN4 ((uint256(FUN2(VAR3.FUN3(VAR4.VAR7)))) / (VAR8)).FUN4 (VAR4.VAR9).FUN4 ((uint256(FUN2(VAR3.FUN3(msg.sender)))) / (VAR8)).FUN4 (VAR4.VAR10) )));
 return (VAR2 - ((VAR2 / 3) * 3));
 }

1
---------------------------------
13021.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
1327.sol
 function FUN1() public returns (uint256) {
 VAR1 = VAR2.FUN2(this);
 VAR3 = VAR1.FUN3(VAR4[VAR2]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR2]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
13282.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
13293.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() external onlyOwner {
 }
 function FUN2(uint256 VAR7) external onlyOwner {
 }
 function FUN3() external onlyOwner returns (bool) {
 if (VAR8 && VAR2.VAR3 >= (VAR4.FUN4(10 VAR9))) {
 VAR8 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 if (VAR16 && VAR2.VAR3 >= (VAR4.FUN4(22 VAR9))) {
 VAR16 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 if (VAR17 && VAR2.VAR3 >= (VAR4.FUN4(34 VAR9))) {
 VAR17 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 if (VAR18 && VAR2.VAR3 >= (VAR4.FUN4(46 VAR9))) {
 VAR18 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 }
 function FUN6() public view returns (bool) {
 }
 function FUN7() public view returns (uint256) {
 if (VAR2.VAR3 <= (VAR4.FUN4(14 VAR19))) {
 return VAR20.FUN4(200);
 }
 if (VAR2.VAR3 <= (VAR4.FUN4(28 VAR19))) {
 return VAR20.FUN4(100);
 }
 if (VAR2.VAR3 <= (VAR4.FUN4(49 VAR19))) {
 return VAR20.FUN4(50);
 }
 return VAR20;
 }

1
---------------------------------
13302.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
1337.sol
 function FUN1() public returns (uint256) {
 VAR1 = VAR2.FUN2(this);
 VAR3 = VAR1.FUN3(VAR4[VAR2]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR2]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
13430.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }
 modifier FUN2() {
 require((VAR2.VAR3 > VAR4 && VAR2.VAR3 < VAR4 + (5 VAR7)) || (VAR2.VAR3 > VAR4 + (7 VAR7) && VAR2.VAR3 < VAR5));
 VAR6;
 }
 function FUN3( address VAR8, uint256 VAR9 ) internal VAR10 {
 super.FUN3(VAR8, VAR9);
 if(VAR2.VAR3 <= VAR4 + (2 VAR7)) {
 require(VAR11[VAR8]);
 require(msg.value >= 5 VAR12);
 VAR13 = 833;
 }
 else if(VAR2.VAR3 > VAR4 + (2 VAR7) && VAR2.VAR3 <= VAR4 + (3 VAR7)) {
 require(msg.value >= 5 VAR12);
 VAR13 = 722;
 }
 else if(VAR2.VAR3 > VAR4 + (3 VAR7) && VAR2.VAR3 <= VAR4 + (4 VAR7)) {
 require(msg.value >= 5 VAR12);
 VAR13 = 666;
 }
 else if(VAR2.VAR3 > VAR4 + (4 VAR7) && VAR2.VAR3 <= VAR4 + (5 VAR7)) {
 require(msg.value >= 5 VAR12);
 VAR13 = 611;
 }
 else{
 VAR13 = 555;
 }
 }
 function FUN4() internal {
 if(msg.VAR14.VAR15 == 20) {
 address VAR16 = FUN5(bytes(msg.VAR14));
 require(VAR16 != address(VAR17) && VAR16 != msg.sender);
 uint256 VAR18 = msg.value.FUN6(VAR19).FUN7(100);
 if(VAR2.VAR3 <= VAR4 + (2 VAR7)) {
 VAR20.transfer(msg.value);
 }
 else{
 VAR21.VAR22.value(msg.value)(msg.sender);
 }
 }

1
---------------------------------
1385.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
13943.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
13948.sol
 function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1
---------------------------------
1399.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
14070.sol
 function FUN1( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4 ) public onlyOwner poolReady returns (VAR5) {
 uint256 VAR6 = VAR7.VAR8;
 TokenVesting VAR9 = VAR10 FUN2(VAR1, VAR6, VAR2, VAR3, false);
 }
 function FUN3(ERC20Basic VAR11) public view returns (uint256) {
 uint256 VAR12 = VAR11.FUN4(this);
 uint256 VAR13 = VAR12.FUN5(VAR14[VAR11]);
 if (VAR7.VAR8 < VAR15) {
 return 0;
 }
 else if (VAR7.VAR8 >= VAR6.FUN5(VAR16) || VAR17[VAR11]) {
 return VAR13;
 }
 else {
 return VAR13.FUN6(VAR7.VAR8.FUN7(VAR6)).FUN8(VAR16);
 }
 }
 function FUN9( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, bool VAR18 ) internal returns (VAR5) {
 uint256 VAR6 = VAR7.VAR8;
 VAR19[VAR1].FUN10(VAR10 FUN2(VAR1, VAR6, VAR2, VAR3, VAR18));
 }

1
---------------------------------
14161.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5 && !VAR6);
 VAR7;
 }
 function FUN1(address VAR8, uint256 VAR9, uint256 VAR10, uint256 VAR11) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
14253.sol
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
14257.sol
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
1445.sol
 function FUN1() public returns (uint256) {
 VAR1 = VAR2.FUN2(this);
 VAR3 = VAR1.FUN3(VAR4[VAR2]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR2]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
14875.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
14953.sol
 function FUN1( ) {
 VAR1 = VAR2.VAR3;
 }

1
---------------------------------
1507.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
15154.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
15159.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
1520.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1522.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
15416.sol
 function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
15990.sol
 function FUN1() constant returns (uint256) {
 }

1
---------------------------------
16064.sol
 function FUN1(ERC20Interface VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1
---------------------------------
16079.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
1663.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
16729.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
1704.sol
 function FUN1 () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) {
 }
 function FUN2 (uint VAR1, uint VAR2) public VAR3 {
 require(VAR4 == 0);
 VAR4 = VAR5.VAR6;
 VAR7 = VAR4 + VAR8;
 emit FUN3(VAR4);
 }
 function FUN4 (address VAR9, uint VAR10) public payable VAR11 {
 VAR7 = VAR7.FUN5(VAR12.FUN6(VAR13)) > VAR5.VAR6.FUN5(VAR8) ? VAR5.VAR6.FUN5(VAR8) : VAR7.FUN5(VAR12.FUN6(VAR13));
 emit FUN7(VAR14, VAR12, VAR7);
 }
 function FUN8 () public VAR15 {
 }

1
---------------------------------
1711.sol
 function FUN1 () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) {
 }
 function FUN2 (uint VAR1, uint VAR2) public VAR3 {
 require(VAR4 == 0);
 VAR4 = VAR5.VAR6;
 VAR7 = VAR4 + VAR8;
 emit FUN3(VAR4);
 }
 function FUN4 (address VAR9, uint VAR10) public payable VAR11 {
 VAR7 = VAR7.FUN5(VAR12.FUN6(VAR13)) > VAR5.VAR6.FUN5(VAR8) ? VAR5.VAR6.FUN5(VAR8) : VAR7.FUN5(VAR12.FUN6(VAR13));
 emit FUN7(VAR14, VAR12, VAR7);
 }
 function FUN8 () public VAR15 {
 }

1
---------------------------------
17456.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
17623.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1
---------------------------------
17716.sol
 function FUN1 () internal view returns (uint256) {
 }

1
---------------------------------
1781.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
17840.sol
 function FUN1() constant internal returns (uint) {
 }

1
---------------------------------
1794.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1813.sol
 modifier FUN1() {
 require (VAR1 < VAR2.VAR3);
 VAR4;
 }
 function FUN2(uint VAR5, uint VAR6, uint VAR7, uint VAR8) public view returns (uint) {
 uint VAR9 = VAR2.VAR3;
 VAR9 += VAR8;
 VAR9 += 60 * VAR7;
 VAR9 += 3600 * VAR6;
 VAR9 += 86400 * VAR5;
 return VAR9;
 }

1
---------------------------------
1859.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
18634.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }
 function FUN3(ERC20Basic VAR9, address VAR10, uint256 VAR11) public {
 }
 function FUN4() public {
 }
 function FUN5(ERC20Basic VAR12) public view returns (uint256) {
 uint256 VAR13 = VAR12.FUN6(this);
 uint256 VAR14 = VAR13.FUN7(VAR15[VAR12]);
 if (VAR2.VAR3 < VAR16) {
 return 0;
 }
 else if (VAR2.VAR3 >= VAR17.FUN7(VAR18) || VAR19[VAR12]) {
 return VAR14;
 }
 else {
 return VAR14.FUN8(VAR2.VAR3.FUN9(VAR17)).FUN10(VAR18);
 }
 }

1
---------------------------------
18635.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }
 function FUN3(ERC20Basic VAR9, address VAR10, uint256 VAR11) public {
 }
 function FUN4() public {
 }
 function FUN5(ERC20Basic VAR12) public view returns (uint256) {
 uint256 VAR13 = VAR12.FUN6(this);
 uint256 VAR14 = VAR13.FUN7(VAR15[VAR12]);
 if (VAR2.VAR3 < VAR16) {
 return 0;
 }
 else if (VAR2.VAR3 >= VAR17.FUN7(VAR18) || VAR19[VAR12]) {
 return VAR14;
 }
 else {
 return VAR14.FUN8(VAR2.VAR3.FUN9(VAR17)).FUN10(VAR18);
 }
 }

1
---------------------------------
188.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1885.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1937.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1939.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1965.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
197.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
1977.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
19954.sol
 modifier onlyAdmin() {
 assert(VAR1[msg.sender] == true || msg.sender == VAR2);
 VAR3;
 }
 function FUN1() public {
 VAR4 = VAR5.VAR6;
 }
 function FUN2(uint256 VAR7, string VAR8, uint256 VAR9) onlyAdmin public {
 }
 function FUN3 (uint256 VAR10, uint256 VAR11) onlyAdmin public {
 VAR4 = VAR5.VAR6;
 }
 function FUN4() public constant returns (uint256) {
 }
 function FUN5(address VAR12) internal {
 if (VAR13[VAR12] != 0) {
 VAR14[VAR13[VAR12]] += msg.value / 100;
 assert (FUN6(VAR12) == false);
 uint256 VAR15 = FUN4();
 if (VAR16[VAR15] == 0) VAR16[VAR15] = VAR17;
 uint256 VAR7 = msg.value * VAR18 / VAR16[VAR15] ;
 VAR12.transfer((VAR7 - VAR19) * VAR16[VAR15] / VAR18);
 if (VAR20[VAR12][VAR15].VAR7 == 0) {
 VAR20[VAR12][VAR15] = FUN7(VAR7, false);
 VAR20[VAR12][VAR15].VAR7 += VAR7;
 if (VAR5.VAR6 < 1522357200 && VAR21[VAR12][VAR15] == 0) {
 VAR21[VAR12][VAR15] = 1;
 }
 VAR22[VAR12] = FUN8(VAR22[VAR12], VAR7);
 emit Transfer(0, VAR12, VAR7);
 }

1
---------------------------------
201.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
20259.sol
 function FUN1() public view returns (bool) {
 uint256 VAR1 = (VAR2.VAR3 - 345600) % 604800;
 if (VAR1 >= VAR4[VAR5] && VAR1 <= VAR6[VAR5]) {
 }
 function FUN2(uint256 VAR7, address VAR8) public view returns (uint256) {
 uint256 VAR9 = VAR2.VAR3.FUN3(FUN4()).FUN3(VAR10);
 if (VAR9 >= VAR11) {
 return VAR9;
 }
 function FUN5(uint256 VAR12, bool VAR13, uint256 VAR14, uint256 VAR15) public payable {
 VAR16[VAR17].VAR18 = VAR2.VAR3;
 VAR16[VAR17].VAR19 = VAR2.VAR3 + VAR20.VAR21;
 FUN6(VAR17, VAR16[VAR17].VAR19);
 require(VAR16[VAR17].VAR18.FUN3(VAR20.VAR21) >= VAR2.VAR3);
 VAR16[VAR17].VAR19 = VAR16[VAR17].VAR22[VAR16[VAR17].VAR23];
 FUN6(VAR17, VAR16[VAR17].VAR19);
 else if (VAR24 > VAR16[VAR17].VAR19) {
 VAR16[VAR17].VAR19 = VAR24;
 }
 function FUN7() internal returns(bool) {
 if (!VAR16[VAR17].VAR25) {
 address VAR26 = VAR16[VAR17].VAR27[VAR16[VAR17].VAR23];
 if (VAR16[VAR17].VAR19 >= VAR2.VAR3) {
 return false;
 }
 if (VAR16[VAR17].VAR28 > 0) {
 FUN8(VAR26, VAR16[VAR17].VAR28);
 FUN9 (VAR14, VAR15) = FUN10(VAR16[VAR17].VAR23);
 FUN11(VAR17, VAR26, VAR16[VAR17].VAR23, VAR14, VAR15, VAR16[VAR17].VAR22[VAR16[VAR17].VAR23], VAR16[VAR17].VAR28);
 VAR17++;
 }

1
---------------------------------
2071.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2077.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
20888.sol
 function FUN1() internal view returns (bool){
 if (VAR1.VAR2 < VAR3){
 return (true);
 }
 }
 function FUN2() internal {
 VAR3 = VAR1.VAR2 + VAR4[VAR5];
 }

1
---------------------------------
21049.sol
 function FUN1() constant internal returns (uint) {
 }

1
---------------------------------
2115.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
2119.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2123.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
21231.sol
 modifier onlyAdmin() {
 assert(VAR1[msg.sender] == true || msg.sender == VAR2);
 VAR3;
 }
 function FUN1() public {
 VAR4 = VAR5.VAR6;
 }
 function FUN2(uint256 VAR7, string VAR8, uint256 VAR9) onlyAdmin public {
 }
 function FUN3 (uint256 VAR10, uint256 VAR11) onlyAdmin public {
 VAR4 = VAR5.VAR6;
 }
 function FUN4() public constant returns (uint256) {
 }
 function FUN5(address VAR12) internal {
 if (VAR13[VAR12] != 0) {
 VAR14[VAR13[VAR12]] += msg.value / 100;
 uint256 VAR15 = FUN4();
 if (VAR16[VAR15] == 0) VAR16[VAR15] = VAR17;
 uint256 VAR7 = msg.value * VAR18 / VAR16[VAR15] ;
 VAR12.transfer((VAR7 - VAR19) * VAR16[VAR15] / VAR18);
 if (VAR20[VAR12][VAR15].VAR7 == 0) {
 VAR20[VAR12][VAR15] = FUN6(VAR7, false);
 VAR20[VAR12][VAR15].VAR7 += VAR7;
 if (VAR5.VAR6 < 1522357200 && VAR21[VAR12][VAR15] == 0) {
 VAR21[VAR12][VAR15] = 1;
 }
 VAR22[VAR12] = FUN7(VAR22[VAR12], VAR7);
 emit Transfer(0, VAR12, VAR7);
 }

1
---------------------------------
2129.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2171.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2199.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2205.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2211.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
22160.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 function FUN5(address VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22) public VAR23 {
 VAR24.VAR25 = VAR7.VAR8;
 VAR24.VAR26 = FUN6(VAR7.VAR8,VAR22);
 VAR24.VAR27 = FUN6(VAR7.VAR8,VAR20);
 }
 function FUN7(address VAR18) public {
 VestingSchedule storage VAR24 = VAR28[VAR18];
 uint256 VAR29 = FUN6(VAR24.VAR30, VAR24.VAR31);
 require(FUN8(VAR29, VAR24.VAR32) > 0);
 uint256 VAR33 = 0;
 if (VAR7.VAR8 >= VAR24.VAR27 && !VAR24.VAR34) {
 VAR33 = FUN6(VAR33,VAR24.VAR30);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR34 = true;
 }
 if (VAR7.VAR8 >= VAR24.VAR26 && !VAR24.VAR35) {
 VAR33 = FUN6(VAR33,VAR24.VAR31);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR35 = true;
 }
 require(VAR33 > 0);
 VAR36.transfer(VAR18, VAR33);
 VAR37 = FUN8(VAR37, VAR33);
 FUN9(VAR18, VAR33);
 }

1
---------------------------------
22161.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 function FUN5(address VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22) public VAR23 {
 VAR24.VAR25 = VAR7.VAR8;
 VAR24.VAR26 = FUN6(VAR7.VAR8,VAR22);
 VAR24.VAR27 = FUN6(VAR7.VAR8,VAR20);
 }
 function FUN7(address VAR18) public {
 VestingSchedule storage VAR24 = VAR28[VAR18];
 uint256 VAR29 = FUN6(VAR24.VAR30, VAR24.VAR31);
 require(FUN8(VAR29, VAR24.VAR32) > 0);
 uint256 VAR33 = 0;
 if (VAR7.VAR8 >= VAR24.VAR27 && !VAR24.VAR34) {
 VAR33 = FUN6(VAR33,VAR24.VAR30);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR34 = true;
 }
 if (VAR7.VAR8 >= VAR24.VAR26 && !VAR24.VAR35) {
 VAR33 = FUN6(VAR33,VAR24.VAR31);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR35 = true;
 }
 require(VAR33 > 0);
 VAR36.transfer(VAR18, VAR33);
 VAR37 = FUN8(VAR37, VAR33);
 FUN9(VAR18, VAR33);
 }

1
---------------------------------
22162.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 function FUN5(address VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22) public VAR23 {
 VAR24.VAR25 = VAR7.VAR8;
 VAR24.VAR26 = FUN6(VAR7.VAR8,VAR22);
 VAR24.VAR27 = FUN6(VAR7.VAR8,VAR20);
 }
 function FUN7(address VAR18) public {
 VestingSchedule storage VAR24 = VAR28[VAR18];
 uint256 VAR29 = FUN6(VAR24.VAR30, VAR24.VAR31);
 require(FUN8(VAR29, VAR24.VAR32) > 0);
 uint256 VAR33 = 0;
 if (VAR7.VAR8 >= VAR24.VAR27 && !VAR24.VAR34) {
 VAR33 = FUN6(VAR33,VAR24.VAR30);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR34 = true;
 }
 if (VAR7.VAR8 >= VAR24.VAR26 && !VAR24.VAR35) {
 VAR33 = FUN6(VAR33,VAR24.VAR31);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR35 = true;
 }
 require(VAR33 > 0);
 VAR36.transfer(VAR18, VAR33);
 VAR37 = FUN8(VAR37, VAR33);
 FUN9(VAR18, VAR33);
 }

1
---------------------------------
2222.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2225.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
22273.sol
 modifier FUN1() {
 require(msg.sender == VAR1);
 VAR2;
 }
 modifier FUN2() {
 require(VAR3 == VAR4.VAR5);
 VAR2;
 }
 function FUN3(uint VAR6) public onlyOwner {
 VAR7 = VAR8.VAR9;
 }
 function FUN4(uint VAR6, uint VAR10, uint VAR11, uint VAR12, uint VAR13) public onlyOwner VAR14 {
 if (VAR6 > VAR8.VAR9) {
 VAR15 = VAR6;
 }
 }
 function FUN5() public {
 if (VAR3 != VAR4.VAR16 && VAR3 != VAR4.VAR5) {
 if (VAR17 >= VAR18) {
 VAR3 = VAR4.VAR19;
 VAR15 = VAR8.VAR9;
 FUN6(VAR17);
 else if (VAR8.VAR9 >= VAR15) {
 if (VAR17 < VAR20) {
 VAR3 = VAR4.VAR21;
 FUN7();
 }
 else {
 VAR3 = VAR4.VAR19;
 FUN6(VAR17);
 }
 }
 }
 function FUN8() public onlyWhitelisted payable {
 }

1
---------------------------------
2252.sol
 function FUN1(uint256 VAR1) external {
 }
 function FUN2(uint256 VAR2, uint256 VAR3) external onlyAdmin {
 }
 function FUN3(address VAR4, uint256 VAR5) external {
 }
 function FUN4() public onlyAdmin {
 uint256 VAR6 = VAR7.FUN5(VAR8 , VAR9.VAR10);
 VAR11 = FUN6(uint256(VAR9.FUN7(VAR9.VAR12-1)), VAR6, VAR8);
 }

1
---------------------------------
22714.sol
 function FUN1(uint256 VAR1) public {
 require(VAR1 < VAR2);
 var VAR3 = VAR4[VAR1];
 uint256 VAR5 = FUN2(VAR3.VAR6, VAR3.VAR7);
 if (VAR8.VAR7 > VAR5){
 FUN3(VAR1);
 return;
 }
 else{
 revert();
 }
 }
 function FUN4(uint256 VAR1, string VAR9) public payable{
 require(VAR1 < VAR2);
 var VAR3 = VAR4[VAR1];
 if (VAR3.VAR10 != address(0) && VAR8.VAR7 > (FUN2(VAR3.VAR7, VAR3.VAR6))){
 FUN3(VAR1);
 if (msg.value > 0){
 msg.sender.transfer(msg.value);
 }
 return;
 }
 require(msg.value >= VAR3.VAR11);
 require(msg.sender != VAR10);
 require(msg.sender != VAR3.VAR10);
 uint256 VAR12 = FUN5(VAR3.VAR11, VAR13) / 10000;
 uint256 VAR14 = FUN5(VAR3.VAR11, VAR3.VAR15) / 10000;
 if (VAR3.VAR10 == address(0)){
 VAR16 = (FUN5(VAR3.VAR11, VAR3.VAR17)) / 10000;
 VAR3.VAR10.transfer(VAR16);
 VAR3.VAR18.transfer(VAR14);
 if (msg.value > VAR3.VAR11){
 msg.sender.transfer(FUN6(msg.value, VAR3.VAR11));
 uint256 VAR19 = FUN6(FUN6(FUN6(VAR3.VAR11, VAR12), VAR14), VAR16);
 VAR3.VAR20 = FUN2(VAR3.VAR20, VAR19);
 VAR3.VAR7 = VAR8.VAR7;
 VAR3.VAR10 = msg.sender;
 VAR3.VAR9 = VAR9;
 VAR3.VAR11 = (VAR3.VAR11 * (FUN2(10000, VAR3.VAR21)))/10000;
 emit FUN7(VAR1);
 }

1
---------------------------------
2321.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2329.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
23665.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
2374.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2377.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2379.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3((VAR3.VAR4).FUN4(VAR3.VAR5).FUN4((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4(VAR3.VAR8).FUN4((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4(VAR3.VAR9))));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2383.sol
 function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1
---------------------------------
2385.sol
 function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1
---------------------------------
2387.sol
 modifier VAR1 {
 require(VAR2);
 VAR3;
 }
 modifier VAR4 {
 require(VAR5);
 VAR3;
 }
 function FUN1(address VAR6) public liquid canUseDirectDebit returns (bool) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }
 function FUN1(address[] VAR15, bool VAR16) public liquid canUseDirectDebit returns (bool VAR17) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }

1
---------------------------------
2388.sol
 modifier VAR1 {
 require(VAR2);
 VAR3;
 }
 modifier VAR4 {
 require(VAR5);
 VAR3;
 }
 function FUN1(address VAR6) public liquid canUseDirectDebit returns (bool) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }
 function FUN1(address[] VAR15, bool VAR16) public liquid canUseDirectDebit returns (bool VAR17) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }

1
---------------------------------
2389.sol
 modifier VAR1 {
 require(VAR2);
 VAR3;
 }
 modifier VAR4 {
 require(VAR5);
 VAR3;
 }
 function FUN1(address VAR6) public liquid canUseDirectDebit returns (bool) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }
 function FUN1(address[] VAR15, bool VAR16) public liquid canUseDirectDebit returns (bool VAR17) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }

1
---------------------------------
2391.sol
 function FUN1() private view returns (uint256) {
 }

1
---------------------------------
2397.sol
 function FUN1(address VAR1) internal returns (bool) {
 if (FUN2(VAR1)) {
 if (VAR2.VAR3>VAR4) {
 FUN3(VAR1);
 return true;
 }
 }
 function FUN4(address VAR1) public returns (uint256) {
 int256 VAR5 = (FUN5(VAR2.VAR3)-FUN5(VAR6[VAR1]))/(FUN5(VAR7));
 if (VAR5>VAR8) {
 VAR5=VAR8;
 if (VAR5>0) {
 int256 VAR9 = ((FUN5(VAR10[VAR1])*VAR5))/VAR8;
 }
 function FUN6(address VAR11, uint256 VAR12) internal returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN7(address VAR11) view public returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN8() public onlyOwner {
 VAR15 = VAR2.VAR3;
 VAR4 = VAR15 + VAR16*VAR7;
 VAR6[VAR17]=VAR15;
 VAR6[VAR18]=VAR15;
 VAR6[VAR19]=VAR15;
 }
 function FUN9() public {
 VAR20 = VAR2.VAR3;
 VAR21 = VAR2.VAR3 + VAR22[VAR23]*VAR24;
 }
 function FUN10() public {
 require (VAR25 == 0);
 VAR25 = VAR21.FUN11(VAR2.VAR3);
 }
 function FUN12() public {
 VAR21 = VAR2.VAR3.FUN13(VAR25);
 }
 function FUN14(address VAR26) public payable {
 }
 function FUN15(address VAR27) public {
 uint256 VAR28 = VAR2.VAR3;
 VAR29[0] = VAR28;
 VAR29[1] = VAR28;
 uint256 VAR30=VAR28 - VAR29[0];
 uint256 VAR31=VAR28 - VAR29[1];
 }

1
---------------------------------
2399.sol
 function FUN1(address VAR1) internal returns (bool) {
 if (FUN2(VAR1)) {
 if (VAR2.VAR3>VAR4) {
 FUN3(VAR1);
 return true;
 }
 }
 function FUN4(address VAR1) public returns (uint256) {
 int256 VAR5 = (FUN5(VAR2.VAR3)-FUN5(VAR6[VAR1]))/(FUN5(VAR7));
 if (VAR5>VAR8) {
 VAR5=VAR8;
 if (VAR5>0) {
 int256 VAR9 = ((FUN5(VAR10[VAR1])*VAR5))/VAR8;
 }
 function FUN6(address VAR11, uint256 VAR12) internal returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN7(address VAR11) view public returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN8() public onlyOwner {
 VAR15 = VAR2.VAR3;
 VAR4 = VAR15 + VAR16*VAR7;
 VAR6[VAR17]=VAR15;
 VAR6[VAR18]=VAR15;
 VAR6[VAR19]=VAR15;
 }

1
---------------------------------
2400.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2405.sol
 function FUN1() private view returns (uint) {
 }

1
---------------------------------
2411.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
24200.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
2437.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
24745.sol
 function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1
---------------------------------
2506.sol
 function FUN1() private view returns (uint) {
 }

1
---------------------------------
25248.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
25249.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
2528.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2530.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2531.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2541.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2553.sol
 function FUN1() private view returns (uint) {
 }

1
---------------------------------
2563.sol
 function FUN1(address VAR1) public {
 VAR2 = VAR3.VAR4;
 VAR5 = VAR3.VAR4 + 60;
 VAR6 = VAR3.VAR4 + 120;
 }
 function FUN2() onlyPurchaseAdmin public returns(bool){
 }

1
---------------------------------
2575.sol
 function FUN1() internal returns(uint8){
 uint8 VAR1 = uint8(uint256(FUN2(VAR2.VAR3))%VAR4);
 return uint8(uint256(FUN2(VAR5[VAR1]))%VAR4);
 }

1
---------------------------------
2598.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2599.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2622.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
26498.sol
 function FUN1( ) public {
 VAR1 = VAR2.VAR3;
 }
 function FUN2() internal constant returns (uint) {
 }

1
---------------------------------
2655.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2684.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2688.sol
 function FUN1(uint256 VAR1) public {
 require(VAR2.VAR3 > VAR4.VAR5);
 VAR6.VAR5 = VAR2.VAR3.FUN2(VAR7);
 }
 function FUN3(uint256 VAR6, uint256 VAR8, uint256 VAR9) internal {
 Round memory VAR10 = VAR11[VAR12];
 if (VAR13[VAR8][VAR6].VAR14 == 0) {
 FUN4(VAR8);
 if (VAR2.VAR3 > VAR10.VAR5) {
 FUN1(VAR15[VAR8].VAR16);
 FUN4(VAR8);
 }
 Round storage VAR17 = VAR11[VAR12];
 VAR15[VAR8].VAR18 = VAR9.FUN2(VAR15[VAR8].VAR18);
 VAR17.VAR19 = VAR15[VAR8].VAR20;
 VAR17.VAR5 = VAR17.VAR5.FUN2(VAR21);
 if (VAR17.VAR5.FUN5(VAR2.VAR3) > VAR7) {
 VAR17.VAR5 = VAR2.VAR3.FUN2(VAR7);
 }
 VAR17.VAR22 = (VAR9.FUN6(VAR23) / 1000).FUN2(VAR17.VAR22);
 if (VAR17.VAR14 == 0) {
 VAR15[0].VAR18 = VAR24.FUN2(VAR15[0].VAR18);
 VAR17.VAR25 = VAR17.VAR25.FUN2((VAR9.FUN6(VAR26) / 1000) / VAR17.VAR14);
 uint256 VAR27 = (VAR9.FUN6(VAR26) / 1000).FUN5( VAR9.FUN6(VAR26) / 1000 / VAR17.VAR14 * VAR17.VAR14 );
 VAR15[0].VAR18 = VAR24.FUN2(VAR27).FUN2(VAR15[0].VAR18);
 VAR13[VAR8][VAR12].VAR14 = VAR28.FUN2(VAR13[VAR8][VAR12].VAR14);
 VAR17.VAR14 = VAR28.FUN2(VAR17.VAR14);
 VAR17.VAR29 = VAR9.FUN2(VAR17.VAR29);
 VAR13[VAR8][VAR12].VAR25 = VAR17.VAR25.FUN6(VAR28).FUN2(VAR13[VAR8][VAR12].VAR25);
 uint256 VAR30 = VAR15[VAR8].VAR16;
 uint256 VAR31 = VAR15[VAR30].VAR16;
 VAR15[VAR30].VAR32 = (VAR9.FUN6(VAR33) / 1000).FUN2(VAR15[VAR30].VAR32);
 VAR15[VAR31].VAR32 = (VAR9.FUN6(VAR34) / 1000).FUN2(VAR15[VAR31].VAR32);
 }
 function FUN7() public view returns (uint256) {
 if (VAR11[VAR12].VAR5 <= VAR2.VAR3) {
 return 0;
 }
 else {
 return VAR11[VAR12].VAR5 - VAR2.VAR3;
 }
 }

1
---------------------------------
2699.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
27078.sol
 function FUN1() public FUN2(VAR1, VAR2, VAR3) {
 VAR4 = VAR5.VAR6;
 }
 function FUN3() public view returns (uint) {
 }
 function FUN4() public onlyOwner {
 uint256 VAR7 = (VAR5.VAR6 - VAR4) / VAR8;
 if (VAR7 > VAR9) {
 VAR7 = VAR9;
 uint256 VAR10 = ((VAR9 - VAR7) * VAR11) * 10 ** uint256(VAR12);
 }

1
---------------------------------
27083.sol
 function FUN1() public FUN2(VAR1, VAR2, VAR3) {
 VAR4 = VAR5.VAR6;
 }
 function FUN3() public view returns (uint) {
 }
 function FUN4() public onlyOwner {
 uint256 VAR7 = (VAR5.VAR6 - VAR4) / VAR8;
 if (VAR7 > VAR9) {
 VAR7 = VAR9;
 uint256 VAR10 = ((VAR9 - VAR7) * VAR11) * 10 ** uint256(VAR12);
 }

1
---------------------------------
27225.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
2723.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2740.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2745.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2746.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2750.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2754.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2757.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2761.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2763.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2764.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2772.sol
 function FUN1(uint256 VAR1, address sender) public view returns(bool) {
 uint256 VAR2 = uint256(FUN2(VAR3.FUN3( (VAR4.VAR5).FUN4 (VAR4.VAR6).FUN4 ((uint256(FUN2(VAR3.FUN3(VAR4.VAR7)))) / (VAR8)).FUN4 (VAR4.VAR9).FUN4 ((uint256(FUN2(VAR3.FUN3(sender)))) / (VAR8)).FUN4 (VAR4.VAR10) )));
 if((VAR2 - ((VAR2 / 1000) * 1000)) < VAR1) return(true);
 }

1
---------------------------------
2777.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3((VAR3.VAR4).FUN4(VAR3.VAR5).FUN4((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4(VAR3.VAR8).FUN4((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4(VAR3.VAR9))));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2783.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2792.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2794.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2797.sol
 modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1
---------------------------------
28090.sol
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
28091.sol
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
28093.sol
 function FUN1() internal constant returns (uint256) {
 }
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
28218.sol
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
2823.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2833.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2839.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2855.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2861.sol
 function FUN1( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5 ) public onlyOwner{
 }
 function FUN2(address VAR1) public view returns (uint256) {
 tokenToVest storage value = VAR6[VAR1];
 uint256 VAR7 = value.VAR8;
 if (VAR9.VAR10 < value.VAR11) {
 return 0;
 }
 else if (VAR9.VAR10 >= value.VAR12.FUN3(value.VAR13)) {
 return VAR7;
 }
 else {
 return VAR7.FUN4(VAR9.VAR10.FUN5(value.VAR12)).FUN6(value.VAR13);
 }
 }

1
---------------------------------
2876.sol
 function FUN1() private view returns (bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return (true);
 }

1
---------------------------------
28865.sol
 function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1
---------------------------------
29090.sol
 function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1
---------------------------------
29265.sol
 function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1
---------------------------------
29282.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 modifier FUN5(address VAR18){
 require(VAR19[VAR18].VAR20);
 VAR21;
 }
 modifier FUN6(address VAR22) {
 require(!VAR19[VAR22].VAR20);
 VAR21;
 }
 function FUN7(address VAR18, uint256 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, uint256 VAR27, bool VAR28) public FUN6(VAR18) VAR29 {
 if (VAR23 == 0) VAR23 = VAR7.VAR8;
 VAR30.VAR31 = VAR23;
 }
 function FUN8(address VAR18) public FUN5(VAR18) {
 uint256 VAR32 = VAR7.VAR8 - VAR30.VAR31;
 uint256 VAR33 = VAR32 / VAR30.VAR34;
 }

1
---------------------------------
2941.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2947.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2949.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2954.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2989.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2991.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
2995.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3050.sol
 function FUN1() private returns(uint256,uint256,address) {
 uint256 VAR1 = 0;
 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4) + (VAR3.VAR5) + ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)) + (VAR3.VAR8) + ((uint256(FUN2(VAR2.FUN3(VAR9)))) / (VAR7)) + (VAR3.VAR10) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) >= VAR11) {
 }

1
---------------------------------
3051.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3057.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3071.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
30763.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
30765.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3090.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3096.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3097.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3103.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3106.sol
 function FUN1() private returns(uint256,uint256,address) {
 uint256 VAR1 = 0;
 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4) + (VAR3.VAR5) + ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)) + (VAR3.VAR8) + ((uint256(FUN2(VAR2.FUN3(VAR9)))) / (VAR7)) + (VAR3.VAR10) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) >= VAR11) {
 }

1
---------------------------------
3108.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3109.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
31099.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31103.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3113.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3125.sol
 function FUN1() private view returns (uint8) {
 }

1
---------------------------------
3126.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3127.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3137.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
31450.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31480.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31506.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31507.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31508.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31509.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31510.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31511.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31512.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31514.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31515.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31517.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31518.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31519.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31520.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
31521.sol
 function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1
---------------------------------
3158.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3168.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3174.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
31786.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31787.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31792.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31821.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31823.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31893.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3190.sol
 function FUN1(bytes32 VAR1) internal view returns (uint16) {
 }

1
---------------------------------
31948.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31957.sol
 function FUN1() constant returns (uint) {
 }

1
---------------------------------
31958.sol
 function FUN1() constant returns (uint) {
 }

1
---------------------------------
31964.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31967.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31982.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31985.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
31987.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3199.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
31993.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3204.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3207.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3217.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3222.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3228.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
32296.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3240.sol
 function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1
---------------------------------
3248.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3254.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3255.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3256.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3266.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3269.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
32723.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
32736.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3281.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3286.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3302.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3305.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3314.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3315.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3316.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3318.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3323.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3330.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
33348.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
33351.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
33353.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
33395.sol
 function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public constant returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private constant returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1
---------------------------------
3347.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3350.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3363.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3364.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3371.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
33765.sol
 function FUN1() internal constant returns (uint256) {
 }
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
33768.sol
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
33770.sol
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
33782.sol
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
33784.sol
 function FUN1() internal constant returns (uint256) {
 }

1
---------------------------------
3383.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
3394.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
33962.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
33965.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
33971.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
34088.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
34143.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
34144.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
34148.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
34393.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
3455.sol
 function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1
---------------------------------
34622.sol
 function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1
---------------------------------
