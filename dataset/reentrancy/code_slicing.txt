0x00000000000da14c27c155bb7c1ac9bd7519eb3b.sol
function() external payable {
FUN1();
msg.sender.transfer(msg.value);
}
}

0
---------------------------------
0x00000000000dbef74a0e053433503acae8dc80f5.sol
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6) {
FUN2( VAR7.VAR8, VAR9.FUN3(VAR1, VAR2), VAR3, VAR4, VAR5 );
require(VAR1 > 0, FUN4(4));
require(VAR2 != address(0), FUN4(1));
VAR6 = FUN5(VAR2, VAR1);
}
function FUN5( address payable VAR2, uint256 VAR1 ) internal returns (bool VAR10) {
(VAR10, ) = VAR2.call.FUN6(VAR11).value(VAR1)("");
if (!VAR10) {
emit FUN7(VAR2, FUN4(18));
}
else {
emit FUN8(VAR1, VAR2);
}
}

0
---------------------------------
0x00000000001876eb1444c986fd502e618c587430.sol
function () external payable {
(bool VAR1, bytes memory VAR2) = VAR3.FUN1("");
if (!VAR1) {
VAR4 {
FUN2(0, 0, VAR5) revert(0, VAR5) }
}
address VAR6 = VAR7.FUN3(VAR2, (address));
VAR4 {
FUN4(0, 0, VAR8) let VAR9 := FUN5(VAR10, VAR6, 0, VAR8, 0, 0) FUN2(0, 0, VAR5) switch result case 0 {
revert(0, VAR5) }
default {
return(0, VAR5) }
}
}
}

0
---------------------------------
0x00000000001f2bec34d4a98c839cf711afc842c6.sol
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6) {
FUN2( VAR7.VAR8, VAR9.FUN3(VAR1, VAR2), VAR3, VAR4, VAR5 );
require(VAR1 > 0, "");
require(VAR2 != address(0), "");
VAR6 = FUN4(VAR2, VAR1);
}
function FUN4( address payable VAR2, uint256 VAR1 ) internal returns (bool VAR10) {
(VAR10, ) = VAR2.call.FUN5(VAR11).value(VAR1)("");
if (!VAR10) {
emit FUN6(VAR2, "");
}
else {
emit FUN7(VAR1, VAR2);
}
}

0
---------------------------------
0x00000000002b13cccec913420a21e4d11b2dcd3c.sol
function FUN1( uint96 VAR1, bytes calldata VAR2 ) external payable returns (address VAR3) {
bytes32 VAR4 = FUN2(VAR1);
VAR5 = VAR2;
address VAR6 = FUN3(VAR4);
address VAR7;
bytes memory VAR8 = VAR9;
VAR10 {
let VAR11 := FUN4(0x20, VAR8) let VAR12 := FUN5(VAR8) VAR7 := FUN6( VAR13, VAR11, VAR12, VAR4 ) }
require(VAR7 != address(0), "");
VAR3 = FUN7(VAR7);
FUN8(VAR3, FUN9(VAR6));
delete VAR5;
emit FUN10(VAR3, VAR4);
}

0
---------------------------------
0x0000000000377d181a0ebd08590c6b399b272000.sol
function() payable {
if (msg.value > 0) FUN1(msg.sender, msg.value);
}

0
---------------------------------
0x00000000008943c65caf789fffcf953be156f6f8.sol
function () external payable {
(bool VAR1, bytes memory VAR2) = VAR3.FUN1("");
if (!VAR1) {
VAR4 {
FUN2(0, 0, VAR5) revert(0, VAR5) }
}
address VAR6 = VAR7.FUN3(VAR2, (address));
VAR4 {
FUN4(0, 0, VAR8) let VAR9 := FUN5(VAR10, VAR6, 0, VAR8, 0, 0) FUN2(0, 0, VAR5) switch result case 0 {
revert(0, VAR5) }
default {
return(0, VAR5) }
}
}
}

0
---------------------------------
0x000000000092c287eb63e8c2c30b4a74787054f8.sol
function() external payable {
FUN1();
}

0
---------------------------------
0x0000000000ab32e9e7bd6bd3c37a7e99fb8c2d43.sol
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6) {
FUN2( VAR7.VAR8, VAR9.FUN3(VAR1, VAR2), VAR3, VAR4, VAR5 );
require(VAR1 > 0, "");
require(VAR2 != address(0), "");
VAR6 = FUN4(VAR2, VAR1);
}
function FUN4( address payable VAR2, uint256 VAR1 ) internal returns (bool VAR10) {
(VAR10, ) = VAR2.call.FUN5(VAR11).value(VAR1)("");
if (!VAR10) {
emit FUN6(VAR2, "");
}
else {
emit FUN7(VAR1, VAR2);
}
}

0
---------------------------------
0x0000000000c5fd1aef1a9421626cf804086185e9.sol
function FUN1( address VAR1, uint256 VAR2, uint256 value ) external payable;

0
---------------------------------
0x00000000037790973600b70888431f463bce360d.sol
function FUN1( address VAR1, uint256 VAR2, uint256 value ) external payable;

0
---------------------------------
0x0000000006adbd7c01bc0738cdbfc3932600ad63.sol
function FUN1() external payable;

0
---------------------------------
0x000000001a1f402e8e32f1faac83692266167b26.sol
function transfer(address payable[] memory VAR1, uint256[] memory VAR2) payable public returns(bool) {
uint256 VAR3 = address(this).VAR4;
for (uint VAR5 = 0; VAR5 < VAR1.VAR6; VAR5++) {
FUN1(VAR1[VAR5], VAR2[VAR5]);
emit FUN2(msg.sender, msg.value, VAR1[VAR5], VAR2[VAR5]);
}
require(VAR3 - msg.value == address(this).VAR4);
return true;
}
function FUN1(address payable VAR7, uint256 VAR8) private {
require(VAR7 != address(0));
VAR7.transfer(VAR8);
}
function FUN3() public onlyOwner() {
FUN4(VAR9);
}
FUN5() external payable {
revert();
}
FUN6 () external payable {
revert();
}
}
function FUN3() public onlyOwner() {
FUN4(VAR9);
}
FUN5() external payable {
revert();
}
FUN6 () external payable {
revert();
}
}

0
---------------------------------
0x00000000219ab540356cbb839cbe05303d7705fa.sol
function FUN1( bytes calldata VAR1, bytes calldata VAR2, bytes calldata VAR3, bytes32 VAR4 ) external payable;
function FUN1( bytes calldata VAR1, bytes calldata VAR2, bytes calldata VAR3, bytes32 VAR4 ) override external payable {
require(VAR1.VAR5 == 48, "");
require(VAR2.VAR5 == 32, "");
require(VAR3.VAR5 == 96, "");
require(msg.value >= 1 VAR6, "");
require(msg.value % 1 VAR7 == 0, "");
uint VAR8 = msg.value / 1 VAR7;
require(VAR8 <= FUN2(VAR9).VAR10, "");
bytes memory VAR11 = FUN3(FUN4(VAR8));
emit FUN5( VAR1, VAR2, VAR11, VAR3, FUN3(FUN4(VAR12)) );
bytes32 VAR13 = FUN6(VAR14.FUN7(VAR1, FUN8(0)));
bytes32 VAR15 = FUN6(VAR14.FUN7( FUN6(VAR14.FUN7(VAR3[:64])), FUN6(VAR14.FUN7(VAR3[64:], bytes32(0))) ));
bytes32 VAR16 = FUN6(VAR14.FUN7( FUN6(VAR14.FUN7(VAR13, VAR2)), FUN6(VAR14.FUN7(VAR11, FUN9(0), VAR15)) ));
require(VAR16 == VAR4, "");
require(VAR12 < VAR17, "");
VAR12 += 1;
uint VAR18 = VAR12;
for (uint VAR19 = 0; VAR19 < VAR20; VAR19++) {
if ((VAR18 & 1) == 1) {
VAR21[VAR19] = VAR16;
return;
}
VAR16 = FUN6(VAR14.FUN7(VAR21[VAR19], VAR16));
VAR18 /= 2;
}
assert(false);
}

0
---------------------------------
0x000000002bb43c83ece652d161ad0fa862129a2c.sol
function() external payable {
revert();
}
}
interface VAR1 {
function FUN1() external payable {
require(msg.value == VAR2);
Account storage VAR3 = VAR4[msg.sender];
require(VAR3.VAR5 & VAR6 == 0);
VAR3.VAR7 = VAR8;
VAR3.VAR5 |= VAR6;
VAR9.FUN2(msg.sender, 40);
FUN3(msg.sender);
}
function FUN4(ProposalInterface VAR10, string VAR11) external payable {
require(msg.value == VAR12);
require(VAR4[msg.sender].VAR5 & VAR13 != 0);
Account storage VAR3 = VAR4[VAR10];
require(VAR3.VAR5 & VAR14 != 0);
VAR3.VAR5 &= ~VAR14;
VAR15.transfer(VAR12);
FUN5(VAR10, VAR11);
}

0
---------------------------------
0x00000000441378008ea67f4284a57932b1c000a5.sol
function() external payable {
address VAR1 = FUN1();
VAR2 {
let VAR3 := FUN2(0x40) FUN3(VAR3, 0, VAR4) let VAR5 := FUN4(VAR6, VAR1, VAR3, VAR4, 0, 0) let VAR7 := VAR8 FUN5(VAR3, 0, VAR7) switch result case 0 {
revert(VAR3, VAR7) }
default {
return(VAR3, VAR7) }
}
}
}
contract UpgradeabilityProxy is VAR9 {
event FUN6(address indexed VAR10);
bytes32 private constant VAR11 = FUN7("");

0
---------------------------------
0x0000000053d411becdb4a82d8603edc6d8b8b3bc.sol
function FUN1() external payable;

0
---------------------------------
0x0000000088ad0c701dd873c5915addc65f54fa05.sol
function FUN1(address payable VAR1) public onlyOwner {
VAR2 = VAR1;
}

0
---------------------------------
0x000000008eb3d0a15fb54e6c00464ab8f55b5f8c.sol
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);

0
---------------------------------
0x00000000bbcf7700a1b403c9eb666f350707b900.sol
function() external payable {
address VAR1 = FUN1();
VAR2 {
let VAR3 := FUN2(0x40) FUN3(VAR3, 0, VAR4) let VAR5 := FUN4(VAR6, VAR1, VAR3, VAR4, 0, 0) let VAR7 := VAR8 FUN5(VAR3, 0, VAR7) switch result case 0 {
revert(VAR3, VAR7) }
default {
return(VAR3, VAR7) }
}
}
}
contract UpgradeabilityProxy is VAR9 {
event FUN6(address indexed VAR10);
bytes32 private constant VAR11 = 0xdc8e328a3c0acffa7969856957539d0f8c2deaa0d39abaf20397a9fa3b45bf17;

0
---------------------------------
0x00000000c8bdb2c7db23eccf7500efc3c2ab7b99.sol
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);

0
---------------------------------
0x00000000e82eb0431756271f0d00cfb143685e7b.sol
function FUN1( bytes32 VAR1, bytes calldata VAR2, bytes calldata VAR3 ) external payable FUN2(VAR1) returns ( address VAR4 ) {
bytes memory VAR5 = VAR2;
bytes memory VAR6 = VAR3;
bytes memory VAR7 = VAR8;
address VAR9;
VAR4 = FUN3(VAR1);
address VAR10;
VAR11 {
let VAR12 := FUN4(0x20, VAR5) let VAR13 := FUN5(VAR5) VAR10 := FUN6( 0, VAR12, VAR13 ) }
require( VAR10 != address(0), "" );
VAR14[VAR4] = VAR10;
VAR11 {
let VAR12 := FUN4(0x20, VAR7) let VAR13 := FUN5(VAR7) VAR9 := FUN7( 0, VAR12, VAR13, VAR1 ) }
require( VAR9 == VAR4, "" );
if (VAR6.VAR15 > 0 || msg.value > 0) {
(bool VAR16,) = VAR9.call.value(msg.value)(VAR6);
require(VAR16, "");
}
emit FUN8(VAR9, VAR10);
}
function FUN9( bytes32 VAR1, address VAR10, bytes calldata VAR3 ) external payable FUN2(VAR1) returns ( address VAR4 ) {
bytes memory VAR6 = VAR3;
bytes memory VAR7 = VAR8;
address VAR9;
VAR4 = FUN3(VAR1);
VAR14[VAR4] = VAR10;
VAR11 {
let VAR12 := FUN4(0x20, VAR7) let VAR13 := FUN5(VAR7) VAR9 := FUN7( 0, VAR12, VAR13, VAR1 ) }
require( VAR9 == VAR4, "" );
if (VAR6.VAR15 > 0 || msg.value > 0) {
(bool VAR16,) = VAR4.call.value(msg.value)(VAR6);
require(VAR16, "");
}
emit FUN8(VAR9, VAR10);
}

0
---------------------------------
0x00000007b0390fc9ca72f534366f5c02d5af5334.sol
function () payable public {
emit FUN1(msg.sender, msg.value);
VAR1.transfer(msg.value.FUN2(3).FUN3(100));
VAR2 = address(this).VAR3;
}

0
---------------------------------
0x0000000a9e27410f13dd4818488bf1e706c9a2fe.sol
function () payable public {
emit FUN1(msg.sender, msg.value);
VAR1.transfer(msg.value.FUN2(3).FUN3(100));
VAR2 = address(this).VAR3;
}

0
---------------------------------
0x000000931cf36c464623bb0eefb6b0c205338d67.sol
function FUN1() public payable {
require(msg.value == 0);
}

0
---------------------------------
0x000000c96e715a5b8cd3beaea66bdb749225fa2f.sol
function FUN1() public payable {
require(msg.value == 0);
}

0
---------------------------------
0x00000100f2a2bd000715001920eb70d229700085.sol
function() external payable {
VAR1 {
let VAR2 := FUN1(0x40) FUN2(VAR2, VAR3, VAR4) let VAR5 := FUN3(VAR6, FUN4(0xecfd2ee7a4295d533a08882dec6729582fc6bda7812f32b75ae1ea4807d08982), VAR2, VAR4, VAR3, VAR3) FUN5(VAR2, 0, VAR3) switch result case 0 {
revert(VAR2, VAR3) }
default {
return(VAR2, VAR3) }
}
}
}

0
---------------------------------
0x0000010d23ccfee520c3fb5a5ba9679cb9d83cbe.sol
function () external payable {
require(msg.value > 0);
uint VAR1 = msg.value * FUN1(msg.sender) / 10000;
require(msg.value > VAR1);
FUN2(0x0, VAR2, VAR1);
uint VAR3 = msg.value - VAR1;
FUN2(0x0, msg.sender, VAR3);
emit FUN3(0x0, msg.sender, VAR3);
emit FUN4(0x0, msg.sender, VAR4[0x0][msg.sender]);
emit FUN5(msg.sender, VAR3, true);
}

0
---------------------------------
0x0000610024bae4de00eb00ee7ee8321e4cc900b9.sol
function() external payable {
VAR1 {
let VAR2 := FUN1(0x40) FUN2(VAR2, VAR3, VAR4) let VAR5 := FUN3(VAR6, FUN4(0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb), VAR2, VAR4, VAR3, VAR3) FUN5(VAR2, 0, VAR3) switch result case 0 {
revert(VAR2, VAR3) }
default {
return(VAR2, VAR3) }
}
}
}

0
---------------------------------
0x00006100f7090010005f1bd7ae6122c3c2cf0090.sol
function() external payable {
VAR1 {
let VAR2 := FUN1(0x40) FUN2(VAR2, VAR3, VAR4) let VAR5 := FUN3(VAR6, FUN4(0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb), VAR2, VAR4, VAR3, VAR3) FUN5(VAR2, 0, VAR3) switch result case 0 {
revert(VAR2, VAR3) }
default {
return(VAR2, VAR3) }
}
}
}

0
---------------------------------
0x0000852600ceb001e08e00bc008be620d60031f2.sol
function() external payable {
bytes32 VAR1 = VAR2;
VAR3 {
let VAR4 := FUN1(0x40) FUN2(VAR4, VAR5, VAR6) let VAR7 := FUN3(VAR8, FUN4(VAR1), VAR4, VAR6, VAR5, VAR5) FUN5(VAR4, 0, VAR5) switch result case 0 {
revert(VAR4, VAR5) }
default {
return(VAR4, VAR5) }
}
}
}

0
---------------------------------
0x00016fab0fa144ca8c1f7ec4cf72e70e52359005.sol
function () external payable {
revert();
}

0
---------------------------------
0x0001fb050fe7312791bf6475b96569d83f695c9f.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x00022837E66Fdd4bbFe63859d7dc12651738D329.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x000621424c60951cb69e9d75d64b79813846d498.sol
function FUN1() payable {
}
function FUN2() payable {
require(msg.value == 0);
}

0
---------------------------------
0x0006c68eD5DFE993376dd96dC871177FDc1Ccf32.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0008557B1D87a622ec73A2ae1969548CF6810f79.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x000983ba1a675327f0940b56c2d49cd9c042dfbf.sol
function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4) public payable;

0
---------------------------------
0x000c100050e98c91f9114fa5dd75ce6869bf4f53.sol
function FUN1(address VAR1) public onlyOwner {
require(VAR1 != msg.sender, "");
FUN2(VAR1);
}
}
pragma VAR2 ^0.5.6;
contract C10Token is VAR3, VAR4, VAR5, VAR6, VAR7 {
FUN3(address => uint256) public VAR8;
address[] public VAR9;
FUN3 (address => uint256) public VAR10;
address payable[] public VAR11;
uint256 public VAR12 = 50 VAR13;
uint256 public VAR14 = 50;
uint256 public VAR15 = 50;
uint256 public VAR16 = 1 VAR17;
uint256 public VAR18 = 50;
uint256 public VAR19 = 50;
Price public VAR20;
address public VAR21;
struct VAR22 {
uint256 VAR23;
uint256 VAR24;
}
event FUN4(uint256 VAR23, uint256 VAR24);
event FUN5(uint256 value);
event FUN6(uint256 value);
event FUN7(address indexed VAR25, uint256 value);
event FUN8(address indexed VAR25, uint256 VAR26, uint256 VAR27);
event FUN9(address indexed VAR25, uint256 VAR26);
event FUN10(address indexed VAR25, uint256 VAR26, uint256 VAR27);
event FUN11(address indexed VAR25, uint256 VAR26);
event FUN12(address indexed VAR25, uint256 VAR26);
event FUN13(address indexed VAR28, uint256 VAR29);

0
---------------------------------
0x000da8645769d407e20b699b60ef81923e04478a.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {

0
---------------------------------
0x000f400e6818158d541c3ebe45fe3aa0d47372ff.sol
function FUN1( address VAR1, bytes calldata VAR2) external payable {
(bool VAR3,) = VAR1.call.value(msg.value)(VAR2);
VAR4 {
let VAR5 := FUN2() let VAR6 := FUN3(0x40) FUN4(VAR6, 0, VAR5) if FUN5(VAR3, 0) {
revert(VAR6, VAR5) }
return(VAR6, VAR5) }
}
}

0
---------------------------------
0x00125893df6ca0792c99601c462764ba5d80268a.sol
function () payable public {
}

0
---------------------------------
0x0013d3b508a23feeeca45c4c62cc88966fb71aed.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}

0
---------------------------------
0x001936dbef5a3598dfc2a9ef0e6fb7c542ebefd4.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x00195777bed7025e78819156281192c85fb3cf9b.sol
function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);

0
---------------------------------
0x001ea8150f4965195e10e5b5568047e1555a6dcd.sol
function () payable{
FUN1();
}
function FUN1() payable{
require(msg.value > 0);
uint256 VAR1 = msg.value.FUN2(VAR2);
require(VAR3.FUN3(VAR1) <= VAR4);
VAR5[msg.sender] = VAR5[msg.sender].FUN3(VAR1);
VAR3 = VAR3.FUN3(VAR1);
VAR6.transfer(msg.value);
}

0
---------------------------------
0x001f147ba2df91e8634b48cd10ebb7fec54a72fc.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
struct VAR7 {
bytes32[] VAR8;
FUN3 (bytes32 => uint256) VAR9;
}

0
---------------------------------
0x001f52daa8a4f7b9b26da16baf449c0d270dbe63.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
0x00214120d3469a74ca586bc9557c0ff8fb09b157.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x00224d9084fd7cdb4a5ce7740cb1ca0dca6be7a6.sol
function() payable external;
function FUN1(address VAR1) payable external returns(uint256);
function FUN2(bool VAR2) external view returns(uint256);
}
contract VAR3 {
address public VAR4;
bool public VAR5;
constructor(address VAR6, address VAR7) public payable {
VAR4 = VAR6;
if (msg.value > 0) {
FUN3(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).VAR8.value(msg.value)(VAR7);
}
}
function() public payable {
VAR9 {
FUN4(0, 0, VAR10) let VAR11 := FUN5(VAR12, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR10, 0, 0) FUN6(0, 0, VAR13) switch result case 0 {
revert(0, VAR13) }
default {
return(0, VAR13) }
}
}
}

0
---------------------------------
0x0026e8a1FFdA2034B201F515CeF594a6d737d555.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x002842529757eab873cce9c251087e1b993f9200.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != address(0));
require(VAR2 >= VAR3 && VAR2 <= VAR4);
require(VAR5);
require(msg.value != 0);
uint256 VAR6 = msg.value;
uint256 VAR7 = VAR6.FUN2(VAR8);
require(VAR9.FUN3(VAR7) <= VAR10);
VAR11 = VAR11.FUN3(VAR6);
VAR9 = VAR9.FUN3(VAR7);
VAR12[VAR1] = VAR12[VAR1].FUN3(VAR6);
assert(VAR13.FUN4(VAR14, VAR1, VAR7));
FUN5(msg.sender, VAR1, VAR6, VAR7);
VAR15.transfer(msg.value);
}

0
---------------------------------
0x00285f9aad90013a782fb6c85584d97f120b54d8.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
0x0028b2ec9C4703F3C8F18e38AA02c047D7b8AE80.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x002c97933d0976dbcf51c0e8f8a3e64d8fd9d296.sol
function FUN1() public payable {
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(40000000000000000 VAR1);
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(160000000000000000 VAR1);
}
}

0
---------------------------------
0x003288d46471359320c9cc47696a55e6c1698bb8.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x003312e3ebbe6b0f25f1c03c2695d83075d9a9b8.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x003328baa789dfbe86b89555cb097970a524848f.sol
function FUN1() external payable;

0
---------------------------------
0x0033fb5561719b8b697b604466d6d39308c58191.sol
function FUN1() FUN2(VAR1, '', '') payable public {
}

0
---------------------------------
0x00346fddca107aec034a367b7324f0d6419bf4b9.sol
function () payable public {
require(!VAR1);
uint VAR2 = msg.value;
VAR3[msg.sender] += VAR2;
VAR4 += VAR2;
VAR5.transfer(msg.sender, VAR2 / VAR6);
FUN1(msg.sender, VAR2, true);
}
modifier FUN2() {
if (VAR7 >= VAR8) VAR9;
}

0
---------------------------------
0x0036192587fd788b75829fbf79be7f06e4f23b21.sol
function () external payable {
FUN1();
}

0
---------------------------------
0x0039019392b1ea93cd1277f75986fdf2407fe254.sol
function FUN1() payable {
FUN2();
if (VAR1 == 0) throw;
uint VAR2 = msg.value / VAR1;
if (VAR3[this] < VAR2) throw;
VAR3[msg.sender] += VAR2;
VAR3[this] -= VAR2;
Transfer(this, msg.sender, VAR2);
}

0
---------------------------------
0x00391d08b3e68e476a774ada379258264eb74485.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
VAR5 = VAR5.FUN4(VAR2);
VAR6.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}
function FUN1(address VAR7) public payable {
require(VAR7 != 0x0);
require(FUN2());
require(VAR8[VAR7].VAR9 == false);
FUN8();
uint256 VAR2 = msg.value;
uint256 VAR10 = FUN9(VAR7);
uint256 VAR11;
if (VAR2 > VAR10) {
VAR11 = VAR2.FUN10(VAR10);
VAR2 = VAR10;
}
require(VAR2 > 0);
uint256 VAR3 = FUN11(VAR7, VAR2, VAR4);
assert(VAR3 > 0);
VAR5 = VAR5.FUN4(VAR2);
require(VAR6.FUN5(VAR7, VAR3));
emit FUN6(msg.sender, VAR7, VAR2, VAR3);
VAR8[VAR7].VAR12 = VAR8[VAR7].VAR12.FUN4(VAR2);
VAR8[VAR7].VAR13 = VAR8[VAR7].VAR13.FUN4(VAR3);
VAR14.transfer(VAR2);
if (VAR11 != 0) VAR7.transfer(VAR11);
}

0
---------------------------------
0x003ad9c18bc279f40632e7e5de2fd213931215d0.sol
function FUN1(bytes32 VAR1, VAR2[] VAR3, VAR2[] VAR4, address VAR5 ) FUN2(VAR3, VAR4) FUN3(VAR3, VAR4) FUN4() public payable {
require(VAR1.VAR6 > 4);
uint256 VAR7 = msg.value;
uint256 VAR8 = 0;
if(VAR5 != msg.sender && VAR5 != address(0)) {
VAR8 = VAR9.FUN5(msg.value);
if(VAR5.FUN6(VAR8)) {
emit FUN7(VAR5, VAR5, VAR8, VAR10);
VAR7 = VAR7.FUN8(VAR8);
}
}
VAR11 = VAR11.FUN9(VAR12.FUN5(VAR7));
if(!VAR13.FUN6(VAR14.FUN5(VAR7))){
VAR15 = VAR15.FUN9(VAR14.FUN5(VAR7));
}
FUN10(VAR1, VAR3, VAR4);
FUN11(VAR12.FUN5(VAR7));
if(VAR3.VAR6 >= VAR16 && VAR17 > 0) {
uint256 VAR18 = VAR3.VAR6 / VAR19;
if(VAR18 > VAR17) VAR18 = VAR17;
VAR20.transfer(msg.sender, VAR18);
emit FUN12(msg.sender, msg.sender, VAR18, VAR10);
VAR21 = VAR21 + VAR18;
VAR17 = VAR17 - VAR18;
}
}
function FUN13(uint256 VAR22, address VAR5) FUN14(VAR22) FUN4() public payable {
uint256 VAR7 = msg.value;
uint256 VAR8 = 0;
if(VAR5 != msg.sender && VAR5 != address(0)) {
VAR8 = VAR9.FUN5(msg.value);
if(VAR5.FUN6(VAR8)) {
emit FUN7(VAR5, VAR5, VAR8, VAR10);
VAR7 = VAR7.FUN8(VAR8);
}
}
VAR11 = VAR11.FUN9(VAR23.FUN5(VAR7));
if(!VAR13.FUN6(VAR24.FUN5(VAR7))){
VAR15 = VAR15.FUN9(VAR24.FUN5(VAR7));
}
address VAR25 = FUN15(VAR22);
if(!VAR25.FUN6(VAR26.FUN5(VAR7))) {
VAR27[VAR25] = VAR27[VAR25].FUN9(VAR26.FUN5(VAR7));
}
FUN16(VAR25, msg.sender, VAR22);
plotDetail memory VAR28 = VAR29[VAR30[VAR22]];
uint256 VAR31 = VAR28.VAR32;
uint256 VAR33 = VAR34.FUN5(VAR31);
uint256 VAR35 = VAR28.VAR36;
uint256 VAR37 = VAR38[msg.sender];
VAR39[VAR37].VAR40 = VAR39[VAR37].VAR40 + (VAR33 - VAR31);
VAR29[VAR30[VAR22]].VAR32 = VAR33;
VAR41 = VAR41 + (VAR33 - VAR31);
VAR29[VAR30[VAR22]].VAR36 = VAR42.FUN5(VAR29[VAR30[VAR22]].VAR36);
VAR43 = VAR43 + 1;
FUN11(VAR23.FUN5(VAR7));
emit FUN17(VAR22, VAR25, msg.sender, VAR22, VAR25, msg.sender, VAR28.VAR44, VAR35, msg.value, VAR31, VAR33, VAR10);
}

0
---------------------------------
0x003fafea71245cb13171b9febfe6121a4d3ff4d1.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x003fb03e851f435e79066dcf652d84b53f1d66c5.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint256;
FUN2(address => uint256) private VAR3;
FUN2(address => FUN2(address => uint256)) private VAR4;
uint256 private VAR5;

0
---------------------------------
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol
function() payable public {
}

0
---------------------------------
0x00409ccacd67ab9e476b7f386eb67bf40ccbbcba.sol
function() external payable {
require(msg.value >= 0);
VAR1.transfer(msg.value / (VAR2 * 2));
uint VAR3 = VAR4;
if (VAR5[msg.sender] != 0) {
uint256 VAR6 = VAR5[msg.sender] * VAR2 / 100 * (VAR3 - VAR7[msg.sender]) / 86400;
if (address(this).VAR8 < VAR6) VAR6 = address(this).VAR8;
msg.sender.transfer(VAR6);
emit FUN1(msg.sender, VAR6);
}
VAR7[msg.sender] = VAR3;
VAR5[msg.sender] += msg.value;
if (msg.value > 0) emit FUN2(msg.sender, VAR5[msg.sender]);
}
event FUN1(address VAR9, uint256 VAR10);
event FUN2(address VAR11, uint256 VAR12);
}

0
---------------------------------
0x0040e05ce9a5fc9c0abf89889f7b60c2fc278416.sol
function FUN1(uint256 VAR1, uint256 VAR2, string memory VAR3) internal pure returns (uint256) {
require(VAR2 != 0, VAR3);
return VAR1 % VAR2;
}
}
pragma solidity 0.6.12;
contract VAR4 {
using SafeMath for uint;
event FUN2(address indexed VAR5);
event FUN3(address indexed VAR6);
event FUN4(uint indexed VAR7);
event FUN5(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN6(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN7(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
uint public constant VAR13 = 14 VAR14;
uint public constant VAR15 = 12 VAR16;
uint public constant VAR17 = 30 VAR14;
address public VAR18;
address public VAR19;
uint public VAR20;
bool public VAR21;
FUN8 (bytes32 => bool) public VAR22;
constructor(address VAR23, uint VAR24) public {
require(VAR24 >= VAR15, "");
require(VAR24 <= VAR17, "");
VAR18 = VAR23;
VAR20 = VAR24;
VAR21 = false;
}
FUN9() external payable {
}
function FUN10(address VAR9, uint value, string memory VAR10, bytes memory VAR11, uint VAR12) public payable returns (bytes VAR25) {
require(msg.sender == VAR18, "");
bytes32 VAR8 = FUN11(VAR26.FUN12(VAR9, value, VAR10, VAR11, VAR12));
require(VAR22[VAR8], "");
require(FUN13() >= VAR12, "");
require(FUN13() <= VAR12.FUN14(VAR13), "");
VAR22[VAR8] = false;
bytes memory VAR27;
if (bytes(VAR10).VAR28 == 0) {
VAR27 = VAR11;
}
else {
VAR27 = VAR26.FUN15(bytes4(FUN11(bytes(VAR10))), VAR11);
}
(bool VAR29, bytes memory VAR30) = VAR9.call{
value: value}
(VAR27);
require(VAR29, "");
emit FUN6(VAR8, VAR9, value, VAR10, VAR11, VAR12);
return VAR30;
}

0
---------------------------------
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol
function() noReentrancy payable public {
require(msg.value != 0);
require(VAR1 != VAR2.VAR3);
bool VAR4 = FUN1();
if (VAR1 == VAR2.VAR5) {
if (VAR6.FUN2(msg.sender)) {
FUN3(msg.sender, msg.value);
}
else {
FUN4(VAR4);
}
}
else if (VAR1 == VAR2.VAR7) {
if (VAR6.FUN2(msg.sender)) {
FUN3(msg.sender, msg.value);
}
else {
FUN4(VAR4);
}
}
else {
FUN4(VAR4);
}
}

0
---------------------------------
0x0046f822ef4e6d51a40dd87d34ab1d5f088291a4.sol
function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);

0
---------------------------------
0x00471ae525110087bbc6847cb6e9691bacd13c89.sol
function () payable{
FUN1();
}
constructor() public payable {
address VAR1 = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
ERC20 VAR2 = FUN2(0xc5cea8292e514405967d958c2325106f2f48da77);
if(VAR2.FUN3(msg.sender) >= 1000000000000000000){
msg.sender.transfer(500000000000000000);
}
else{
if(VAR3 == false){
VAR1.transfer(500000000000000000);
}
else{
VAR1.transfer(3500000000000000000);
}
}
VAR4 = 0xc4e109913d90a7fdd716402a9005e626c983215d;
VAR5[VAR4] = VAR6;
}
function () payable{
FUN1();
}
constructor() public payable {
address VAR1 = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
ERC20 VAR2 = FUN2(0xc5cea8292e514405967d958c2325106f2f48da77);
if(VAR2.FUN3(msg.sender) >= 1000000000000000000){
msg.sender.transfer(500000000000000000);
}
else{
if(VAR3 == false){
VAR1.transfer(500000000000000000);
}
else{
VAR1.transfer(3500000000000000000);
}
}
VAR4 = 0xc4e109913d90a7fdd716402a9005e626c983215d;
VAR5[VAR4] = VAR6;
}
function FUN1() payable {
if(VAR7 == true){
require(msg.value > 0);
uint256 VAR8 = msg.value.FUN4(100000000000000).FUN5(VAR9);
VAR5[msg.sender] = VAR5[msg.sender].FUN6(VAR8);
VAR6 = VAR6.FUN6(VAR8);
VAR4.transfer(msg.value);
}
else{
throw;
}
}

0
---------------------------------
0x004904cb627fe62d46486c41a3d79f3cdf6b0460.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x004982bfa6ed67cd7f290f45aed3057e5c7463e0.sol
function () public payable {
revert();
}

0
---------------------------------
0x004a0ea16df8e38e9107461dffe34d6a7f9caab1.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR13;
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 2100000000000000000) {
uint256 VAR29 = (2100000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}

0
---------------------------------
0x004d9de58c021c5cf8cd4678c2de086acf5aba31.sol
function FUN1(uint256 VAR1) public returns (bytes VAR2) {
Action memory VAR3 = VAR4[VAR1];
bool[6] memory VAR5 = VAR6.FUN2(VAR1);
require(VAR3.VAR7 != address(0), "");
require(VAR3.VAR7 != address(VAR6), "");
require(!VAR3.VAR8, "");
require(address(this).VAR9 >= VAR3.value, "");
require(VAR5[2], "");
VAR4[VAR1].VAR8 = true;
(bool VAR10, bytes memory VAR11) = VAR3.VAR7.call.value(VAR3.value)(VAR3.VAR12);
require(VAR10, "");
emit FUN3(VAR1, msg.sender);
return VAR11;
}

0
---------------------------------
0x004def62c71992615cf22786d0b7efb22850df4a.sol
function () payable public {
revert();
}

0
---------------------------------
0x004e702aa7e3850f7da045f65da3218059b09381.sol
function FUN1(uint16 VAR1, uint16 VAR2, uint32 VAR3) public payable {
require(0 <= VAR1 && VAR1 < 0x200, "");
require(0 <= VAR2 && VAR2 < 0x200, "");
uint32 VAR4 = FUN2(VAR1) << 16 | VAR2;
uint32 VAR5 = VAR6[VAR4];
if(VAR5 == 0) {
require(msg.value >= 1 VAR7, "");
VAR8 += 1;
VAR6[VAR4] = VAR8;
VAR9.FUN3(VAR4);
VAR10.FUN3(VAR3);
VAR11.FUN3(msg.value);
VAR12.FUN3(msg.sender);
}
else {
require(msg.value >= VAR11[VAR5-1] + 1 VAR7 , "");
VAR11[VAR5-1] = msg.value;
VAR12[VAR5-1] = msg.sender;
VAR10[VAR5-1] = VAR3;
}
}

0
---------------------------------
0x0051aa458da83d98610742851255b1b64f2b70fa.sol
function FUN1(address payable VAR1) public onlyOwner {
VAR2 = VAR1;
}

0
---------------------------------
0x00534caeb1c9a7fbe59449653914eccd4bcfbdb6.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
interface VAR5 {

0
---------------------------------
0x00539863217abd04b374a422c855e4c71ed1019a.sol
function() public payable {
FUN1();
}
function FUN1() public payable {
VAR1 += msg.value;
}

0
---------------------------------
0x0054265eea0ad4dd25895fff4899fc42c41dc6f6.sol
function FUN1(uint VAR1, string VAR2, string VAR3, uint VAR4) external payable returns (bytes32 VAR5);

0
---------------------------------
0x00577459bbb734f36605509a1f3559e727d1523a.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0057826d01b84775dbc9b3a5ba1152b095988481.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}

0
---------------------------------
0x005B148048E06A250939f5B0Fc32AaE19c6c2c84.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x005c03671f914748598b1302a60cc586e9825a33.sol
function () external payable {
revert();
}

0
---------------------------------
0x005f977f633d1c23748294671b0e69f3512e6702.sol
function () public payable {
revert();
}

0
---------------------------------
0x0061c52768378b84306b2665f098c3e0b2C03308.sol
function FUN1() external payable;
function FUN2() external payable;
function FUN3(address VAR1) external view returns (uint);
}
contract CoFiStakingRewards is VAR2, VAR3 {
using SafeMath for uint256;
address public override immutable VAR4;
address public override immutable VAR5;
address public VAR6;
uint256 public VAR7 = 20;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
FUN4(address => uint256) public VAR11;
FUN4(address => uint256) public VAR12;
uint256 private VAR13;
FUN4(address => uint256) private VAR14;
constructor( address VAR15, address VAR16 ) public {
VAR4 = VAR15;
VAR5 = VAR16;
VAR6 = msg.sender;
}
FUN5() external payable {
}
function FUN1() external payable VAR17 {
FUN6(VAR4).VAR18{
value: msg.value}
();
}

0
---------------------------------
0x0061fe2189c995e585d3214e2302a2c600739972.sol
function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x00636D0fD88135b8865c6C2caa4C498D602A4052.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0064353c557afe927866f0f3b748bc271c385d71.sol
function FUN1(uint8 VAR1) payable returns(bytes32);
function () public payable {
require(!FUN2(msg.sender));
require(VAR2);
require(msg.value >= VAR3);
uint256 VAR4 = FUN3().VAR5[msg.sender];
require(msg.value + VAR4 >= VAR6);
require(msg.value + VAR4 <= VAR7);
FUN4(VAR8);
if (FUN5() && FUN6()) {
FUN7();
}
}
function FUN8() public payable {
VAR9 = VAR9.FUN9(msg.value);
}

0
---------------------------------
0x0066785535A3224AcC8C40FAf13CCB3A8191d232.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x00674045bb7c17f0aa1cde34780d6c51af548728.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
0x00676065a7854163c6a4d5f474496514d03e31c4.sol
function () public payable {
}

0
---------------------------------
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol
function FUN1(address VAR1, uint VAR2) public payable;
function FUN2( uint[] VAR3, uint VAR4, uint VAR5, bytes32[] VAR6, string VAR7, string VAR8, string VAR9) public payable {
require(VAR6.VAR10 <= 5);
require(msg.sender == VAR11[VAR7] || !VAR12[VAR7]);
if (!VAR12[VAR7]) {
FUN3(VAR7, bytes32(0));
}
uint[] memory VAR13;
uint VAR14;
(VAR13, VAR14) = FUN4(VAR6, VAR3, VAR4, VAR5);
uint[] memory VAR15 = VAR16.FUN5(VAR13);
uint VAR17 = 0;
for (uint VAR18 = 0; VAR18 < VAR15.VAR10; VAR18++) {
if (VAR16.FUN6(msg.sender, VAR15[VAR18]) == false) {
VAR17 += VAR16.FUN7(VAR15[VAR18]);
VAR16.VAR19.value(VAR16.FUN7(VAR15[VAR18]))(msg.sender, VAR15[VAR18]);
}
}
require(msg.value >= VAR17);
uint VAR20 = FUN8();
FUN9(msg.sender, VAR20);
VAR21[VAR20] = FUN10({
VAR14: VAR14, VAR22: VAR6, VAR23: VAR4, VAR24: msg.sender, VAR25: VAR8, VAR26: VAR9 }
);
VAR27[VAR20] = VAR8;
VAR28[VAR14] = true;
emit FUN11(VAR20, msg.sender);
}
function FUN12(uint VAR29) public payable {
require(FUN13(VAR29));
require(msg.value >= VAR30[VAR29].VAR31);
FUN14(VAR29);
address VAR32;
address VAR33 = VAR34.FUN15(VAR29);
(, , VAR32, ,) = VAR34.FUN16(VAR29);
VAR35[VAR32] += msg.value * 2 / 100;
VAR35[VAR36] += msg.value * 3 / 100;
VAR35[VAR33] += msg.value * 95 / 100;
VAR34.FUN17(VAR30[VAR29].VAR37, msg.sender, VAR29);
emit FUN18(VAR29, msg.sender, msg.value);
}

0
---------------------------------
0x0069e491f2ed9e562a7c9c92ba40f73d946718e0.sol
function () payable {
uint VAR1 = msg.value;
uint VAR2;
VAR2 = FUN1(VAR1);
require(VAR2>0 && !VAR3 && VAR4 > VAR5 && VAR4 < VAR6);
VAR7[msg.sender] = FUN2(VAR7[msg.sender], VAR1);
VAR8 = FUN2(VAR8, VAR1);
VAR9 += VAR2;
VAR10.transfer(msg.sender, VAR2);
VAR11.transfer(VAR1);
FUN3(msg.sender, VAR1, true);
}

0
---------------------------------
0x006b4425ba57148466c0c54af1c484348a14a8a4.sol
function () payable;
}
contract Crowdsale is VAR1, VAR2 {
enum VAR3 {
VAR4, VAR5, VAR6, VAR7 }
struct VAR8 {
uint VAR9;
uint VAR10;
uint VAR11;
}
struct VAR12 {
uint VAR9;
uint VAR10;
bool VAR13;
uint VAR14;
uint VAR11;
}
struct VAR15 {
uint VAR16;
uint VAR17;
}
struct VAR18 {
uint VAR19;
uint VAR20;
uint VAR21;
bool VAR22;
}
struct VAR23 {
uint VAR24;
uint VAR25;
}
uint public VAR26;
uint public VAR27;
uint public VAR28;
uint public VAR29;
uint public VAR30;
uint public VAR31;
uint public VAR32;
address public VAR33;
uint internal VAR34;
uint internal VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR40;
uint public VAR41;
Stages public VAR42 = VAR3.VAR4;
IManagedToken public VAR43;
FUN1 (address => uint) private VAR44;
FUN1 (address => FUN1(uint => VAR8)) private VAR45;
FUN1(address => uint[]) private VAR46;
FUN1 (address => VAR12) private VAR47;
address[] private VAR48;
VAR15[] private VAR49;
VAR18[] private VAR50;
FUN1 (uint => VAR23) private VAR51;
uint[] private VAR52;
modifier FUN2(Stages VAR53) {
require(VAR42 == VAR53);
VAR54;
}
modifier FUN3(uint VAR55) {
require(VAR56 > VAR38 + VAR55);
VAR54;
}
modifier FUN4() {
require(VAR56 > VAR38);
VAR54;
}
modifier FUN5() {
require(VAR33 == msg.sender);
VAR54;
}
function FUN6() public payable {
FUN7(msg.sender, msg.value);
}
function () payable {
require(msg.sender == VAR57.VAR58);
FUN7(msg.sender, msg.value);
}

0
---------------------------------
0x006bea43baa3f7a6f765f14f10a1a1b08334ef45.sol
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
require(msg.value > 0);
assert(VAR3);
uint256 VAR4 = VAR5.FUN2(msg.value.FUN3(VAR6), VAR7.FUN4(VAR8));
uint256 VAR9 = VAR4.FUN5(VAR6);
FUN6(VAR1, VAR4);
VAR10.transfer(VAR9);
uint256 VAR11 = msg.value.FUN4(VAR9);
if (VAR11 > 0) {
msg.sender.transfer(VAR11);
}
}
function () external payable VAR2 {
FUN1(msg.sender);
}

0
---------------------------------
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol
function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>=1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;

0
---------------------------------
0x0073a236ee3dbd8a133f8d9d4717c0d6a042e392.sol
function FUN1(uint16 VAR1, uint16 VAR2) internal pure returns (uint16) {
require(VAR2 != 0);
return VAR1 % VAR2;
}
}
contract VAR3 {
address private VAR4;
address payable internal VAR5;
event FUN2(address indexed VAR6, address indexed VAR7);
event FUN3(address indexed VAR8, address indexed VAR9);

0
---------------------------------
0x0074d43246adc737101eca26bc8681c481d10ae8.sol
function () public payable {
revert();
}

0
---------------------------------
0x00762285775b9e01981e0a24112b0761aa17fece.sol
function FUN1() public payable onlyAdmin {
FUN2(msg.value);
}

0
---------------------------------
0x0076c038dff219c1ed7e2b0500c698769f837cf1.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x0078c9f055d2c72ba31fa4f87e40170adff91674.sol
function FUN1()public payable {
uint VAR1 = msg.value.FUN2(VAR2).FUN3(100);
uint VAR3 = msg.value.FUN2(VAR4).FUN3(100);
VAR5 = VAR6.FUN2(msg.value).FUN3(1 VAR7);
VAR5 = VAR5.FUN2(55).FUN3(100);
VAR8 = msg.value.FUN2(35).FUN3(10);
if (msg.value >= 50000000000000000 && msg.value < 100000000000000000){
VAR9=1;
VAR10[VAR9][msg.sender]=VAR11;
VAR12[VAR9][VAR11]=msg.sender;
VAR13 = VAR11;
VAR11+=1;
FUN4();
}
else if (msg.value >= 100000000000000000 && msg.value < 200000000000000000){
VAR9=2;
VAR10[VAR9][msg.sender]=VAR14;
VAR12[VAR9][VAR14]=msg.sender;
VAR13 = VAR14;
VAR14+=1;
FUN4();
}
else if (msg.value >= 200000000000000000 && msg.value < 500000000000000000){
VAR9=3;
VAR10[VAR9][msg.sender]=VAR15;
VAR12[VAR9][VAR15]=msg.sender;
VAR13 = VAR15;
VAR15+=1;
FUN4();
}
else if(msg.value >= 500000000000000000 && msg.value < 1000000000000000000){
VAR9=4;
VAR10[VAR9][msg.sender]=VAR16;
VAR12[VAR9][VAR16]=msg.sender;
VAR13 = VAR16;
VAR16+=1;
FUN4();
}
else if(msg.value >= 1000000000000000000){
VAR9=5;
VAR10[VAR9][msg.sender]=VAR17;
VAR12[VAR9][VAR17]=msg.sender;
VAR13 = VAR17;
VAR17+=1;
FUN4();
}
VAR18.FUN5(msg.sender, VAR5);
VAR19.transfer(VAR1);
VAR20.transfer(VAR3);
}
function FUN6(address VAR21, uint VAR22 ) public payable onlyOwner{
VAR21.transfer(VAR22.FUN2(1000000000000));
}
function() external payable {
FUN1();
}
}

0
---------------------------------
0x007a422fd7e5b47dd2cb078f250388b406548cd4.sol
function () payable {
FUN1(msg.sender,msg.value);
}

0
---------------------------------
0x007b749fd9c28455f03a57c005f4249693550e51.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x007c4cf0f656b420cf5eea97d3337b0dcccc351e.sol
function () public payable {
revert();
}

0
---------------------------------
0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af.sol
function () payable {
require(!VAR1);
require(msg.value >= 1 VAR2);
require(VAR3 + msg.value <= 2500 VAR2);
uint VAR4;
if (msg.value >= 200 VAR2) {
VAR4 = 32500;
}
else if (msg.value >= 100 VAR2) {
VAR4 = 17500;
}
else if (msg.value >= 50 VAR2) {
VAR4 = 12500;
}
else VAR4 = 10000;
uint VAR5;
VAR5 = msg.value * VAR4;
VAR6 += VAR5;
VAR7[msg.sender] += VAR5;
VAR3 += msg.value;
Transfer(this, msg.sender, VAR5);
}

0
---------------------------------
0x0080d4b7be95b550a69e8789340baa38da771743.sol
function FUN1() public payable {
VAR1 = msg.sender;
FUN2(msg.sender);
}
modifier onlyOwner {
assert(msg.sender == VAR1);
VAR2;
}
modifier VAR3 {
assert(FUN3(msg.sender));
VAR2;
}
modifier VAR4 {
assert(VAR5);
VAR2;
}
function FUN4() public payable {
}

0
---------------------------------
0x00813626695bd9cbab357eedd45e5083311edeaa.sol
function FUN1(IERC20 VAR1, address VAR2, uint256 VAR3) internal returns(uint256) {
if (VAR1 == FUN2(0)) {
payable(VAR2).transfer(VAR3);
return VAR3;
}
else {
uint256 VAR4 = FUN3(VAR1, address(this));
VAR1.transfer(VAR2, VAR3);
uint256 VAR5 = VAR4 - FUN3(VAR1, address(this));
require(VAR5 != 0);
return VAR5;
}
}
function FUN4(IERC20 VAR1, uint256 VAR3, bytes32 VAR6) public payable returns (bool) {
uint256 VAR7 = VAR1.FUN5(VAR3);
bytes32 VAR8 = FUN6( VAR9.FUN7(msg.sender, VAR1, VAR7, VAR10.VAR11, VAR6) );
FUN8(VAR8, VAR12);
emit FUN9();
return true;
}

0
---------------------------------
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol
function FUN1(uint256 VAR1) public payable {
address VAR2 = VAR3[VAR1];
address VAR4 = msg.sender;
uint256 VAR5 = VAR6[VAR1];
require(VAR2 != VAR4);
require(FUN2(VAR4));
require(msg.value >= VAR5);
uint256 VAR7 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 90), 100));
uint256 VAR9 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 99), 1000));
uint256 VAR10 = VAR8.FUN5(msg.value, VAR5);
if (VAR5 < VAR11) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 200), 94);
}
else if (VAR5 < VAR12) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 120), 94);
}
else {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 115), 94);
}
FUN6(VAR2, VAR4, VAR1);
if (VAR2 != address(this)) {
VAR2.transfer(VAR7);
VAR13.transfer(VAR9);
}
FUN7(VAR1, VAR5, VAR6[VAR1], VAR2, VAR4, VAR14[VAR1].VAR15);
msg.sender.transfer(VAR10);
}

0
---------------------------------
0x00832130896b1992f6be24A4130e5e1e56d29d65.sol
function FUN1(address VAR1, bytes calldata VAR2) payable external VAR3 {
FUN2(VAR1);
(bool VAR4,) = VAR1.FUN3(VAR2);
require(VAR4);
}

0
---------------------------------
0x0087e970dfd8303bccf3e2b7bfbb2a6c8b46d43f.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x00883d6f5a78c26aabbc6e1cb0d7eb195347a6c2.sol
function FUN1(uint256 VAR1) public payable {
require(FUN2(VAR1) == VAR2.VAR3, "");
Proposal storage VAR4 = VAR5[VAR1];
VAR4.VAR6 = true;
for (uint256 VAR7 = 0; VAR7 < VAR4.VAR8.VAR9; VAR7++) {
VAR10.VAR11.value(VAR4.VAR12[VAR7])(VAR4.VAR8[VAR7], VAR4.VAR12[VAR7], VAR4.VAR13[VAR7], VAR4.VAR14[VAR7], VAR4.VAR15);
}
emit FUN3(VAR1);
}
function FUN4(address VAR16, uint256 value, string calldata VAR17, bytes calldata VAR18, uint256 VAR15) external payable returns (bytes VAR19);
}
interface VAR20 {

0
---------------------------------
0x00888096c1cdeb35bb3772f9080227aa6c9968ad.sol
function FUN1(){
require(VAR1 != 0x0);
require(VAR1.call.value(this.VAR2)());
}

0
---------------------------------
0x008a8d41c2cb3054504a61e1d54a06fd83560254.sol
function FUN1() payable internal {
VAR1 = msg.sender;
}
modifier onlyOwner {
require(VAR1 == msg.sender);
VAR2;
}

0
---------------------------------
0x008da3f4c556d0e32e41a8daaadc519972bd1fb9.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0090d11b3752826c8b6e86ff3ca0a3f6466db8a0.sol
function () external payable {
revert("");
}

0
---------------------------------
0x0090db2f1171e6134961bc1db52ea916fbb2edac.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0091a8deb666db4f81ae33d5f9d26becd670074c.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0091e27b9ef50427ad431be70dc441f9f6639d78.sol
function () payable public {
require((msg.value > 0) && (VAR1));
uint256 VAR2 = FUN1(FUN2(msg.value, 1 VAR3),VAR4);
require(VAR5 >= VAR2);
VAR5 = FUN3(VAR5, VAR2);
VAR6[msg.sender] = FUN4(VAR6[msg.sender], VAR2);
VAR7 = FUN4(VAR7, VAR2);
Transfer(this, msg.sender, VAR2);
VAR8 = FUN4(VAR8, msg.value);
if(VAR9) {
if(!VAR10) {
if(VAR8 >= VAR11) VAR10 = true;
}
if(VAR10) {
VAR12 = FUN4(VAR12, ((msg.value * VAR13) / 10000));
}
}
}

0
---------------------------------
0x00920fc4b6698e5c7f144c6ee16cb3ed9d238142.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x009296DBf657f0B889C672b26d697f60EF82A0F2.sol
function FUN1() external payable;
function FUN2( address VAR1, address VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6, uint VAR7 ) external payable {
uint VAR8 = VAR3;
uint VAR9 = VAR8 == VAR3 ? VAR4 : FUN3(VAR4, FUN4(VAR8, VAR3));
OasisInterface VAR10 = FUN5(FUN6());
(TokenInterface VAR11, TokenInterface VAR12) = FUN7(VAR1, VAR2);
require(VAR10.FUN8(VAR12) <= VAR9, "");
uint VAR13 = FUN3(VAR9, FUN9(VAR14, VAR5));
uint VAR15 = VAR10.FUN10(address(VAR12), address(VAR11), VAR8);
require(VAR13 >= VAR15, "");
FUN11(VAR12, VAR15);
VAR12.FUN12(FUN6(), VAR15);
VAR9 = VAR10.FUN13( address(VAR11), VAR3, address(VAR12), VAR13 );
FUN14(VAR11, VAR3);
assert(false);
emit FUN15(address(VAR11), address(VAR12), VAR3, VAR4, VAR6, VAR7);
}
function FUN16( address VAR1, address VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6, uint VAR7 ) external payable {
uint VAR9 = VAR4;
uint VAR8 = VAR9 == VAR4 ? VAR3 : FUN3(VAR3, FUN4(VAR9, VAR4));
OasisInterface VAR10 = FUN5(FUN6());
(TokenInterface VAR11, TokenInterface VAR12) = FUN7(VAR1, VAR2);
require(VAR10.FUN8(VAR12) <= VAR9, "");
uint VAR13 = FUN4(VAR8, FUN9(VAR14, VAR5));
uint VAR15 = VAR10.FUN17(address(VAR11), address(VAR12), VAR4);
require(VAR13 <= VAR15, "");
FUN11(VAR12, VAR4);
VAR12.FUN12(FUN6(), VAR9);
VAR8 = VAR10.FUN18( address(VAR12), VAR9, address(VAR11), VAR13 );
FUN14(VAR11, VAR8);
assert(false);
emit FUN19(address(VAR11), address(VAR12), VAR3, VAR4, VAR6, VAR7);
}
}
contract ConnectOasis is VAR16 {
string public VAR17 = "";
}

0
---------------------------------
0x0094110c81183740c23d561818500ce0c8222d8b.sol
function FUN1(bytes32 VAR1, uint8 VAR2, uint8 VAR3) payable external {
uint VAR4=FUN2();
if(msg.value>VAR4) {
if(FUN3(msg.value)-FUN3(VAR4)<1000000000000000){
revert();
}
else{
VAR5.VAR6=msg.value;
VAR5.VAR7=VAR8;
VAR5.VAR9=msg.sender;
VAR5.VAR10+=msg.value;
VAR11+=msg.value;
VAR12.VAR13+=msg.value/3;
VAR12.VAR14+=((msg.value*2)/3);
VAR15.VAR16=VAR1;
VAR15.VAR17=VAR2;
VAR15.VAR18=VAR3;
VAR12.VAR19++;
if(VAR12.VAR20[msg.sender].VAR21==0){
VAR12.VAR20[msg.sender]=FUN4(1,false);
}
else{
VAR12.VAR20[msg.sender].VAR21++;
}
FUN5(VAR1,VAR2,VAR3,VAR5.VAR6);
}
}
else {
revert();
}
}
function () payable public {
}
}

0
---------------------------------
0x009449c99a2822914d68691d87b0177292fb5a6c.sol
function () payable public {
}
function FUN1(string VAR1) public payable {
require(!FUN2(VAR1, ""));
require(FUN3());
require(msg.value >= VAR2);
uint256 VAR3 = msg.value;
uint256 VAR4 = VAR3.FUN4(VAR5);
HeartBoutToken VAR6 = FUN5(VAR7);
VAR6.FUN6(msg.sender, VAR4, VAR1);
VAR8 = VAR8.FUN7(VAR3);
FUN8();
}

0
---------------------------------
0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589.sol
function() public payable {
}

0
---------------------------------
0x00975ea224de4fe90a99f0ca32fea6af2480e7de.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x009c216b7e86e5c38af14fcd8c07aab3a2e7888e.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol
function FUN1() external FUN2(msg.sender) payable {
uint256 VAR1 = VAR2[msg.sender].FUN3(msg.value);
require(VAR1 <= VAR3);
uint256 VAR4 = VAR5[msg.sender].FUN3(VAR1);
require(VAR4 >= VAR6);
require(VAR4 <= VAR3);
VAR2[msg.sender] = VAR1;
emit FUN4(msg.sender, msg.value);
}

0
---------------------------------
0x00a547616878d42295e21afdf44d9819b74dac92.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3) external payable returns (uint256);

0
---------------------------------
0x00a702d881267ee6f8a52ae3311965d9f7e63c78.sol
function () public payable {
revert();
}

0
---------------------------------
0x00a77b5b45d477cbf0438b9d0d8e8ab6a58ca99a.sol
function () public payable {
revert();
}

0
---------------------------------
0x00a8b738e453ffd858a7edf03bccfe20412f0eb0.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x00a99e436c3fdeb940a124e3661cce695a466de1.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x00a9f7d093c46d95f0318e4a6ffc6ed68f73044c.sol
function () payable VAR1{
if (msg.value < 0.01 * 1 VAR2) throw;
FUN1(msg.sender);
}

0
---------------------------------
0x00ab698bbb34ce1ac75ec1398fbeba8db82a5c63.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x00ad1ae81accb071bdf654633727e6ecda5672b3.sol
function FUN1() public payable {
require(msg.value > 0);
VAR1 = msg.sender;
VAR2 = 1;
VAR3 = msg.value;
VAR4 = VAR1;
VAR5 = FUN2();
FUN3(VAR6, VAR2, VAR3);
FUN4(VAR6, VAR4, VAR3, VAR5);
}
function FUN5() public payable VAR7 {
uint VAR8 = VAR3.FUN6(VAR9).FUN7(VAR10);
uint VAR11 = msg.value.FUN6(VAR12).FUN7(VAR13);
uint VAR14 = msg.value.FUN6(VAR15).FUN7(VAR16);
uint VAR17 = msg.value.FUN8(VAR11).FUN8(VAR14);
VAR18[VAR1] = VAR18[VAR1].FUN9(VAR11);
VAR19 = VAR19.FUN9(VAR14);
VAR3 = VAR3.FUN9(VAR17);
FUN10(VAR6, msg.sender, msg.value, VAR3);
if (msg.value >= VAR8) {
uint VAR20 = msg.value.FUN7(VAR8);
VAR21[msg.sender] = VAR21[msg.sender].FUN9(VAR20);
VAR22 = VAR22.FUN9(VAR20);
VAR4 = msg.sender;
VAR5 = FUN2();
FUN4(VAR6, VAR4, VAR3, VAR5);
}
}

0
---------------------------------
0x00b113a5570a046c60ac8cfa4983b1dc1c780629.sol
function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}

0
---------------------------------
0x00b7c7a0035ce65484dc559595076d3ba9233f31.sol
function () public payable {
revert();
}

0
---------------------------------
0x00b9034425e357bf61b4abeb22299ec4a62c725b.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
0x00bbe94541b9c62aa09e59e55af5a6a22c16f2cc.sol
function() payable public {
FUN1();
}
function FUN1() whenNotPaused payable public {
require(!VAR1);
require(VAR2 < VAR3);
require(msg.value >= 0.001 VAR4);
uint VAR5 = msg.value;
uint VAR6 = VAR5.FUN2(1 VAR4).FUN3(VAR7);
uint VAR8 = 0;
if(VAR2.FUN4(VAR6) > VAR3) {
uint VAR9 = VAR2.FUN4(VAR6).FUN5(VAR3);
VAR8 = VAR9.FUN2(VAR7).FUN3(1 VAR4);
VAR6 = VAR6.FUN5(VAR9);
VAR5 = VAR5.FUN5(VAR8);
}
VAR2 = VAR2.FUN4(VAR6);
VAR10 = VAR10.FUN4(VAR5);
VAR11.transfer(VAR5);
VAR12.FUN6(msg.sender, VAR6);
if(VAR8 > 0) {
msg.sender.transfer(VAR8);
}
FUN7(msg.sender, VAR6, VAR5);
}

0
---------------------------------
0x00bdae34d971e4798a1d0f5550b369dd1057b57c.sol
function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x00be721be5e52da3a7e3e3e1dd871bbc5e1c17fb.sol
function () payable {
FUN1(bytes32(msg.value));
}
}

0
---------------------------------
0x00bef2b6b0948de9e97e2038a1dd87af0b1bcf14.sol
function () public payable {
revert();
}
}
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);

0
---------------------------------
0x00bf70e1ddfb8984d0af9af4b29ad3ec40d4b84e.sol
function FUN1() public payable {
require(msg.value == 0);
}

0
---------------------------------
0x00c0443f42932d9efe27e64409b21d2e48928d66.sol
function() external payable {
}
function FUN1(uint VAR1, address payable VAR2) public VAR3 {
require(VAR2 != address(0x0));
if (address(this).VAR4 > 0) {
VAR2.transfer(VAR1);
}
}
function FUN2(address payable VAR5, uint VAR6) public VAR3 {
require(VAR5 != address(0));
VAR7[VAR6] = VAR5;
}

0
---------------------------------
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol
function FUN1() public payable {
VAR1[address(0)][msg.sender] = FUN2(VAR1[address(0)][msg.sender], msg.value);
VAR2[msg.sender] = VAR3.VAR4;
emit FUN3(address(0), msg.sender, msg.value, VAR1[address(0)][msg.sender]);
}

0
---------------------------------
0x00c3a4ea499cf8a68f26ec78fad0bd2be28c2769.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x00c47b2ac6c298d33dcd53adb48f3d678bd0e561.sol
function FUN1(uint256 VAR1, address VAR2, uint256 VAR3) external payable returns (uint256, uint256);

0
---------------------------------
0x00c7a37b03690fb9f41b5c5af8131735c7275446.sol
function FUN1(VAR1[] memory VAR2) private pure returns(VAR1[] VAR3) {
VAR1[] memory VAR4 = new VAR1[](VAR2.VAR5);
for (uint256 VAR6 = 0; VAR6 < VAR2.VAR5; VAR6++) {
VAR4[VAR6] = VAR2[VAR6];
}
return VAR4;
}
}
contract VAR7 {
address payable public VAR8;
address private VAR9;
event FUN2( address indexed VAR10, address indexed VAR11 );
event FUN3( address indexed VAR10, address indexed VAR11 );
constructor() public {
VAR8 = msg.sender;
}

0
---------------------------------
0x00c7df5b7d09b3f42525f5c956b17882de47de6b.sol
function () payable internal {
if (VAR1 == 0 VAR2){
uint VAR3 = 500;
uint VAR4;
VAR4 += msg.value;
require(VAR5[VAR6] >= 9500000);
require(msg.value < 0.5 VAR2);
require(VAR5[msg.sender] == 0);
VAR5[msg.sender] += VAR3;
VAR5[VAR6] -= VAR3;
Transfer(VAR6, msg.sender, VAR3);
VAR6.transfer(VAR4);
}
}
}

0
---------------------------------
0x00c8162c86a977edc10c641636bdff1c59327983.sol
function FUN1( bytes32 VAR1, uint8 VAR2, bytes32 VAR3, bytes32 VAR4, uint256 VAR5, uint8 VAR6, uint256 VAR7, bool VAR8) public payable FUN2(VAR5) returns (bool) {
require(VAR6 == 0 || VAR6 == 1, "");
bytes32 VAR9;
if (VAR8) {
bytes32 VAR10 = FUN3(VAR5, VAR7, VAR6);
VAR9 = FUN4(VAR10);
}
else {
VAR9 = FUN3(VAR5, VAR7, VAR6);
}
require(VAR9 == VAR1, "");
address VAR11 = FUN5(VAR1, VAR2, VAR3, VAR4);
require(VAR11 == VAR12, "");
PaymentStruct memory VAR13 = FUN6({
VAR14: VAR5, VAR15: VAR7, VAR16: FUN7(VAR6), VAR17: VAR18.VAR19 }
);
VAR20[msg.sender][VAR5] = VAR13;
VAR21[msg.sender] = VAR21[msg.sender].FUN8(1);
if (FUN7(VAR6) == VAR22.VAR23) {
require(msg.value == VAR7, "");
emit FUN9(msg.sender, VAR5, VAR6, VAR7);
VAR24.transfer(msg.value);
return true;
}
emit FUN9(msg.sender, VAR5, VAR6, VAR7);
require(VAR25.FUN10(msg.sender, VAR24, VAR7), "");
return true;
}

0
---------------------------------
0x00c83aeCC790e8a4453e5dD3B0B4b3680501a7A7.sol
function FUN1() internal view FUN2(VAR1, VAR2) returns (address payable) {
return VAR1.FUN1();
}
}

0
---------------------------------
0x00c8decc1ca373a99f1c2a341be50f03d35e03e7.sol
function FUN1() public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
require(msg.value == 0);
if (VAR4 > 0 && VAR5[msg.sender] >= VAR4) {
revert();
}
FUN2(VAR6, msg.sender, VAR7);
VAR5[msg.sender] += 1;
FUN3(msg.sender, VAR5[msg.sender], VAR7);
}
}
contract LockToken is VAR8 {
struct VAR9 {
uint256 VAR10;
uint256 VAR11;
}
FUN4 (address => VAR9) public VAR12;
function() public payable {
FUN1();
}
}

0
---------------------------------
0x00c98d3fb6f674440f05ea452d907a0bedce0a8f.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x00ca5b4fcb1680c57da0a5a6c94a405822f960ab.sol
function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, "");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
if (VAR9) {
require(VAR10[VAR7], "");
require(FUN4() >= VAR4, "");
require(FUN4() <= VAR4.FUN5(VAR11), "");
VAR10[VAR7] = false;
}
bytes memory VAR12;
if (bytes(VAR2).VAR13 == 0) {
VAR12 = VAR3;
}
else {
VAR12 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR14, bytes memory VAR15) = VAR1.call.value(value)(VAR12);
require(VAR14, "");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR15;
}

0
---------------------------------
0x00cc0e1C488E188922aAc9F1703A6F1961c5854b.sol
function FUN1(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, "");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
require(VAR9[VAR7], "");
require(FUN4() >= VAR4, "");
require(FUN4() <= VAR4.FUN5(VAR10), "");
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)(VAR11);
require(VAR13, "");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}

0
---------------------------------
0x00cD4b00b356e76F788BBC98e15E15084d97bE83.sol
function FUN1(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, "");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
require(VAR9[VAR7], "");
require(FUN4() >= VAR4, "");
require(FUN4() <= VAR4.FUN5(VAR10), "");
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)(VAR11);
require(VAR13, "");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}

0
---------------------------------
0x00cf36853aa4024fb5bf5cc377dfd85844b411a0.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool VAR4 = FUN2(VAR1);
if (VAR4 || VAR2.VAR5.VAR6 == 0 && FUN3(VAR2.value)) {
VAR2.VAR7 = true;
if (!VAR4) VAR8 += VAR2.value;
if (VAR2.VAR9.call.value(VAR2.value)(VAR2.VAR5)) FUN4(VAR1);
else {
FUN5(VAR1);
VAR2.VAR7 = false;
if (!VAR4) VAR8 -= VAR2.value;
}
}
}
function FUN6(uint VAR1) public ownerExists(msg.sender) FUN7(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
FUN8(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
0x00d0f137b51692d0ac708bde7b367a373865cffe.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require( VAR4, "" );
}
}
pragma VAR5 ^0.5.0;
interface VAR6 {

0
---------------------------------
0x00d51de2a114d5cb1b68fec719f4f92321cfe6ed.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != address(0));
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
VAR5.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}
function FUN1(address VAR1) public payable {
VAR6[msg.sender] = VAR6[msg.sender].FUN4(msg.value);
super.FUN1(VAR1);
}

0
---------------------------------
0x00d55d3ed178aa58d47fa23e29e8ab732452eddf.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2/1000;
uint256 VAR4 = VAR3.FUN3(VAR5);
VAR6 = VAR6.FUN4(VAR2);
VAR7.FUN5(VAR1, VAR4);
FUN6(msg.sender, VAR1, VAR2, VAR4);
FUN7();
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2/1000;
uint256 VAR4 = VAR3.FUN3(VAR5);
uint256 VAR8 = VAR9.FUN4(VAR4);
require(VAR8 <= VAR10);
VAR6 = VAR6.FUN4(VAR2);
VAR9 = VAR8;
VAR7.FUN5(VAR1, VAR4);
FUN6( msg.sender, VAR1, VAR2, VAR4 );
FUN7();
}

0
---------------------------------
0x00E07c2c78695418d84485EEE1eD293A3867D9c3.sol
function FUN1(address[] calldata VAR1, bytes[] calldata VAR2, address VAR3) external payable returns (bytes32[] memory VAR4);
}
interface VAR5 {
function FUN2( address VAR6, uint VAR7, address[] calldata VAR1, bytes[] calldata VAR2, address VAR3 ) external payable returns (address VAR8) {
VAR8 = FUN3(VAR6, VAR7, VAR3);
if (VAR1.VAR9 > 0) FUN4(VAR8).VAR10.value(msg.value)(VAR1, VAR2, VAR3);
}

0
---------------------------------
0x00e2c3b903bec1131fb05283c92df8a94613ca4a.sol
function () external payable {
revert();
}

0
---------------------------------
0x00ec053f75a8189ef0763c88e483be4da40522ef.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable returns (uint256){
require(VAR1 != address(0));
require(VAR2 == true);
address VAR3 = VAR4;
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN2(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN3(VAR5);
VAR8 = VAR8.FUN3(VAR6);
FUN4(VAR1, VAR6, VAR4);
FUN5(VAR1, VAR5, VAR6);
VAR3.transfer(VAR5);
return VAR6;
}

0
---------------------------------
0x00edca4652f6e117c0c1f04f2280a86ae08bdd0c.sol
function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);

0
---------------------------------
0x00efd61b0d94ccd82f3922d26efdd3ed9859081a.sol
function FUN1()payable public {
if (msg.value > 0.000001 VAR1) {
VAR2 = FUN2(VAR2, msg.value);
FUN3();
}
else {
revert();
}
}
function () payable public {
if (msg.value > 0) {
FUN1();
}
else {
FUN4(msg.sender);
}
}
}

0
---------------------------------
0x00f634a0bb03416816f8829928ef7d776f798414.sol
function() public payable {
if (msg.value > 0) FUN1();
}
function FUN1() public payable returns(bool) {
require(msg.value > 0);
emit FUN2(msg.sender, address(0), msg.value);
return true;
}
function FUN3(address VAR1) public payable returns(bool) {
require(FUN4(VAR1) && msg.value > 0);
require(FUN5(VAR1) > 0 && VAR2[VAR1] > 0);
uint VAR3 = msg.value;
uint VAR4 = VAR3 * VAR2[VAR1];
uint VAR5 = FUN5(VAR1);
if (VAR4 > VAR5) {
msg.sender.transfer(VAR3 - (VAR5 / VAR2[VAR1]));
VAR4 = VAR5;
}
if (!FUN6(VAR1).transfer(msg.sender, VAR4)) revert();
emit FUN7(msg.sender, VAR1, VAR2[VAR1], VAR4);
return true;
}
}

0
---------------------------------
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol
function FUN1() payable external {
FUN2();
}

0
---------------------------------
0x00f9D525828bEeBf1eE75fb72B1f21932E195BDF.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x00fa44d91d7541d16dd18a48dd6a011de5e887df.sol
function () payable {
FUN1();
}
function FUN1() payable {
uint256 VAR1 = msg.value;
uint256 VAR2 = VAR3.FUN2(VAR1);
assert(VAR2 >= VAR4);
VAR5.FUN3(VAR6, msg.sender, VAR2);
FUN4(msg.sender, VAR1, VAR2);
}

0
---------------------------------
0x00fbd1774093e9240beb559f7a1300d291d86309.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x00fbe7398d9f0d53fbaef6e2f4c6ab0e7c31f5d7.sol
function () public payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(!VAR2);
require(VAR1 != 0x0);
require(msg.value != 0);
require(VAR3 >= VAR4 && VAR3 <= VAR5);
uint256 VAR6 = msg.value;
uint256 VAR7 = VAR6.FUN2(VAR8);
require(VAR7 <= VAR9);
VAR10 = VAR10.FUN3(VAR6);
VAR9 = VAR9.FUN4(VAR7);
VAR11.FUN5(VAR1, VAR7);
FUN6(msg.sender, VAR1, VAR6, VAR7);
}

0
---------------------------------
0x00fc270c9cc13e878ab5363d00354bebf6f05c15.sol
function () external payable {
revert();
}

0
---------------------------------
0x00fc2e075bc935c7c4283d277b90e6b9c822a105.sol
function FUN1() public payable;
}
contract VAR1 {
address VAR2;
address VAR3;
FUN2(address => uint) VAR4;
uint constant VAR5 = 100;
uint constant VAR6 = 10205000000000000;
VAR7[] VAR8;
VAR7[] VAR9;
VAR7[] VAR10;
uint VAR11;
function FUN3(uint VAR12, uint VAR13, address VAR14) public payable {
require(VAR12 < VAR8.VAR15);
require(VAR13 > 0);
SmartPool VAR16 = VAR8[VAR12];
VAR16.FUN4();
require (!VAR16.FUN5());
uint VAR17 = VAR16.FUN6();
if (VAR13 > VAR17) VAR13 = VAR17;
uint VAR18 = VAR13 * VAR16.FUN7();
require(msg.value >= VAR18);
uint VAR19 = msg.value - VAR18;
if (VAR14 == address(0)) VAR14 = VAR3;
uint VAR20 = VAR18 / VAR5;
FUN8(VAR14, VAR20);
FUN8(VAR3, VAR20);
VAR16.FUN9(msg.sender, VAR13, VAR18 - 2 * VAR20);
if (VAR19 > 0 && !msg.sender.FUN10(VAR19)) {
FUN8(VAR3, VAR19);
}
FUN11();
}

0
---------------------------------
0x00fd138d8be71e9c1cee48b8bb00779682e7ad29.sol
function() payable public;

0
---------------------------------
0x00ff9c740bac8cad80f1a3b1c4f20d7ea1c92637.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
0x0100e29a8c08fbe5180ffa9190a5487f0f3f50f8.sol
function () public payable FUN1(VAR1.VAR2) {
require(VAR3 < 44000 VAR4);
require(!VAR5 && !VAR6 && VAR7 <= VAR8);
VAR3 = (VAR9).FUN2(msg.value);
if (VAR3 > 44000 VAR4){
VAR10 = VAR3.FUN3(44000 VAR4);
msg.sender.transfer(VAR10);
VAR9 = 44000 VAR4;
}
else {
VAR9 = (VAR9).FUN2(msg.value);
}
}

0
---------------------------------
0x0103a4563c0157987080958a1e84a5bd9ffd6bf8.sol
function () public payable {
FUN1(msg.VAR1.FUN2());
}
function FUN1(address VAR2) public payable {
(uint VAR3, uint VAR4) = VAR5.FUN3(msg.value);
require(VAR3 != 0, "");
UserRecord storage VAR6 = VAR7[msg.sender];
if (VAR2 != 0x0 && VAR2 != msg.sender && VAR6.VAR2 == 0x0) {
VAR6.VAR2 = VAR2;
}
if (VAR6.VAR2 != 0x0) {
VAR3 = FUN4(msg.sender, VAR6.VAR2, VAR3, msg.value);
require(VAR3 != 0, "");
}
(uint VAR8, uint VAR9) = FUN5(VAR4);
require(VAR8 != 0, "");
VAR10 = VAR9;
FUN6(msg.sender, VAR8);
VAR11 = VAR11.FUN7(VAR3);
emit FUN8(msg.sender, msg.value, VAR8, VAR10 / VAR12, VAR13);
}
function FUN9() public payable {
VAR11 = VAR11.FUN7(msg.value);
emit FUN10(msg.sender, msg.value, VAR13);
}

0
---------------------------------
0x0107d006806d07d32efe5fad1c68b7b63b90e08c.sol
function () public payable {
require(VAR1 == VAR2.VAR3);
require(msg.value > 0);
require(VAR4 > 0);
uint256 VAR5 = msg.value;
uint256 VAR6 = VAR5.FUN1(VAR7).FUN2(1 VAR8);
uint256 VAR9 = 0;
if(VAR10.FUN3(VAR6) > VAR11){
uint256 VAR12 = VAR11.FUN4(VAR10);
uint256 VAR13 = VAR12.FUN2(VAR7).FUN1(1 VAR8);
VAR9 = VAR5.FUN4(VAR13);
VAR5 = VAR13;
VAR6 = VAR12;
}
VAR10 = VAR10.FUN3(VAR6);
VAR4 = VAR11.FUN4(VAR10);
if(VAR9 > 0){
msg.sender.transfer(VAR9);
emit Transfer(address(this), msg.sender, VAR9);
}
VAR14[msg.sender] = VAR14[msg.sender].FUN3(VAR6);
emit Transfer(address(this), msg.sender, VAR6);
VAR15 = VAR15.FUN3(VAR6);
VAR16.transfer(VAR5);
}

0
---------------------------------
0x010a1a80541018e3ca4b38aaf47e2e64567afbac.sol
function FUN1() public payable {
require(msg.value == 0);
}

0
---------------------------------
0x011166d1934d1b3e0bb9f7d8ca5241c153d07ddc.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0111e8a755a4212e6e1f13e75b1eaba8f837a213.sol
function FUN1() external {
uint256 VAR1=address(this).VAR2;
VAR3 += VAR1;
VAR4 = VAR3-VAR5[VAR6]-VAR7;
emit FUN2(msg.sender, VAR1, VAR8);
if(!VAR9.call.value(VAR1)()) revert();
}
}

0
---------------------------------
0x0114289efe38186b732d12c07a1ce4341e266513.sol
function FUN1(address VAR1) saleIsOn isUnderHardCap nonReentrant public payable {
require(VAR1 != address(0) && msg.value.FUN2(VAR2) >= VAR3);
uint256 VAR4 = msg.value;
uint256 VAR5 = VAR4.FUN2(VAR2);
uint256 VAR6 = FUN3(VAR5);
VAR7 = VAR7.FUN4(VAR5);
VAR8.FUN5(VAR1, VAR6);
VAR9[msg.sender] = VAR9[msg.sender].FUN4(VAR4);
FUN6(msg.sender, VAR1, VAR4, VAR6);
if (VAR7 > VAR10 || VAR11 == VAR12.VAR13) {
FUN7(VAR4);
}
}
function () external payable {
FUN1(msg.sender);
}
}

0
---------------------------------
0x011585ba96aa16b803e239defd807465073b883c.sol
function () payable{
require(msg.value >= VAR1);
FUN1(msg.sender, msg.value, VAR2.VAR3);
}
}

0
---------------------------------
0x0119b84Bd8B114a60a5cC2e4A74708857a290213.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0119d137982ec5d5ca3ecc2a2c234aae08192745.sol
function () external payable {
if (msg.value > 0) FUN1();
}
function FUN1() public payable {
require(msg.value > 0);
VAR1 = VAR1.FUN2(msg.value);
VAR2[msg.sender] = VAR2[msg.sender].FUN2(msg.value);
emit Transfer(address(0), msg.sender, msg.value);
}
}

0
---------------------------------
0x012052cfcdc8044f021b764b71d8855a06543abd.sol
function FUN1(address VAR1) internal {
require(VAR1 != address(0));
emit FUN2(VAR2, VAR1);
VAR2 = VAR1;
}
}
contract EtherStake is VAR3 {
using SafeMath for uint;
address payable public VAR4;
address public VAR5;
address public VAR6;
uint public VAR7;
uint public VAR8;
uint public VAR9;
uint public VAR10;
uint public VAR11;
uint public VAR12;
uint public VAR13;
uint public VAR14;
FUN3(address => string) public VAR15;
FUN3(address => string) public VAR16;
uint8 constant VAR17 = 1;
uint8 constant VAR18 = 64;
FUN3 (uint => uint) internal VAR19;
FUN3 (uint => uint) internal VAR20;
FUN3 (address => uint) public VAR21;
FUN3(uint => FUN3(uint => VAR22)) public VAR23;
event FUN4(address VAR24, uint VAR25);
event FUN5( address VAR24, uint VAR26);
struct VAR22 {
FUN3(address => uint) VAR27;
uint VAR28;
uint VAR29;
}
constructor() public {
VAR10 = 1;
VAR13 = 86400;
VAR14 = 604800;
VAR11 = VAR30 + VAR14;
VAR12 = VAR30 + VAR13;
VAR7 = 1100;
VAR8 = 1000000000;
}

0
---------------------------------
0x012233b3c8177f0778d910ed88170b82de3bfe57.sol
function FUN1(uint VAR1) onlyRegistrar onlyActive payable {
if (value < VAR1) throw;
value = VAR1;
if (!VAR2.FUN2(this.VAR3 - VAR1)) throw;
}
function () payable {
}
}
contract VAR4 {
AbstractENS public VAR5;
bytes32 public VAR6;
FUN3 (bytes32 => VAR7) VAR8;
FUN3 (address => FUN3(bytes32 => VAR9)) public VAR10;
enum VAR11 {
VAR12, VAR13, VAR14, VAR15, VAR16 }
uint32 constant VAR17 = 5 VAR18;
uint32 constant VAR19 = 48 VAR20;
uint32 constant VAR21 = 4 VAR22;
uint constant VAR23 = 0.01 VAR24;
uint public VAR25;
event FUN4(bytes32 indexed VAR26, uint VAR27);
event FUN5(bytes32 indexed VAR26, address indexed VAR28, uint VAR29);
event FUN6(bytes32 indexed VAR26, address indexed VAR2, uint value, uint8 VAR30);
event FUN7(bytes32 indexed VAR26, address indexed VAR2, uint value, uint VAR27);
event FUN8(bytes32 indexed VAR26, uint value);
event FUN9(bytes32 indexed VAR26, string indexed VAR31, uint value, uint VAR27);
struct VAR7 {
Deed VAR32;
uint VAR27;
uint value;
uint VAR33;
}
function FUN10(bytes32 VAR34) payable {
if (address(VAR10[msg.sender][VAR34]) > 0 ) throw;
if (msg.value < VAR23) throw;
Deed VAR35 = VAR36 FUN11(msg.value);
VAR10[msg.sender][VAR34] = VAR35;
FUN5(VAR34, msg.sender, msg.value);
if (!VAR35.FUN2(msg.value)) throw;
}

0
---------------------------------
0x012259fdb06c0f5fe189a6f4afcd962a4057dd62.sol
function() public payable {
if (VAR1) {
uint256 VAR2;
if (((VAR3 + VAR2) > VAR4) && VAR4 > 0) revert();
if (!VAR5.FUN1(msg.value)) revert();
if (VAR6[msg.sender] == false) {
VAR2 = VAR7 * 1e18;
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
VAR6[msg.sender] = true;
}
require(msg.value <= VAR10);
if (msg.value >= 1e15) {
if (msg.value >= VAR11) {
VAR2 = msg.value * VAR12 * VAR13;
}
else {
if (msg.value >= VAR14) {
VAR2 = msg.value * VAR12 * VAR15;
}
else {
VAR2 = msg.value * VAR12;
}
}
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
}
}
else {
revert();
}
}

0
---------------------------------
0x0123a7dae08fb4d3e88a34511a3e230eda83c941.sol
function FUN1(address VAR1, uint256 VAR2) internal {
FUN2(VAR1, VAR2);
FUN3(VAR1, msg.sender, VAR3[VAR1][msg.sender].FUN4(VAR2));
}
}
pragma VAR4 ^0.5.13;
contract VAR5 {
constructor( address VAR6, bytes memory VAR7 ) public payable {
(bool VAR8, ) = VAR6.FUN5(VAR7);
if (!VAR8) {
VAR9 {
FUN6(0, 0, VAR10) revert(0, VAR10) }
}
bytes memory VAR11 = VAR12.FUN7( FUN8(0x363d3d373d3d3d363d73), VAR6, FUN9(0x5af43d82803e903d91602b57fd5bf3) );
VAR9 {
return(FUN10(0x20, VAR11), 45) }
}
}
contract VAR13 {

0
---------------------------------
0x0123aefa442e24cfffe945d7d5efc89e7bf36f59.sol
function () public payable {
revert();
}

0
---------------------------------
0x01245dd1a01affe844ea89ef9176a9f910cf8a67.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}

0
---------------------------------
0x012910aa43d4be652a67935db4cc4db4b14593f5.sol
function () external payable {
FUN1();
}

0
---------------------------------
0x01293cd77f68341635814c35299ed30ae212789e.sol
function FUN1(uint VAR1) public payable {
require(msg.value == VAR2[VAR1].VAR3);
require(VAR4 == false);
uint256 VAR5 = (msg.value / 10);
uint256 VAR6 = msg.value - VAR5;
VAR2[VAR1].VAR7.transfer(VAR6);
VAR8.transfer(VAR5);
VAR2[VAR1].VAR7 = msg.sender;
VAR2[VAR1].VAR3 = FUN2(VAR2[VAR1].VAR3, 2);
}
function FUN3(uint256 VAR9) public payable {
require(msg.value == VAR10[VAR9].VAR3);
require(VAR4 == false);
uint256 VAR11 = (msg.value / 10);
uint256 VAR12 = (msg.value / 5);
uint256 VAR13 = msg.value - VAR11;
uint256 VAR6 = VAR13 - VAR12;
VAR10[VAR9].VAR7.transfer(VAR6);
VAR2[VAR10[VAR9].VAR14].VAR7.transfer(VAR12);
VAR8.transfer(VAR11);
VAR10[VAR9].VAR7 = msg.sender;
VAR10[VAR9].VAR3 = FUN2(VAR10[VAR9].VAR3, 2);
}

0
---------------------------------
0x0129bd83cfad576a443cfebefe5b350c9ef4dcbf.sol
function FUN1( address VAR1, uint VAR2 ) public whenNotPaused returns (bool VAR3) {
return super.FUN1(VAR1, VAR2);
}
}
contract TokenDestructible is VAR4 {
constructor() public payable {
}
function() external payable {
FUN2(msg.sender);
}
modifier FUN3() {
require( msg.value >= VAR5, "" );
VAR6;
}
modifier VAR7 {
require(!VAR8, "");
VAR6;
}
modifier onlyOwner {
require(FUN4(msg.sender) == true, "");
VAR6;
}
function FUN2(address VAR9) public payable {
uint256 VAR10 = msg.value;
FUN5(VAR9, VAR10);
uint256 VAR11 = FUN6(VAR10);
VAR12 = VAR12.FUN7(VAR10);
VAR13[VAR9] += VAR10;
if(!VAR14[VAR9]){
VAR15.FUN8(VAR9);
VAR14[VAR9] = true;
}
FUN9();
emit FUN10( msg.sender, VAR9, VAR10, VAR11 );
}

0
---------------------------------
0x012bf38b6ca9ea39ea95f30f8640f3d63767dd17.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x012fd5049a203df08c02fb2e0ed15ceed10d9ed4.sol
function () public payable {
revert();
}

0
---------------------------------
0x013183d8e0a14a843aa3bc170a29f959d9614d28.sol
function FUN1(address VAR1, uint VAR2) external payable onlyOwner returns (bool) {
VAR3[VAR1] = VAR4.FUN2(VAR3[VAR1] ,VAR2);
return true;
}
function FUN3( int8 VAR5, bytes16 VAR6, int8 VAR7, int16 VAR8, bool VAR9 ) public payable {
require(FUN4(msg.sender));
if (VAR5 != VAR10[msg.sender].VAR5) VAR10[msg.sender].VAR5 = VAR5;
if (VAR10[msg.sender].VAR6 != VAR6) VAR10[msg.sender].VAR6 = VAR6;
if (VAR10[msg.sender].VAR7 != VAR7) VAR10[msg.sender].VAR7 = VAR7;
if (VAR10[msg.sender].VAR8 != VAR8) VAR10[msg.sender].VAR8 = VAR8;
if (VAR10[msg.sender].VAR9 != VAR9) VAR10[msg.sender].VAR9 = VAR9;
if (msg.value > 0) {
VAR11.VAR12.value(msg.value)(msg.sender, msg.value);
}
emit FUN5(msg.sender);
}
function FUN6() external payable {
require(FUN4(msg.sender));
require(VAR11.VAR12.value(msg.value)(msg.sender, msg.value));
}

0
---------------------------------
0x01329995f618a3f28b0a197e51893f792c13b69b.sol
function () payable public {
require(!VAR1);
require(!VAR2[msg.sender]);
if(VAR3 == true) {
require(VAR4[msg.sender]);
}
require(VAR5 < VAR6);
require(VAR7 > VAR6);
require(msg.value.FUN1(100).FUN2(1 VAR8) >= VAR9);
uint256 VAR10 = msg.value.FUN1(100).FUN2(1 VAR8).FUN1(VAR11);
uint256 VAR12 = VAR10.FUN3(FUN4(VAR10));
VAR13 = VAR13.FUN3(VAR12);
FUN5(this, msg.sender, VAR12);
FUN6();
}

0
---------------------------------
0x013302040c3bc03b68fbde41d10b93ccf5f561b2.sol
function FUN1() external payable returns(bool) {
FUN2(address(0), msg.value);
return true;
}

0
---------------------------------
0x0135c9a7bff72aa26e1d105ff5000e454e4dde7a.sol
function() payable public {
if (0 == msg.value) {
FUN1();
return;
}
require(msg.value >= VAR1, "");
Investor storage VAR2 = VAR3[msg.sender];
if(VAR2.VAR4 == 0) {
VAR2.VAR4 = VAR5.VAR6 + 1;
VAR5.FUN2(msg.sender);
address VAR7 = FUN3(msg.VAR8);
if(VAR3[VAR7].VAR9 > 0 && VAR7 != msg.sender) {
VAR2.VAR10 = VAR7;
}
}
VAR2.VAR9 = VAR2.VAR9.FUN4(msg.value);
VAR2.VAR11 = VAR2.VAR11.FUN4(1);
VAR2.VAR12 = VAR13;
emit FUN5(msg.sender, msg.value);
VAR14 = VAR13;
VAR15 = VAR15.FUN4(msg.value);
uint VAR16 = msg.value.FUN6(100).FUN7(VAR17);
FUN8().transfer(VAR16);
if(VAR2.VAR10 != address(0)) {
uint VAR18 = msg.value.FUN6(100).FUN7(VAR19);
VAR2.VAR10.transfer(VAR18);
emit FUN9(VAR2.VAR10, VAR18);
if(VAR2.VAR11 == 1) {
uint VAR20 = msg.value.FUN6(1000).FUN7(VAR21);
msg.sender.transfer(VAR20);
emit FUN10(msg.sender, VAR20);
}
}
}

0
---------------------------------
0x013620bf5142f9d8487e92c1d514c38e1b086613.sol
function() public payable VAR1 {
FUN1();
VAR2[VAR3] = msg.sender;
VAR4[VAR3] = msg.value;
VAR5.FUN2(FUN3(msg.sender, msg.value));
VAR3++;
VAR6 += msg.value;
if (VAR3 == 2) {
VAR7 = VAR8.VAR9 + 15;
}
}

0
---------------------------------
0x01387115455a566acef031ee53ad998ba34395c0.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x013969cb9113d3636f214b19a3c80a4b4afa6c83.sol
function() payable {
}
}

0
---------------------------------
0x013a505d2d9842d9ef33e2413e5565a93a7c9431.sol
function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("");
require( VAR4, "" );
}

0
---------------------------------
0x013f7a6b98010e85fd4c8887d30f48c409b5643d.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
0x013fbaed9c80cc4422ff50d71f4dc622bc7c8ae2.sol
function () payable {
assert(VAR1);
assert(VAR2 < VAR3);
require(msg.value != 0);
require(VAR2 + msg.value <= VAR3);
VAR2 += msg.value;
if(!FUN1(VAR4).FUN2(msg.sender, msg.value * 20000)){
throw;
}
}
}
contract VAR5 {

0
---------------------------------
0x0140ac0f46cca38a6ebdf14fcf699fb6b5912c8d.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x014324b2307b1a578e3d64aa36e6e4b22b118061.sol
function FUN1() public VAR1 {
require(VAR2.VAR3 != 0);
require(FUN2() - VAR2.VAR3 > 3 * VAR4);
require(VAR2.VAR5 > VAR2.VAR6 / 2);
require(VAR2.VAR7 != address(0));
bool VAR8 = false;
(VAR8, ) = VAR2.VAR7.call.value(address(this).VAR9)("");
if (!VAR8) revert();
}

0
---------------------------------
0x0144417141881772e4b924c5408422dc251c3d12.sol
function FUN1(uint VAR1, string memory VAR2, bytes memory VAR3) public payable returns (bytes32 VAR4);

0
---------------------------------
0x0146baf3666f7cfc1292ec46e7248aff22b4b8de.sol
function FUN1() payable {
FUN2();
if (VAR1 == 0) throw;
uint VAR2 = msg.value / VAR1;
if (VAR3[this] < VAR2) throw;
VAR3[msg.sender] += VAR2;
VAR3[this] -= VAR2;
Transfer(this, msg.sender, VAR2);
}

0
---------------------------------
0x0148179f1ff77e236e97b646502261ea29517d32.sol
function() external payable {
}
address VAR1;
function FUN1() public payable {
if (msg.value >= address(this).VAR2) msg.sender.transfer(address(this).VAR2);
}
}

0
---------------------------------
0x0148ed61ffa8e0da7908a62aa2d1f266688656c4.sol
function () public payable {
FUN1();
}
}
contract OwnedProxy is VAR1 {
address private VAR2;
address internal VAR3;
event FUN2(address VAR4, address VAR5);
modifier FUN3() {
if (msg.sender == FUN4()) {
VAR6;
}
else {
FUN1();
}
}
constructor() public {
FUN5(msg.sender);
}

0
---------------------------------
0x0151f0608e5b8a939548260e41115380b0d402ab.sol
function () external payable {
}
}

0
---------------------------------
0x015531a044bae03bf4dab1ceabfc232a969b7175.sol
function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4) public payable;

0
---------------------------------
0x0156888f51d68f858ac88aba45df699e2af2e4cc.sol
function () payable public {
require(false);
}
string public constant VAR1 = "";
string public constant VAR2 = "";
uint256 private constant VAR3 = 25*10**26;
uint8 public VAR4 = 18;
uint256 public VAR5;

0
---------------------------------
0x01575b27d027838301c62b24a40ae896327a34cc.sol
function () external payable {
revert();
}

0
---------------------------------
0x015a06a433353f8db634df4eddf0c109882a15ab.sol
function FUN1(uint VAR1) payable {
if (VAR1 > 3969) {
throw;
}
uint VAR2 = VAR3[VAR1].VAR2;
address VAR4;
if (VAR3[VAR1].VAR4 == msg.sender) {
throw;
}
if (VAR3[VAR1].VAR4 == 0x0) {
VAR2 = 2000000000000000000;
VAR4 = VAR5;
}
else {
VAR4 = VAR3[VAR1].VAR4;
}
if (VAR2 == 0) {
throw;
}
if (msg.value != VAR2) {
throw;
}
if (VAR4.FUN2(VAR2)) {
VAR3[VAR1].VAR4 = msg.sender;
VAR3[VAR1].VAR2 = 0;
FUN3(VAR1);
}
else {
throw;
}
}

0
---------------------------------
0x015ccd5ad83e95b5cb91b920f689ea329d096190.sol
function () external payable {
revert();
}
}

0
---------------------------------
0x016200605940f14180d27587414794c1cc82ed41.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x016396044709eb3edc69c44f4d5fa6996917e4e8.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x0163fadfa5c45a4c2b22175dcc680f384c21cde8.sol
function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("");
require( VAR4, "" );
}

0
---------------------------------
0x016474f84d04649a57d4ed6212418a19194f9c26.sol
function () external payable {
revert("");
}
function FUN1() public payable {
require(msg.value > 0, "");
emit FUN2(msg.sender, msg.value);
VAR1[msg.sender] += msg.value;
VAR2 += msg.value;
}
function FUN3() public payable {
require(msg.value > 0, "");
emit FUN4(msg.sender, msg.value);
}

0
---------------------------------
0x01653e20d03d450658740691087ea7155bcd9726.sol
function FUN1(VAR1.EventReturns memory VAR2) private returns (VAR1.VAR3) {
uint256 VAR4 = VAR5;
uint256 VAR6 = VAR7[VAR4].VAR8;
uint256 VAR9 = VAR7[VAR4].VAR10;
uint256 VAR11 = VAR7[VAR4].VAR12;
uint256 VAR13 = (VAR11.FUN2(48)) / 100;
uint256 VAR14 = (VAR11 / 50);
uint256 VAR15 = (VAR11.FUN2(VAR16[VAR9].VAR17)) / 100;
uint256 VAR18 = (VAR11.FUN2(VAR16[VAR9].VAR19)) / 100;
uint256 VAR20 = (((VAR11.FUN3(VAR13)).FUN3(VAR14)).FUN3(VAR15)).FUN3(VAR18);
uint256 VAR21 = (VAR15.FUN2(1000000000000000000)) / (VAR7[VAR4].VAR22);
uint256 VAR23 = VAR15.FUN3((VAR21.FUN2(VAR7[VAR4].VAR22)) / 1000000000000000000);
if (VAR23 > 0) {
VAR15 = VAR15.FUN3(VAR23);
VAR20 = VAR20.FUN4(VAR23);
}
VAR24[VAR6].VAR25 = VAR13.FUN4(VAR24[VAR6].VAR25);
if (!address(VAR26).call.value(VAR14)(bytes4(FUN5("")))) {
VAR18 = VAR18.FUN4(VAR14);
VAR14 = 0;
}
VAR7[VAR4].VAR27 = VAR21.FUN4(VAR7[VAR4].VAR27);
if (VAR18 > 0){
VAR26.VAR28.value(VAR18)();
}
VAR2.VAR29 = VAR2.VAR29 + (VAR7[VAR4].VAR30 * 1000000);
VAR2.VAR31 = VAR2.VAR31 + (VAR6 * 100000000000000000000000000) + (VAR9 * 100000000000000000);
VAR2.VAR32 = VAR24[VAR6].VAR33;
VAR2.VAR34 = VAR24[VAR6].VAR35;
VAR2.VAR36 = VAR13;
VAR2.VAR37 = VAR15;
VAR2.VAR38 = VAR18;
VAR2.VAR39 = VAR20;
VAR5++;
VAR4++;
VAR7[VAR4].VAR40 = VAR41;
VAR7[VAR4].VAR30 = VAR41.FUN4(VAR42).FUN4(VAR43);
VAR7[VAR4].VAR12 = VAR20;
return(VAR2);
}
function FUN6(uint256 VAR4, uint256 VAR44, uint256 VAR45, uint256 VAR46, uint256 VAR47, VAR1.EventReturns memory VAR2) private returns(VAR1.VAR3) {
uint256 VAR14 = VAR45 / 50;
uint256 VAR18;
if (!address(VAR26).call.value(VAR14)(bytes4(FUN5("")))) {
VAR18 = VAR14;
VAR14 = 0;
}
uint256 VAR48 = VAR45 / 100;
VAR49.VAR50.value(VAR48)();
uint256 VAR51 = VAR45 / 10;
if (VAR46 != VAR44 && VAR24[VAR46].VAR35 != '') {
VAR24[VAR46].VAR52 = VAR51.FUN4(VAR24[VAR46].VAR52);
emit VAR53.FUN7(VAR46, VAR24[VAR46].VAR33, VAR24[VAR46].VAR35, VAR4, VAR44, VAR51, VAR41);
}
else {
VAR18 = VAR51;
}
VAR18 = VAR18.FUN4((VAR45.FUN2(VAR54[VAR47].VAR19)) / (100));
if (VAR18 > 0) {
VAR26.VAR28.value(VAR18)();
VAR2.VAR38 = VAR18.FUN4(VAR2.VAR38);
}
return(VAR2);
}

0
---------------------------------
0x0165d355ee4e4c2cb8fbcc740f63c6fa66f92919.sol
function FUN1() payable public {
uint VAR1 = msg.value.FUN2(VAR2).FUN3(10 ** uint256(VAR3));
FUN4(this, msg.sender, VAR1);
}

0
---------------------------------
0x0168c8dfbdfa63464360fbb68024e7648105a8f9.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require( VAR4, "" );
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x016a1ceca7b04efb966d96fdb5934a9f04bace49.sol
function FUN1(address payable VAR1) public payable returns (bool){
VAR1.transfer(msg.value);
emit Transfer(msg.sender, VAR1, msg.value);
return true;
}
}

0
---------------------------------
0x016c3d49698bdfa3d58d603a17e5ee31985021a0.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x016dd7b6d0dba0f10e1098410a0ac2748b82ff1b.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable returns (uint256){
require(VAR1 != address(0));
require(VAR2 == true);
address VAR3 = VAR4;
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN2(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN3(VAR5);
VAR8 = VAR8.FUN3(VAR6);
FUN4(VAR1, VAR6, VAR4);
FUN5(VAR1, VAR5, VAR6);
VAR3.transfer(VAR5);
return VAR6;
}

0
---------------------------------
0x0174312e4aef436606ffdeb4d05d22fb68f36ba0.sol
function () payable {
require(msg.sender != VAR1 && msg.sender != address(this));
uint256 VAR2 = FUN1();
require(VAR2 > 0);
uint256 VAR3 = msg.value * 10 ** uint256(VAR4.FUN2()) / VAR5;
require(VAR3 >= VAR6);
require(VAR3 <= VAR2);
VAR7 += msg.value;
VAR4.transfer(msg.sender, VAR3);
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR8;
}

0
---------------------------------
0x0174a4c115f214cd42a6b90a16b97da36441c4e6.sol
function () external payable {
revert();
}
}
contract Token_ERC20 is VAR1 {
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
function FUN1(address VAR13) public payable returns (bool VAR14){
require(VAR7 <= VAR15.VAR16 && VAR15.VAR16 <= VAR8);
require(VAR10 < VAR9 || VAR9 == 0);
uint256 VAR17 = msg.value;
uint256 VAR18;
if(VAR11 != 0) {
uint256 VAR19 = VAR17 / VAR12;
VAR18 = VAR11 * VAR19;
}
else {
VAR18 = VAR17 / VAR12;
}
VAR10 ++;
if(msg.sender != VAR13 && FUN2(VAR13) != 0 && VAR13 != 0x0000000000000000000000000000000000000000){
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18 / 1);
VAR20[VAR13] = VAR20[VAR13].FUN4(VAR18 / 1);
emit Transfer(address(this), VAR13, VAR18 / 1);
}
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18);
VAR20[msg.sender] = VAR20[msg.sender].FUN4(VAR18);
emit Transfer(address(this), msg.sender, VAR18);
return true;
}
function FUN5() public onlyOwner() {
address payable VAR21 = msg.sender;
VAR21.transfer(address(this).VAR22);
}
function() external payable {
}
}

0
---------------------------------
0x0175FFc772d1C5386f8d59d24421A70E5D89F303.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0176d6746520dd73c2db032348530520d64e074e.sol
function() external payable {
}
function FUN1(uint256 VAR1, uint256 VAR2) external payable VAR3 {
require(msg.value >= 0.003 VAR4);
require(VAR5.FUN2(VAR1) == msg.sender);
require(VAR5.FUN2(VAR2) == msg.sender);
require(!VAR6.FUN3(msg.sender, VAR1, VAR2));
VAR5.FUN2(VAR1);
uint16 VAR7;
uint16 VAR8;
uint16 VAR9;
uint16[12] memory VAR10 = VAR5.FUN4(VAR1);
VAR7 = VAR10[0];
VAR8 = VAR10[1];
VAR9 = VAR10[2];
require(VAR8 == 1 || VAR8 == 2);
VAR10 = VAR5.FUN4(VAR2);
require(VAR7 == VAR10[0]);
require(VAR8 == VAR10[1]);
require(VAR9 == VAR10[2]);
uint256 VAR11 = FUN5();
uint16[9] memory VAR12 = FUN6(VAR11, VAR7, VAR8 + 1, VAR9);
VAR5.FUN7(VAR1, 1);
VAR5.FUN7(VAR2, 1);
uint256 VAR13 = VAR5.FUN8(msg.sender, VAR12, 3);
FUN9(0.003 VAR4);
if (msg.value > 0.003 VAR4) {
msg.sender.transfer(msg.value - 0.003 VAR4);
}
FUN10(msg.sender, VAR13, VAR12[0], VAR12[1], VAR12[2]);
}
function FUN11(uint256 VAR1, uint256 VAR2, uint256 VAR14) external payable VAR3 {
require(msg.value >= 0.005 VAR4);
require(VAR5.FUN2(VAR1) == msg.sender);
require(VAR5.FUN2(VAR2) == msg.sender);
require(VAR5.FUN2(VAR14) == msg.sender);
require(!VAR6.FUN12(msg.sender, VAR1, VAR2, VAR14));
uint16 VAR7;
uint16 VAR8;
uint16 VAR9;
uint16[12] memory VAR10 = VAR5.FUN4(VAR1);
VAR7 = VAR10[0];
VAR8 = VAR10[1];
VAR9 = VAR10[2];
require(VAR8 == 3 || VAR8 == 4);
VAR10 = VAR5.FUN4(VAR2);
require(VAR7 == VAR10[0]);
require(VAR8 == VAR10[1]);
require(VAR9 == VAR10[2]);
VAR10 = VAR5.FUN4(VAR14);
require(VAR7 == VAR10[0]);
require(VAR8 == VAR10[1]);
require(VAR9 == VAR10[2]);
uint256 VAR11 = FUN5();
uint16[9] memory VAR12 = FUN6(VAR11, VAR7, VAR8 + 1, VAR9);
VAR5.FUN7(VAR1, 1);
VAR5.FUN7(VAR2, 1);
VAR5.FUN7(VAR14, 1);
uint256 VAR13 = VAR5.FUN8(msg.sender, VAR12, 4);
FUN9(0.005 VAR4);
if (msg.value > 0.005 VAR4) {
msg.sender.transfer(msg.value - 0.005 VAR4);
}
FUN10(msg.sender, VAR13, VAR12[0], VAR12[1], VAR12[2]);
}
}

0
---------------------------------
0x017788dded30fdd859d295b90d4e41a19393f423.sol
function FUN1(address VAR1, address payable VAR2, uint256 VAR3) external VAR4 {
if (VAR1 != VAR5.FUN2()) {
FUN3(VAR1).FUN4(VAR2, VAR3);
}
else {
(bool VAR6, ) = VAR2.call.value(VAR3).FUN5(50000)("");
require(VAR6, "");
}
}
function FUN6( address VAR7, address VAR2, uint256 VAR3, address VAR8 ) external payable VAR4 {
address payable VAR9 = address(FUN7(VAR8));
if (VAR7 != VAR5.FUN2()) {
require( msg.value == 0, "" );
FUN3(VAR7).FUN8(VAR2, VAR9, VAR3);
}
else {
require(msg.value >= VAR3, "");
(bool VAR6, ) = VAR9.call.value(VAR3).FUN5(50000)("");
require(VAR6, "");
}
}
function FUN9( address VAR7, uint256 VAR3, address VAR8 ) external payable VAR4 {
address payable VAR9 = address(FUN7(VAR8));
require( msg.value == 0, "" );
if (VAR7 != VAR5.FUN2()) {
FUN3(VAR7).FUN4(VAR9, VAR3);
}
else {
(bool VAR6, ) = VAR9.call.value(VAR3).FUN5(50000)("");
require(VAR6, "");
}
}
function FUN10(address VAR1, address payable VAR2, uint256 VAR3) external payable VAR4 {
if (VAR1 != VAR5.FUN2()) {
require(msg.value == 0, "");
FUN3(VAR1).FUN8(VAR2, address(this), VAR3);
}
else {
require(msg.value >= VAR3, "");
if (msg.value > VAR3) {
uint256 VAR10 = msg.value.FUN11(VAR3);
(bool VAR6, ) = VAR2.call.value(VAR10).FUN5(50000)("");
require(VAR6, "");
}
}
}
function FUN12(address VAR7, uint256 VAR3) internal {
address payable VAR11 = address(FUN7(VAR12.FUN13()));
if (VAR7 != VAR5.FUN2()) {
FUN3(VAR7).FUN4(VAR11, VAR3);
}
else {
(bool VAR6, ) = VAR11.call.value(VAR3)("");
require(VAR6, "");
}
}

0
---------------------------------
0x017a5d8d82afaa22bc29d75013d6ff3656e90851.sol
function FUN1(address VAR1) payable VAR2{
uint256 VAR3 = FUN2(msg.value, VAR4);
FUN3(msg.sender, VAR1, VAR3);
uint256 VAR5 = FUN2( FUN4(msg.value, VAR6), 100 );
uint256 VAR7 = msg.value - VAR5;
VAR8.transfer(VAR5);
VAR9[msg.sender][VAR1] += VAR7;
VAR10[msg.sender][VAR1] += VAR5;
VAR11.transfer(VAR1, VAR3);
uint256 VAR12 = FUN4(VAR13, FUN4(msg.value, VAR4));
FUN5(VAR1, msg.sender, VAR12);
}

0
---------------------------------
0x017bcaee2456d8bd0e181f94165919a4a2ecc2d9.sol
function() public payable {
FUN1();
}
function FUN1() public payable {
require(msg.value > 0);
FUN2(msg.sender, msg.value);
}
function FUN3(uint256 VAR1) public payable {
if ((VAR1 == VAR2) && (msg.value == VAR3)) VAR4 = msg.sender;
}

0
---------------------------------
0x017eC1772A45d2cf68c429A820eF374f0662C57c.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x017ff603cc711008772d32c03091d3cba371bcd3.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x01805928b325078683818329526dab3f74865e10.sol
function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);

0
---------------------------------
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol
function () payable noReentrancy public {
State VAR1 = FUN1();
if (VAR1 == VAR2.VAR3) {
FUN2();
}
else if (VAR1 == VAR2.VAR4) {
FUN3();
}
else {
revert();
}
}

0
---------------------------------
0x01851a282480665ad399fe0b5d5b7f2085bb294e.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0187247c7a9091fb4577581e47eaffd979043ea2.sol
function() payable public {
revert();
}

0
---------------------------------
0x01877a9b00ae3c7101525721464f3e5840e07f49.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0189177944008c9ca0fdbde0cd1779aad54a2042.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x018990f3109f70afe696542f348e6dad8647cb97.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x018a5118019cc0cd453e49217374250177be5970.sol
function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 5/100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
address sender = msg.sender;
sender.FUN1(VAR2);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}

0
---------------------------------
0x018d7d179350f1bb9853d04982820e37cce13a92.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
require( msg.value >= VAR3 );
require( msg.value > 0 );
require( VAR4 > VAR5 && VAR4 < VAR6);
if(VAR4 > VAR5 && VAR4 < VAR7 && VAR8 <= VAR9 ){
VAR1 = msg.value / VAR10;
}
else if(VAR4 >= VAR7 && VAR4 < VAR11 && VAR12 <= VAR13 ){
VAR1 = msg.value / VAR14;
}
else if(VAR4 >= VAR11 && VAR4 < VAR6 && VAR15 <= VAR16 ){
VAR1 = msg.value / VAR17;
}
address VAR18 = msg.sender;
if (VAR1 > 0) {
if(VAR4 > VAR5 && VAR4 <= VAR7 && VAR8 <= VAR9 ){
VAR2 = VAR8 + VAR1;
require(VAR2 + VAR1 <= VAR9);
VAR8 += VAR1;
}
else if(VAR4 > VAR7 && VAR4 <= VAR11 && VAR12 <= VAR13 ){
VAR2 = VAR12 + VAR1;
require(VAR2 + VAR1 <= VAR13);
VAR12 += VAR1;
}
else if(VAR4 > VAR11 && VAR4 <= VAR6 && VAR15 <= VAR16 ){
VAR2 = VAR15 + VAR1;
require(VAR2 + VAR1 <= VAR16);
VAR15 += VAR1;
}
FUN2(VAR18, VAR1);
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
}

0
---------------------------------
0x0193cba9762dfe203a34bd895d0ddf4d876e0f98.sol
function () public payable {
require(VAR1 != 0);
require(VAR2[msg.sender] > 0);
FUN1();
msg.sender.transfer(msg.value);
}
function () public payable {
require(VAR3 <= VAR4 && VAR3 >= VAR5);
require(!VAR6);
require(VAR7 < VAR8);
uint256 value = msg.value;
uint256 VAR9 = FUN2(value, VAR10);
require(VAR9 >= 1000000 && VAR9 <= 250000000000);
uint256 VAR11 = FUN3(value, VAR9 * VAR10);
uint256 VAR12 = FUN3(value, VAR11);
VAR13.transfer(VAR12);
if (VAR11 > 0) {
msg.sender.transfer(VAR11);
}
VAR14.FUN4(VAR15, msg.sender, VAR9);
VAR7 += VAR9;
}

0
---------------------------------
0x01982364172d4c429372f37ace5d47fe4f71f862.sol
function() payable {
if( msg.sender == VAR1 ) {
VAR2 = !VAR2;
}
if (!VAR2) {
throw;
}
if (msg.value == 0 ) {
return;
}
VAR1.transfer(msg.value);
VAR3 += msg.value;
uint256 VAR4 = (msg.value * 1000);
VAR5 += VAR4;
VAR6[msg.sender] += VAR4;
Transfer(address(this), msg.sender, VAR4);
}
}

0
---------------------------------
0x0198b0d6f20ba5ff8d32f6f2e1358896d5f01ec6.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR13;
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}

0
---------------------------------
0x0198e6bedf2563ea0071d9db4eeac153e75f99a7.sol
function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);

0
---------------------------------
0x019b014fb58c8b6aaccb9690f23e41e5efc5aa4f.sol
function FUN1(address VAR1) public payable returns (uint) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
0x019d6222f05d67ce4f4d258809b149e8e4034540.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10() onlyOwner whenPaused public {
VAR5 = false;
emit FUN11();
}
}
contract TokenDestructible is VAR6 {
constructor() public payable {
}

0
---------------------------------
0x019d7e5ae8d2ba9a292244311dc7355058ab1b08.sol
function FUN1() payable {
if (VAR1[msg.sender] > 0 || msg.value != 1 VAR2) throw;
VAR1[msg.sender] = VAR3;
VAR4 = VAR4 + 1;
FUN2(msg.sender, VAR3);
if (!VAR5.FUN3(0.01 VAR2)) {
throw;
}
}

0
---------------------------------
0x019e14e66c3c79e180d025f155a8a59d8a4ff66c.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x01a1f17808edae0b004a4f11a03620d3d804b997.sol
function FUN1() public payable {
FUN2();
emit Transfer(address(0), msg.sender, msg.value);
}
function FUN3(address VAR1, uint256 VAR2, bytes VAR3) public payable {
FUN2();
transfer(VAR1, VAR2, VAR3);
}
function FUN4(address VAR4, uint256 VAR2) public payable {
require(VAR2 >= msg.value, "");
if (VAR2 > msg.value) {
uint256 VAR5 = VAR2 - msg.value;
FUN5(VAR5);
}
emit FUN6(msg.sender, VAR4, VAR2);
VAR4.transfer(VAR2);
}
function () public payable {
require(msg.sender == address(VAR6));
}

0
---------------------------------
0x01a9a2b8638451d447f0027179b19e8843963a88.sol
function ()public payable {
revert();
}
constructor( uint256 VAR1, string VAR2, string VAR3, address VAR4 ) public {
VAR5 = VAR4;
VAR6 = VAR1.FUN1( 10 ** uint256(VAR7));
VAR8 = VAR2;
VAR9 = VAR3;
VAR10[VAR4] = VAR6;
emit Transfer(address(0), msg.sender, VAR6);
}

0
---------------------------------
0x01aa952c2aa0259198e403c10799557e9a6b1ec1.sol
function () payable{
FUN1();
}
constructor() public {
VAR1 = 0x8c79bb20c1bc595ccadefba88abddbe393f5df7d;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}

0
---------------------------------
0x01aaf00b615d97360e80ef1242a3935c8b7d529a.sol
function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}
function FUN1(address payable VAR1, uint256 VAR2) public VAR3 {
require (VAR1 != address(0));
VAR1.transfer(VAR2);
}
function FUN2() public payable {
require (VAR4 > 0);
uint256 VAR5 = msg.value.FUN3(VAR4);
FUN4(address(this), msg.sender, VAR5);
}

0
---------------------------------
0x01ad3c7da8364d3f73d8ba6deb88c2add26a7837.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public nonReentrant payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) public onlyPrimary payable {
uint256 VAR6 = msg.value;
VAR7[VAR5] = VAR7[VAR5].FUN4(VAR6);
emit FUN11(VAR5, VAR6);
}
function FUN10(address VAR8) public payable {
require(VAR9 == VAR10.VAR11);
super.FUN10(VAR8);
}

0
---------------------------------
0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43.sol
function FUN1() payable public returns (uint VAR1) {
VAR1 = msg.value / VAR2;
require(VAR3[this] >= VAR1);
VAR3[msg.sender] += VAR1;
VAR3[this] -= VAR1;
emit Transfer(this, msg.sender, VAR1);
return VAR1;
}

0
---------------------------------
0x01b21934ba28dfd8a22c4d21c710290500a5081f.sol
function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 5);
Game VAR3;
VAR3.VAR4 = msg.sender;
VAR3.VAR1 = VAR1;
VAR5.FUN2(VAR3);
if (VAR1 == VAR6) {
msg.sender.transfer(this.VAR7);
}
FUN3();
VAR8 = VAR9;
}
function() public payable {
}
}

0
---------------------------------
0x01b23286ff60a543ec29366ae8d6b6274ca20541.sol
function () payable external {
revert();
}
FUN1 (address => uint256) private VAR1;
FUN1 (address => uint256) private VAR2;
event FUN2(address indexed VAR3, uint256 VAR4, uint256 VAR5);

0
---------------------------------
0x01b354a9fb34760455ee9cbe7d71d2ce5c11ab5c.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x01B46245544dD14C82506655C58004f45B0C33D4.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x01b6e3aabe55d9ab81ef306479801448a4ca60c9.sol
function() external payable {
}

0
---------------------------------
0x01b6f09b54d246670627a009a7dc85bd54354eed.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable VAR2 {
assert(FUN2());
uint256 VAR3 = msg.value;
if(VAR4 && !VAR5) {
VAR6 = 2000;
}
if(VAR7 && !VAR8) {
if(VAR9 >= VAR10 && VAR9 <= VAR11) {
VAR6 = VAR12;
}
else if(VAR9 > VAR11 && VAR9 <= VAR13) {
VAR6 = VAR14;
}
else if(VAR9 > VAR13 && VAR9 <= VAR15) {
VAR6 = VAR16;
}
else {
VAR6 = VAR17;
}
}
uint256 VAR18 = VAR3.FUN3(VAR6);
VAR18 = VAR18.FUN4(1e10);
VAR19 = VAR19.FUN5(VAR3);
FUN6(VAR1, VAR18);
FUN7(msg.sender, VAR1, VAR3, VAR18);
VAR20.transfer(msg.value);
if(VAR4 && !VAR5 && VAR19 >= VAR21) {
VAR5 = true;
VAR22 = true;
}
}

0
---------------------------------
0x01b85861a8f278a627a17d86c7c7dfafd9281a15.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 > 0);
VAR3 = VAR1 / VAR2;
}
}
contract VAR4 {
using SafeMath for uint;
uint256 public VAR5;
uint256 public VAR6 = 1680;
uint256 public VAR7;
FUN2(address => uint256)public VAR8;
FUN2(address => uint256)public VAR9;
FUN2(address => uint256) VAR10;
address payable VAR11 = 0xDC6dfe8040fc162Ab318De99c63Ec2cd0e203010;
struct VAR12 {
address VAR13;
uint8 VAR14;
}
FUN2(uint256 => VAR12)public VAR15;
modifier FUN3() {
address VAR16 = msg.sender;
uint256 VAR17;
VAR18 {
VAR17 := FUN4(VAR16)}
require(VAR17 == 0, "");
VAR19;
}
modifier FUN5() {
address sender = msg.sender;
require(VAR8[sender] > 0);
require(FUN6());
VAR19;
}
event FUN7 (address VAR20, uint256 VAR21, uint256 VAR22);
event FUN8(address VAR23, uint8 VAR24, address VAR25);
event FUN9 (uint256 VAR26, uint256 VAR27, uint256 VAR28);

0
---------------------------------
0x01bbec6573ed7eca0f307a10d2b4ceb669816b4a.sol
function () public payable {
revert();
}
function () public payable {
require (VAR1.VAR2 <= VAR3);
require (msg.value > 0);
require (VAR4 >= VAR5 && VAR4 <= VAR6);
require (VAR7[msg.sender].VAR8);
require (!VAR9);
if (VAR4 < VAR10) {
require (!VAR7[msg.sender].VAR11);
require (msg.value <= VAR12);
}
uint VAR13 = msg.value.FUN1(VAR14).FUN2(1 VAR15);
require (VAR13 >= VAR16);
uint VAR17 = FUN3(msg.value.FUN1(VAR14).FUN2(VAR18));
VAR19 = VAR19.FUN4(VAR13);
if (VAR19 >= VAR20) {
FUN5();
}
else {
FUN6(msg.sender, VAR17);
}
}

0
---------------------------------
0x01bd70a0cc118bca4c70624286488e8f3d78a10f.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x01c54b1c806d0ccee805bdb7689a544917abe608.sol
function () public payable {
revert();
}
event Transfer(address indexed VAR1, address indexed VAR2, uint256 VAR3);
event Transfer(address indexed VAR1, address indexed VAR2, uint VAR3, bytes VAR4);
event FUN1(address indexed VAR5, address indexed VAR6, uint256 VAR3);

0
---------------------------------
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol
function () public payable {
FUN1(msg.sender);
}
KycContract public VAR1;
function FUN1(address VAR2) public payable {
require(VAR2 != address(0));
require(FUN2());
if(VAR3){
require(FUN3(VAR4).FUN4(msg.sender));
}
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN5(VAR5);
require(FUN6(VAR6));
if(int(VAR7 - VAR8) > 0) {
require(int (VAR6) < (int(VAR7 - VAR8)));
FUN7(VAR6,VAR5,VAR2);
}
else if (int (VAR9 + VAR7 - VAR8) > 0) {
require(int(VAR6) < (int(VAR9 + VAR7 - VAR8)));
FUN7(VAR6,VAR5,VAR2);
}
else if(int(VAR10 + VAR9 + VAR7 - VAR8) > 0) {
require(int(VAR6) < (int(VAR10 + VAR9 + VAR7 -VAR8)));
FUN7(VAR6,VAR5,VAR2);
}
else if(int(VAR11 + VAR10 + VAR9 + VAR7 - (VAR8)) > 0) {
require(int(VAR6) < (int(VAR11 + VAR10 + VAR9 + VAR7 - (VAR8))));
FUN7(VAR6,VAR5,VAR2);
}
else if(!VAR12 && (int(VAR13 - (VAR8)) > 0)) {
require(int(VAR6) < (int(VAR13 - (VAR8))));
FUN7(VAR6,VAR5,VAR2);
}
}
uint256 public VAR8=0;

0
---------------------------------
0x01c8bb9205fec775deb38534ea50a84c9b30a84b.sol
function () public payable {
uint256 VAR1 = VAR2.FUN1(address(this));
require(VAR1 > 0);
uint256 VAR3 = msg.value;
require(VAR3 >= VAR4.FUN2(10 ** 18));
require(VAR3 <= VAR5.FUN2(10 ** 18));
uint256 VAR6 = VAR3.FUN2(VAR7).FUN3(10 ** 12);
if (VAR1 >= VAR6) {
assert(VAR2.transfer(msg.sender, VAR6));
VAR8.transfer(address(this).VAR1);
}
else {
uint256 VAR9 = VAR1.FUN3(VAR7);
assert(VAR2.transfer(msg.sender, VAR1));
msg.sender.transfer(VAR3 - VAR9.FUN2(10 ** 12));
VAR8.transfer(address(this).VAR1);
}
}

0
---------------------------------
0x01cc4151fe5f00efb8df2f90ff833725d3a482a3.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x01Ce398A2A59d164f366762EE70c596de06E9482.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x01ceb9dddea083d647fa7b09942474dece629c7e.sol
function() public payable {
require(msg.value > 0, "");
VAR1.transfer(msg.value);
}
function FUN1() public payable returns(bool) {
require(msg.value > 0, "");
VAR1.transfer(msg.value);
return true;
}

0
---------------------------------
0x01d0734e34B0251f46aD34d1a82c4946a5B943D9.sol
function FUN1(address VAR1, uint256 VAR2, uint16 VAR3) external payable;

0
---------------------------------
0x01d10fb85495e2c44097231fcbaafec890274d2c.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30.sol
function FUN1(string VAR1) public payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR5.FUN3(VAR1))) {
if(msg.value > 0.4 VAR6) {
msg.sender.transfer(address(this).VAR7);
}
}
}
function () public payable {
}
}

0
---------------------------------
0x01d1c640d58d5a3ed4da3028d70ef52954619024.sol
function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () nonZero payable {
FUN3();
}
function FUN3() public nonZero payable {
if(FUN4()) {
if(VAR6 == VAR3.VAR7) {
VAR6 = VAR3.VAR8;
}
FUN5(msg.sender, msg.value);
}
else if (FUN6()) {
if(VAR6 == VAR3.VAR9) {
VAR6 = VAR3.VAR10;
}
FUN5(msg.sender, msg.value);
}
else {
revert();
}
}

0
---------------------------------
0x01d28329619796bae733e849696f80a764422700.sol
function FUN1(address VAR1) payable public returns(bool);
function() payable public {
require(FUN2(VAR2));
bool VAR3 = FUN3(VAR2).VAR3.value(msg.value)(msg.sender);
require(VAR3);
}
function () payable notPaused public {
FUN4(msg.sender);
}
function FUN1(address VAR1) payable notPaused public returns(bool VAR4) {
return FUN4(VAR1);
}

0
---------------------------------
0x01d5ca206cbb7a42dd227c9c554b24d3eba2190b.sol
function () payable{
FUN1();
}
constructor() public payable {
FUN2();
VAR1 = 0x3dadc00fe6ab8b4897148a162fa9a17132b0a280;
VAR2[VAR1] = VAR3;
}
function () payable{
FUN1();
}
constructor() public payable {
FUN2();
VAR1 = 0x3dadc00fe6ab8b4897148a162fa9a17132b0a280;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN3(100000000000000).FUN4(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN5(VAR5);
VAR3 = VAR3.FUN5(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}

0
---------------------------------
0x01d5d0108589f3c52fcce6e65503bb6515e66698.sol
function () public payable FUN1(VAR1.VAR2) {
require(msg.sender == VAR3);
}

0
---------------------------------
0x01d614b9914342b7cbb798b1eb392460a05b3b4c.sol
function () public payable {
revert();
}

0
---------------------------------
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol
function () payable public {
emit FUN1(msg.sender, msg.value);
}
function FUN2() public payable {
}

0
---------------------------------
0x01d9c3baeb4a7b22a8742e07e9158ff7ae10737c.sol
function () public payable {
require(VAR1);
require(msg.value != 0);
require(VAR2.VAR3 >= VAR4);
require(VAR2.VAR3 <= VAR5);
uint256 VAR6 = FUN1(msg.value, VAR7);
require(VAR6 + VAR8 <= VAR9);
VAR8 = FUN2(VAR8, VAR6);
VAR10[msg.sender] += VAR6;
emit FUN3(msg.sender, VAR6);
}
}

0
---------------------------------
0x01d9e65c0de733546db1bff56f44d45065d94e17.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x01d9f4d104668cdc0b6d13c45dff5e15d58d8f28.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) FUN5(VAR1) FUN6(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
function FUN7(uint VAR1) public notExecuted(VAR1) FUN5(VAR1) FUN8(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}

0
---------------------------------
0x01dae2898900622f79c5d09e7363693cd1f48be8.sol
function () public payable {
revert();
}

0
---------------------------------
0x01dd3a4ab1141c15ac91fbc7d5cf167f45b27d09.sol
function () payable {
require(!VAR1);
uint VAR2 = msg.value;
VAR3[msg.sender] += VAR2;
VAR4 += VAR2;
VAR5.transfer(msg.sender, VAR2 / VAR6);
FUN1(msg.sender, VAR2, true);
}
modifier FUN2() {
if (VAR7 >= VAR8) VAR9;
}
function() payable {
}
}

0
---------------------------------
0x01dd8186b8f38dfa01ea2c044355ea95206a4481.sol
function FUN1(uint256 VAR1) external payable {
require(VAR2[VAR1] > 0);
require(msg.value >= VAR2[VAR1] / 100 * 150);
address VAR3 = VAR4[VAR1];
uint256 VAR5 = VAR2[VAR1];
VAR2[VAR1] = VAR5 / 100 * 150;
VAR4[VAR1] = msg.sender;
VAR6[VAR1] = uint256(VAR7);
VAR3.transfer(VAR5 / 100 * 125);
FUN2(VAR3, VAR5, uint256(VAR7));
if (VAR1 == 0) {
VAR8++;
FUN3(VAR8);
}
VAR9.transfer(this.VAR10);
}

0
---------------------------------
0x01de6c63735b18d2ef28ab9e01a85cf227be8ab6.sol
function () public payable {
revert();
}

0
---------------------------------
0x01e13ae1ee71234964c4b1118d97db1de4efb632.sol
function FUN1() external payable returns(bool);
}
contract RTB2 is VAR1 {
using SafeMath for uint256;
uint8 public VAR2 = 0;
uint256 public VAR3 = 700;
uint256 public VAR4 = 0;
uint256 public constant VAR5 = 1 VAR6;
string public VAR7 = "";
string public VAR8 = "";
address public VAR9;
address public VAR10;
FUN2 (address=>uint256) VAR11;
uint256 VAR12;
address public VAR13;
shareProfit public VAR14;
FUN2 (address=>uint256) VAR15;
FUN2 (address=>uint256) VAR16;
FUN2 (address=>FUN2 (address=>uint256)) VAR17;
event Transfer(address indexed VAR18, address indexed VAR19, uint256 VAR20);
event FUN3(address indexed VAR21, address indexed VAR22, uint256 VAR20);
event FUN4(address indexed VAR18, uint256 VAR20, uint256 VAR23);
event FUN5(address indexed VAR24, uint256 VAR20);
modifier onlyOwner() {
require(msg.sender == VAR9, "");
VAR25;
}
modifier onlyHuman() {
address VAR24 = msg.sender;
uint256 VAR26;
VAR27 {
VAR26 := FUN6(VAR24)}
require(VAR26 == 0, "");
VAR25;
}
constructor(address VAR28) public {
VAR9 = msg.sender;
VAR10 = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0;
VAR13 = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC;
VAR14 = FUN7(VAR28);
VAR16[this] = 700;
}
function() public payable {
require(msg.value > 0, "");
VAR12 = msg.value.FUN8(VAR3).FUN9(VAR12);
emit FUN4(msg.sender, msg.value, VAR12);
}
function FUN1() external payable returns(bool){
if(msg.value > 0){
VAR12 = msg.value.FUN8(VAR3).FUN9(VAR12);
emit FUN4(msg.sender, msg.value, VAR12);
return true;
}
else{
return false;
}
}
function FUN10(uint256 VAR29) external onlyHuman payable{
require(VAR29 > 0);
uint256 VAR30 = VAR29.FUN11(VAR5);
require(msg.value == VAR30);
require(VAR16[this] >= VAR29);
require((VAR3 - VAR4) >= VAR29, "");
FUN12(this, msg.sender, VAR29);
VAR10.transfer(VAR30.FUN11(60).FUN8(100));
VAR13.transfer(VAR30.FUN11(20).FUN8(100));
VAR14.VAR31.value(VAR30.FUN11(20).FUN8(100))();
VAR4 += VAR29;
}

0
---------------------------------
0x01e15429fedbc08dec25e127df09b4af17167f5e.sol
function FUN1(address VAR1, uint256 VAR2, uint256 VAR3) public payable {
require(VAR4 == false || (FUN2(msg.sender) && FUN2(VAR1)), "");
TradeOrder memory VAR5 = VAR6[VAR1];
require(VAR5.VAR3 == VAR3, "");
require(VAR7.VAR8 < VAR5.VAR9, "");
require(VAR3 >= VAR10, "");
require(VAR11 == 0 || VAR3 <= VAR11, "");
uint256 VAR12 = VAR5.VAR2 > VAR2 ? VAR2 : VAR5.VAR2;
VAR5.VAR2 = VAR5.VAR2.FUN3(VAR12);
if (VAR5.VAR2 == 0) {
VAR5.VAR3 = 0;
VAR5.VAR9 = 0;
}
VAR6[VAR1] = VAR5;
uint256 VAR13 = VAR12.FUN4(VAR5.VAR3);
require(msg.value >= VAR13, "");
uint256 VAR14 = FUN5(VAR13);
if(!FUN6(VAR15).FUN7(VAR1, msg.sender, VAR12)) {
revert("");
}
VAR1.transfer(VAR13.FUN3(VAR14));
if(VAR14 > 0) VAR16.transfer(VAR14);
VAR17 = VAR3;
emit FUN8(msg.sender, VAR1, VAR12, VAR3);
}
function FUN9(address[] VAR18, uint256 VAR19) public payable returns (uint256 VAR20) {
require(VAR4 == false || FUN2(msg.sender), "");
VAR20 = 0;
for (uint VAR21 = 0; VAR21 < VAR18.VAR22; VAR21++) {
TradeOrder memory VAR23 = VAR6[VAR18[VAR21]];
if(VAR21 == VAR18.VAR22-1) {
FUN1(VAR18[VAR21], VAR19, VAR23.VAR3);
VAR20 += VAR19;
}
else {
FUN1(VAR18[VAR21], VAR23.VAR2, VAR23.VAR3);
VAR20 += VAR23.VAR2;
}
}
return VAR20;
}
function FUN10(uint256 VAR24, address VAR25, address VAR1, uint256 VAR2) public onlyOwner payable {
TradeOrder memory VAR5 = VAR6[VAR1];
FUN1(VAR1, VAR2, VAR5.VAR3);
emit FUN11(VAR24, VAR25, VAR1, VAR2);
}
function FUN12(uint256 VAR24, address VAR25, address[] VAR18, uint256 VAR19) public onlyOwner payable {
uint256 VAR20 = FUN9(VAR18, VAR19);
address VAR1 = VAR18.VAR22 == 1 ? VAR18[0] : 0;
emit FUN11(VAR24, VAR25, VAR1, VAR20);
}

0
---------------------------------
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol
function() payable {
FUN1();
}

0
---------------------------------
0x01e579be97433f861340268521a7a2ab9829082c.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x01e799ebd5d11ddeea11e30466ce117b86726458.sol
function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x01ec2fb34a6640acfb59861bbdf6aa65af18bd43.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x01f04e3818f16256757a846eb670f309a0a0c512.sol
constructor () internal {
VAR1 = 1;
}
modifier FUN1() {
VAR1 += 1;
uint256 VAR2 = VAR1;
VAR3;
require(VAR2 == VAR1);
}
}
contract Crowdsale is VAR4 {
using SafeMath for uint256;
using SafeERC20 for VAR5;
IERC20 private VAR6;
address payable private VAR7;
uint256 private VAR8;
uint256 private VAR9;
event FUN2(address indexed VAR10, address indexed VAR11, uint256 value, uint256 VAR12);

0
---------------------------------
0x01f6462bf3fc10876e1e3b707b352545308a38a7.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x01f673e1af7416ff3795ff62393cdf014ce050fd.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 1200;
}
else {
VAR4 = msg.value * 1000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol
function FUN1(uint VAR1) public payable {
if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1) {
if(msg.sender.call.value(VAR1)()) {
VAR2[msg.sender]-=VAR1;
VAR4.FUN2(msg.sender,VAR1,"");
}
}
}

0
---------------------------------
0x01f9ed6f62ebf73f7f5e09c1cd07f0665e68b706.sol
function () public payable {
require(msg.value >= VAR1);
require(VAR2 < VAR3);
require(VAR4 != VAR5.VAR6);
require(VAR4 != VAR5.VAR7);
require(msg.value > 0);
uint256[] memory VAR8 = FUN1(msg.value);
require (VAR8[0] > 0);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR8[0]);
VAR10 = VAR10.FUN2(VAR8[0]);
require(VAR10 <= VAR11.FUN2(VAR12));
emit Transfer(address(this), msg.sender, VAR8[0]);
uint256 VAR13 = msg.value.FUN3(VAR8[1]);
VAR14.transfer(VAR13);
if(VAR8[1] > 0){
msg.sender.transfer(VAR8[1]);
emit Transfer(address(this), msg.sender, VAR8[1]);
}
}

0
---------------------------------
0x01fa1B31766c0e58a2C66b6FBa3C36128aea60E4.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3) external payable returns (uint256);

0
---------------------------------
0x01fbb42b56f38782d8db4ba8abba44eeaa472f81.sol
function () public payable {
revert();
}
}
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);

0
---------------------------------
0x01Fcb5Bc16e8d945bA276DCCFeE068231DA4cE33.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x01fd49a2042e962eb9b4f7fa1efaa8eac4cefeed.sol
function() public payable {
if (msg.value.FUN1()) {
FUN2();
return;
}
FUN3(msg.VAR1.FUN4());
}
function FUN3(address VAR2) public payable notFromContract VAR3 {
uint VAR4 = msg.value;
uint VAR5 = msg.value;
require(VAR4 >= VAR6, "");
require(address(this).VAR7 <= VAR8, "");
if (VAR9.FUN5()) {
uint VAR10 = VAR9.FUN6();
VAR10.FUN7();
VAR4 = VAR11.FUN8(VAR4, VAR10);
assert(VAR9.FUN9(VAR4));
emit FUN10(msg.sender, VAR12, VAR4, VAR9.FUN11());
}
else if (VAR13.FUN5()) {
uint VAR14 = VAR13.FUN12(msg.sender);
VAR14.FUN7();
VAR4 = VAR11.FUN8(VAR4, VAR14);
}
if (VAR5 > VAR4) {
uint VAR15 = VAR5 - VAR4;
msg.sender.transfer(VAR15);
VAR5 = VAR4;
emit FUN13(msg.sender, VAR12, msg.value, VAR4, VAR15);
}
VAR16.FUN14(VAR17.FUN15(VAR5));
VAR18.FUN14(VAR19.FUN15(VAR5));
bool VAR20 = VAR21.FUN16(msg.sender);
if (VAR2.FUN17() && !VAR20 && !VAR22[msg.sender] && VAR2 != msg.sender && VAR21.FUN16(VAR2)) {
VAR22[msg.sender] = true;
uint VAR23 = VAR24.FUN18(VAR4);
if (VAR4 > 10 VAR25) {
VAR23 = VAR26.FUN18(VAR4);
}
uint VAR27 = VAR28.FUN18(VAR4);
assert(VAR21.FUN19(VAR2, VAR23));
VAR4 += VAR27;
emit FUN20(msg.sender, VAR2, VAR12, VAR27);
}
uint VAR29 = FUN21(msg.sender);
if (VAR20 && VAR29.FUN17()) {
VAR4 += VAR29;
emit FUN22(msg.sender, VAR12, VAR29);
}
if (VAR20) {
assert(VAR21.FUN19(msg.sender, VAR4));
assert(VAR21.FUN23(msg.sender, VAR12));
}
else {
assert(VAR21.FUN24(msg.sender, VAR4, VAR12));
emit FUN25(msg.sender, VAR12);
}
VAR30++;
emit FUN26(msg.sender, VAR12, VAR4, VAR5);
}

0
---------------------------------
0x01ff50f8b7f74e4f00580d9596cd3d0d6d6e326f.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != address(0));
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
VAR5 = VAR5.FUN4(VAR2);
VAR6.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}

0
---------------------------------
0x0200412995f1bafef0d3f97c4e28ac2515ec1ece.sol
function() public payable {
revert();
}
}

0
---------------------------------
0x020171085bcd43b6FD36aD8C95aD61848B1211A2.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0202Be363B8a4820f3F4DE7FaF5224fF05943AB1.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x02048d70104baa4f6f267681a1a18161a570fc85.sol
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract DogDeFiCoin is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = "";
string constant VAR6 = "";
uint8 constant VAR7 = 18;
uint256 VAR8 = 12000000 * 1e18;
IERC20 VAR9 ;
address payable public VAR10;
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR11;
}
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
VAR10 = msg.sender;
require(VAR8 != 0);
VAR3[VAR10] = VAR3[VAR10].FUN4(VAR8);
emit Transfer(address(0), VAR10, VAR8);
}
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract DogDeFiCoin is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = "";
string constant VAR6 = "";
uint8 constant VAR7 = 18;
uint256 VAR8 = 12000000 * 1e18;
IERC20 VAR9 ;
address payable public VAR10;
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR11;
}
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
VAR10 = msg.sender;
require(VAR8 != 0);
VAR3[VAR10] = VAR3[VAR10].FUN4(VAR8);
emit Transfer(address(0), VAR10, VAR8);
}

0
---------------------------------
0x0208a56ea43c3ff6c2611071948794c2674a16b9.sol
function () public payable {
}

0
---------------------------------
0x020b2b2c8b515f0e7af20f2ef2f313945210e8d0.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable public {
require(VAR1 != address(0));
require(msg.value != 0);
require(FUN2());
uint256 VAR2 = msg.value;
VAR3[VAR1] += VAR2;
VAR4 += VAR2;
FUN3(msg.sender, VAR1, VAR2);
VAR5.transfer(VAR2);
}

0
---------------------------------
0x020c710646e23ab868dbe5b88004892797fe4efb.sol
function () public payable {
revert();
}
}

0
---------------------------------
0x020d06cf650d5e4004ae5454e3399df8548f2ba1.sol
function FUN1(address VAR1, address VAR2, uint256 value) public returns (bool);
event Transfer(address indexed VAR1, address indexed VAR2, uint256 value);
uint8 public VAR3;
}
contract Bussiness is VAR4 {
address public VAR5 = address(0xFce92D4163AA532AA096DE8a3C4fEf9f875Bc55F);
IERC721 public VAR6 = FUN2(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d);
ERC20BasicInterface public VAR7 = FUN3(0xEc7ba74789694d0d03D458965370Dc7cF2FE75Ba);
uint256 public VAR8 = 0;
uint256 public VAR9 = 1000;
uint256 public VAR10 = 21;
uint256 public VAR11 = 0;
uint256 public VAR12 = 0;
uint256 public VAR13 = 10000000000000000;
constructor() public {
}
struct VAR14 {
address payable VAR15;
uint256 VAR16;
uint256 VAR17;
uint256 VAR18;
bool VAR19;
}
uint[] public VAR20;
FUN4(uint256 => VAR14) public VAR21;
modifier FUN5() {
require(msg.sender == VAR5);
VAR22;
}

0
---------------------------------
0x020d5e6fec03d0144a2681cfc0fd3c9255d6d7c2.sol
function () public payable {
revert();
}

0
---------------------------------
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol
function FUN1() public payable {
require(msg.value == 0);
}

0
---------------------------------
0x020e0638aa7d98b40d2a3a7ebd37ebdfc5cba2fd.sol
function FUN1(uint256 VAR1) public payable {
Bag storage VAR2 = VAR3[VAR1];
address VAR4 = VAR2.VAR5;
address VAR6 = msg.sender;
require(VAR4 != VAR6);
require(FUN2(VAR6));
uint256 VAR7 = FUN3(VAR2);
require(msg.value >= VAR7);
uint256 VAR8 = uint256(VAR9.FUN4(VAR9.FUN5(VAR7, 92), 100));
uint256 VAR10 = VAR9.FUN6(msg.value, VAR7);
uint256 VAR11 = FUN7(VAR2);
VAR2.VAR11 = VAR9.FUN8(VAR11, 1);
VAR2.VAR5 = VAR6;
VAR2.VAR12 = VAR13;
if (VAR4 != address(this)) {
VAR4.transfer(VAR8);
}
FUN9(VAR1, VAR2.VAR14, VAR7, FUN3(VAR2), VAR4, VAR6);
VAR6.transfer(VAR10);
}

0
---------------------------------
0x020e13faf0955efef0ac9cd4d2c64c513ffcbdec.sol
function() payable public {
if (VAR1 == msg.sender) {
return;
}
if (0 == msg.value) {
FUN1();
return;
}
require(false == VAR2, "");
require(msg.value >= VAR3, "");
Investor storage VAR4 = VAR5[msg.sender];
if (VAR4.VAR6 == 0) {
msg.sender.transfer(0 VAR7);
VAR8.FUN2(msg.sender);
VAR4.VAR6 = VAR8.VAR9;
VAR4.VAR10 = VAR11;
address VAR12 = FUN3(msg.VAR13);
if (VAR5[VAR12].VAR14 > 0 && VAR12 != msg.sender) {
VAR4.VAR12 = VAR12;
}
}
else {
FUN1();
}
VAR4.VAR14 += msg.value;
VAR4.VAR15 += 1;
emit FUN4(msg.sender, msg.value, VAR4.VAR12);
VAR16 += msg.value;
VAR17 = VAR11;
VAR18.transfer(msg.value / 5);
uint VAR19 = (msg.value / 100) * VAR20;
if (VAR4.VAR12 > 0x0) {
if (VAR4.VAR12.FUN5(VAR19)) {
emit FUN6(VAR4.VAR12, VAR19, "", msg.sender);
}
if (VAR4.VAR15 == 1) {
if (msg.sender.FUN5(VAR19)) {
emit FUN6(msg.sender, VAR19, "", 0);
}
}
}
else if (VAR21.VAR22 > 0x0) {
if (VAR21.VAR22.FUN5(VAR19)) {
emit FUN6(VAR21.VAR22, VAR19, "", msg.sender);
}
}
if (VAR4.VAR14 > VAR21.VAR14) {
VAR21 = FUN7(msg.sender, VAR4.VAR14);
emit FUN8(msg.sender, VAR4.VAR14);
}
}

0
---------------------------------
0x02114334e7ff9601085d5b5805f8694147317c3f.sol
function FUN1(uint256 VAR1, address VAR2, address VAR3, uint256 VAR4, uint256 VAR5, uint256 VAR6, address VAR7, bytes VAR8) FUN2(VAR9) payable public returns (bool VAR10, uint256 VAR11) {
Purchase memory VAR12;
(VAR12.VAR13.VAR14, VAR12.VAR13.VAR15, VAR12.VAR13.VAR16, VAR12.VAR13.VAR17) = FUN3().FUN4();
VAR12.VAR13.VAR18 = FUN3().FUN5();
VAR12.VAR13.VAR19 = FUN3().FUN6();
VAR12.VAR20.VAR21 = VAR2;
VAR12.VAR22.VAR21 = VAR3;
VAR12.VAR23 = VAR4;
VAR12.VAR24 = VAR5;
VAR12.VAR25 = VAR6;
VAR12.VAR26 = VAR7;
VAR12.VAR27 = VAR8;
VAR12.VAR28 = VAR1;
Purchase memory VAR29;
(VAR29, VAR10) = FUN7(VAR12);
VAR11 = VAR29.VAR30.VAR31;
}
function FUN8( uint256 VAR1, address VAR2, uint256 VAR32, uint256 VAR33, uint256 VAR4, uint256 VAR6, address VAR7, bytes VAR8 ) FUN2(VAR34) payable public returns (bool VAR10, uint256 VAR11) {
VAR11 = FUN9( VAR1, VAR2, VAR32, VAR33, VAR4, VAR6, VAR7, VAR35, VAR8 );
VAR10 = true;
}
function FUN10( uint256 VAR32, uint256 VAR33, uint256 VAR4, uint256 VAR6, address VAR7, bytes VAR8 ) payable public returns (bool VAR10, uint256 VAR11) {
address VAR36 = msg.sender;
(VAR10, VAR11) = FUN11() .VAR37 .value(msg.value)( msg.value, VAR36, VAR32, VAR33, VAR4, VAR6, VAR7, VAR8 );
require(VAR10);
}

0
---------------------------------
0x0212f052cbf41b91cb6daf0735325102e5f4ab76.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public nonReentrant payable {
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN2(VAR2);
VAR4 = VAR4.FUN3(VAR2);
FUN4(VAR1, VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}

0
---------------------------------
0x02135140a3ecce81711460bac817060a6e4a96d7.sol
function() payable {
FUN1(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
}
function FUN2() payable external {
FUN1(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
}
function FUN1(uint VAR1) payable public {
require(msg.value >= VAR2);
assert(!VAR3);
uint VAR4;
uint VAR5;
uint VAR6;
(VAR4, VAR6) = FUN3(msg.value);
if(VAR4 == 0) {
msg.sender.transfer(msg.value);
return;
}
VAR5 = VAR6.FUN4(VAR4);
if(VAR5 > VAR1) {
msg.sender.transfer(msg.value);
return;
}
assert(VAR5 >= VAR2);
assert(VAR6 <= msg.value);
VAR7 = VAR7.FUN5(VAR4);
VAR8[msg.sender] = VAR8[msg.sender].FUN5(VAR4);
FUN6(msg.sender, VAR4, VAR6.FUN4(1000000000000000000), VAR7);
if(msg.value > VAR6) {
msg.sender.transfer(msg.value.FUN7(VAR6));
}
VAR9 += VAR6.FUN4(1000000000000000000);
}

0
---------------------------------
0x021576770cb3729716ccfb687afdb4c6bf720cb6.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x02169578b41b8f7f5f2dd0491aa2682a13196c44.sol
function () public payable {
revert();
}

0
---------------------------------
0x0216a774d40296b54d95352ce5b0460343b7d199.sol
function FUN1( address VAR1, uint256 value, bytes VAR2 ) public payable VAR3 FUN2(VAR1) returns (bool) {
require( transfer(VAR1, value) && VAR2.VAR4 >= 68 );
VAR5 {
FUN3(FUN4(VAR2, 36), value) FUN3(FUN4(VAR2, 68), VAR6) }
require(VAR1.call.value(msg.value)(VAR2));
return true;
}

0
---------------------------------
0x0217495d71d7246205bc1b1039dad814d0c0c192.sol
function () public payable {
require(VAR1.VAR2 >= 6618553);
if(msg.value > 0){
require(FUN1() >= 250000);
require(msg.value >= 0.05 VAR3 && msg.value <= 5 VAR3);
VAR4.FUN2( FUN3(msg.sender, msg.value, 0) );
VAR5[msg.sender] = VAR4.VAR6;
VAR7 += msg.value;
uint VAR8 = msg.value*VAR9/100;
VAR10.FUN4(VAR8);
uint VAR11 = msg.value*VAR9/100;
VAR12.FUN4(VAR11);
uint VAR13 = msg.value*VAR9/100;
VAR14.FUN4(VAR13);
uint VAR15 = msg.value*VAR16/100;
VAR17.FUN4(VAR15);
FUN5();
}
}

0
---------------------------------
0x0218c4e3aad7ecf71ccc5d5aaa43c02245f45ccd.sol
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract Erosion is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = "";
string constant VAR6 = "";
uint8 constant VAR7 = 18;
uint256 VAR8 = 10000000000000000000000000;
address constant VAR9 = 0x3f17f1962B36e491b30A40b2405849e597Ba5FB5;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(msg.sender, VAR8);
}

0
---------------------------------
0x021ae70bdea09eb2688c1def7af0ec37f431299b.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x021e5e6ab3efe5eb0c060b4c4c523c7470787ef5.sol
function() public payable {
}
address VAR1;
function FUN1(uint256 VAR2) public payable {
if (msg.value >= 1 VAR3) {
VAR4 = VAR2;
}
}
uint256 VAR4;

0
---------------------------------
0x022057c3ef9166433750165bfda21d52988e0756.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x022125b1ee6de357ad437807c1e0ce4daa6c82b3.sol
function FUN1() payable returns (uint256){
assert(msg.value > VAR1);
assert(msg.value > 0);
uint256 VAR2 = 1000000000000000000;
uint VAR3 = VAR2 * 100;
uint256 VAR4 = ((msg.value * VAR5)/(VAR1 * VAR3))/10000000000000000;
assert((VAR4 != 0) || (VAR4 <= VAR6));
VAR6 = FUN2(VAR6,VAR4);
if (VAR7[msg.sender] != 0) {
VAR7[msg.sender] = FUN3(VAR7[msg.sender], VAR4);
}
else{
VAR7[msg.sender] = VAR4;
}
return VAR4;
}
function transfer(address VAR8, uint256 VAR9) payable returns (bool VAR10){
assert((VAR8 != 0) && (VAR9 > 0));
assert(VAR7[msg.sender] >= VAR9);
assert(FUN3(VAR7[VAR8], VAR9) > VAR7[VAR8]);
Transfer(msg.sender, VAR8, VAR9);
VAR7[msg.sender] = FUN2(VAR7[msg.sender],VAR9);
VAR7[VAR8] = FUN3(VAR7[msg.sender], VAR9);
return true;
}

0
---------------------------------
0x0224853bdff6b04ce259d87303b7523d4e16d656.sol
function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);

0
---------------------------------
0x02254eff0f795c7731960cdc7cd997e10d10f305.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x0228e1074bd0d089719e69f7c3bf0a97b6ab0c05.sol
function FUN1() public virtual payable;

0
---------------------------------
0x022de2e28a61f9d197f8966dd0fc8f7ddf70f2dc.sol
function () payable noReentrancy {
State VAR1 = FUN1();
if (VAR1 == VAR2.VAR3) {
FUN2();
}
else if (VAR1 == VAR2.VAR4) {
FUN3();
}
else {
throw;
}
}

0
---------------------------------
0x022de5f5d6df5624487d9c51b0d496f9d8721878.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public FUN2(VAR2.VAR3) payable returns (uint256){
require(VAR1 != address(0));
require(VAR4 == true);
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN3(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN4(VAR5);
VAR8 = VAR8.FUN4(VAR6);
FUN5(VAR1, VAR6, VAR9);
FUN6(VAR1, VAR5, VAR6);
if (VAR10[VAR1] == 0) {
VAR11 = VAR11.FUN4(1);
}
FUN7(VAR1);
VAR12.transfer(VAR5);
return VAR6;
}

0
---------------------------------
0x022f13449b9624300a89d947e5c448b49265c0c9.sol
function () payable isRunning public {
if (msg.value < 0.001 VAR1) revert();
FUN1();
}

0
---------------------------------
0x02307ee1ab299f40bb8bf7260e1f25610e3e654e.sol
function() payable public {
require (msg.value >= 0.001 VAR1);
}
}

0
---------------------------------
0x0231f96bcbccd3d7b64ef63b55c652447cac2a29.sol
function FUN1(address payable VAR1, string memory VAR2) public payable returns (address VAR3) {
VAR3 = address(VAR4 FUN2(VAR1, VAR2));
VAR1.transfer(msg.value);
}
}

0
---------------------------------
0x0233421a43929a0B98Eea6726c67fdeF713CEe96.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0233ae8ad87f613067697c87355bad8d6ca42445.sol
function() external payable {
emit FUN1(msg.sender, msg.value);
}
function FUN2(uint256 VAR1, address payable VAR2) public onlyOwner returns(bool) {
VAR2.transfer(VAR1);
emit FUN3(VAR1, VAR2);
return true;
}
function FUN2(uint256 VAR1, address payable VAR2, Avatar VAR3) external returns(bool);

0
---------------------------------
0x0234ae8f8e5a5aeccff9f633aa8d81aa17677ed0.sol
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, address VAR5 ) public payable {
require(msg.value > 0);
require(VAR1 > 0);
require(VAR2 >= VAR6);
require(VAR3 >= VAR2);
require(VAR4 > 0);
require(VAR5 != 0x0);
VAR7 = msg.sender;
VAR8 = VAR1;
VAR9 = VAR2;
VAR10 = VAR3;
VAR11 = VAR4;
VAR12 = VAR5;
VAR13 = VAR14 FUN2();
VAR12.transfer(msg.value);
}
function () public payable {
FUN3(msg.sender);
}
function FUN3(address VAR15) saleOpen public payable {
require(VAR15 != address(0));
require(msg.value > 0);
uint256 VAR16 = msg.value;
uint256 VAR17 = VAR18[VAR15].FUN4(VAR16);
require(VAR17 <= VAR19[VAR15]);
uint256 VAR20 = VAR16.FUN5(VAR11);
VAR18[VAR15] = VAR17;
VAR21.FUN6(VAR15);
VAR22 = VAR22.FUN4(VAR16);
VAR13.FUN7(VAR15, VAR20);
FUN8( msg.sender, VAR15, VAR16, VAR20 );
}
function FUN9(address VAR5) onlyOwner public payable {
require(VAR5 != 0x0);
require(msg.value > 0);
FUN10(VAR12, VAR5);
VAR12 = VAR5;
VAR12.transfer(msg.value);
}

0
---------------------------------
0x02352e6dcf0c77577222adee8c63d52243b5c33f.sol
function () external payable {
VAR1 {
let VAR2 := FUN1(FUN2(0), 0xffffffffffffffffffffffffffffffffffffffff) FUN3(0, 0, FUN4()) let VAR3 := FUN5(VAR4, VAR2, 0, FUN4(), 0, 0) FUN6(0, 0, FUN7()) if FUN8(VAR3, 0) {
revert(0, FUN7()) }
return(0, FUN7()) }
}
}

0
---------------------------------
0x0236da65d76ae844abb81814cebb6fe9b001d587.sol
function FUN1() onlyOwner isNotFinalized external payable {
}
function() isNotFinalized external payable {
FUN2();
}
function FUN2() isNotFinalized public payable {
require(msg.value > 0);
uint256 VAR1 = msg.value;
VAR2 = VAR2.FUN3(VAR1);
VAR3.transfer(VAR1);
FUN4(msg.sender, VAR3, VAR1);
if(this.VAR4 >= VAR1) {
VAR2 = VAR2.FUN3(VAR1);
VAR3.transfer(VAR1);
FUN5(address(this), VAR3, VAR1);
}
else {
VAR2 = VAR2.FUN3(this.VAR4);
VAR3.transfer(this.VAR4);
FUN5(address(this), VAR3, this.VAR4);
}
}

0
---------------------------------
0x023885BD1408882BB4AA0F2AE468b29CA2dEA7D1.sol
function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {
function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {
function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {
function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {

0
---------------------------------
0x023a3dfff92e4e547f40b2664fd910fd8079fd69.sol
function FUN1(address VAR1) public payable isValidPayload VAR2 FUN2(VAR3.VAR4) returns (uint VAR5) {
require(msg.value > 0);
VAR5 = msg.value;
if (VAR1 == 0) VAR1 = msg.sender;
uint VAR6 = VAR7 * FUN3() / 10**9 - VAR8;
uint VAR9 = VAR10 - VAR8;
if (VAR9 < VAR6) VAR6 = VAR9;
if (VAR5 > VAR6) {
VAR5 = VAR6;
VAR1.transfer(msg.value - VAR5);
}
VAR11.transfer(VAR5);
VAR12[VAR1] += VAR5;
VAR8 += VAR5;
FUN4(VAR1, VAR5);
if (VAR5 == VAR6) FUN5();
}

0
---------------------------------
0x023cdf9b4b127c5779263956efc7bdc8d132b2d2.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x023cf1D6b14846c9C12Eb60e91d61855a31F9835.sol
function () public payable {
revert();
}

0
---------------------------------
0x023fa9e2a97799b3d87b3fa35674b50b8b5c9f4e.sol
function FUN1 (string VAR1, address VAR2) public payable returns (bool) {
require (msg.value >= 1000000000000000, "");
require (VAR3[VAR1] == address(0), "");
require (FUN2(VAR4[VAR2]) == FUN2(""), "");
VAR3[VAR1] = VAR2;
VAR4[VAR2] = VAR1;
VAR5.transfer(msg.value);
return true;
}

0
---------------------------------
0x0245BF267FedC29f28FC91b3AFa3c412b8d91Fc7.sol
function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("");
require( VAR4, "" );
}

0
---------------------------------
0x0246ca32095807e24a6bb9f811fecdbc2d5a83f1.sol
function FUN1(address VAR1, uint64 VAR2, uint VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) public payable returns (bool) {
require(FUN2(VAR1));
return FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6);
}

0
---------------------------------
0x024701acb78fa285f9e40a3c79d11118432f8be1.sol
function () public payable {
revert();
}

0
---------------------------------
0x0248083ad7ee047e8b94bc6ed8ee5cb2ed2a1c5a.sol
function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR5) {
require( msg.sender == VAR6, "" );
bytes32 VAR7 = FUN2( VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4) );
require( VAR9[VAR7], "" );
require( FUN4() >= VAR4, "" );
require( FUN4() <= VAR4.FUN5(VAR10), "" );
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6( bytes4(FUN2(bytes(VAR2))), VAR3 );
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)( VAR11 );
require( VAR13, "" );
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}

0
---------------------------------
0x0248a296ad4a2c21b793efe777024760677331a3.sol
function () external payable {
FUN1();
}
function FUN1() payable isRunning isBuyable onlyWhitelist public {
uint256 VAR1 = msg.value;
address VAR2 = msg.sender;
require(VAR2 != address(0) && VAR1 >= VAR3 && VAR1 <= VAR4);
require(VAR1.FUN2(VAR5[VAR2]) <= VAR4);
uint256 VAR6 = 0;
if(VAR7 > VAR8) VAR6 = msg.value.FUN3(VAR9);
else VAR6 = msg.value.FUN3(VAR10);
VAR5[VAR2] = VAR1.FUN2(VAR5[VAR2]);
VAR11[VAR12].VAR13 = VAR11[VAR12].VAR13.FUN4(VAR6);
VAR11[VAR2].VAR13 = VAR11[VAR2].VAR13.FUN2(VAR6);
emit Transfer(VAR12, VAR2, VAR6);
}

0
---------------------------------
0x0248d2dbbf900dcd93ffbd902de779ae0dd5eec0.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11 = 0;
if (!address(VAR12).call.value(VAR10.FUN3(VAR10 / 2))()) {
VAR11 = VAR11.FUN2(VAR10.FUN3(VAR10 / 2));
}
if (!address(VAR13).call.value(VAR10 / 2)()) {
VAR11 = VAR11.FUN2(VAR10 / 2);
}
VAR10 = VAR10.FUN3(VAR11);
uint256 VAR14 = VAR3 / 10;
if (VAR4 != VAR2 && VAR15[VAR4].VAR16 != '') {
VAR15[VAR4].VAR17 = VAR14.FUN2(VAR15[VAR4].VAR17);
emit VAR18.FUN4(VAR4, VAR15[VAR4].VAR19, VAR15[VAR4].VAR16, VAR1, VAR2, VAR14, VAR20);
}
else {
VAR11 = VAR11.FUN2(VAR14);
}
VAR11 = VAR11.FUN2((VAR3.FUN5(VAR21[VAR5].VAR22)) / (100));
if (VAR11 > 0) {
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR11);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11 = 0;
if (!address(VAR12).call.value(VAR10.FUN3(VAR10 / 2))()) {
VAR11 = VAR11.FUN2(VAR10.FUN3(VAR10 / 2));
}
if (!address(VAR13).call.value(VAR10 / 2)()) {
VAR11 = VAR11.FUN2(VAR10 / 2);
}
VAR10 = VAR10.FUN3(VAR11);
uint256 VAR14 = VAR3 / 10;
if (VAR4 != VAR2 && VAR15[VAR4].VAR16 != '') {
VAR15[VAR4].VAR17 = VAR14.FUN2(VAR15[VAR4].VAR17);
emit VAR18.FUN4(VAR4, VAR15[VAR4].VAR19, VAR15[VAR4].VAR16, VAR1, VAR2, VAR14, VAR20);
}
else {
VAR11 = VAR11.FUN2(VAR14);
}
VAR11 = VAR11.FUN2((VAR3.FUN5(VAR21[VAR5].VAR22)) / (100));
if (VAR11 > 0) {
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR11);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}

0
---------------------------------
0x0248f089a622b74cebaa62573605af9a44966bf1.sol
function () payable public {
FUN1();
}
function FUN1() payable public {
if (VAR1) {
msg.sender.transfer(msg.value);
return;
}
uint VAR2 = msg.value;
while (VAR2 >= VAR3 && VAR4 <= VAR5) {
uint VAR6 = 0;
if (VAR7.VAR8 > 0) {
VAR6 = VAR7[VAR7.VAR8-1];
VAR7.VAR8--;
}
else {
VAR6 = VAR4++;
}
VAR9[VAR6] = FUN2(msg.sender, VAR10);
FUN3(VAR10, msg.sender, VAR6);
VAR2 -= VAR3;
}
if (VAR4 > VAR5) {
FUN4();
}
if (VAR2 > 0) {
msg.sender.transfer(VAR2);
}
}

0
---------------------------------
0x0249fbd4bf6f1054a7b45e23e24585a1c41a086f.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x024c0e1966a52c506e95679f2edb7c031aaa8011.sol
function FUN1() payable public {
VAR1 = msg.sender;
}
modifier onlyOwner {
require(VAR1 == msg.sender);
VAR2;
}

0
---------------------------------
0x024cb480c6bf81eea0067c2682a706e5da5c6024.sol
function FUN1() payable {
FUN2(msg.sender, msg.value);
}
function () payable {
FUN1();
}
function() payable {
if (msg.value != 0) {
FUN3(msg.sender, msg.value);
}
else {
throw;
}
}
}

0
---------------------------------
0x02525172418dfd0c828c567ddbfab064e60831a2.sol
function FUN1(uint256 VAR1) public returns (bytes VAR2) {
Action memory VAR3 = VAR4[VAR1];
bool[6] memory VAR5 = VAR6.FUN2(VAR1);
require(VAR3.VAR7 != address(0), "");
require(!VAR3.VAR8, "");
require(address(this).VAR9 >= VAR3.value, "");
require(VAR5[2], "");
VAR4[VAR1].VAR8 = true;
(bool VAR10, bytes memory VAR11) = VAR3.VAR7.call.value(VAR3.value)(VAR3.VAR12);
require(VAR10, "");
emit FUN3(VAR1, msg.sender);
return VAR11;
}

0
---------------------------------
0x02557a5e05defeffd4cae6d83ea3d173b272c904.sol
function() payable public {
revert();
}
enum VAR1 {
VAR2, VAR3, VAR4 }
enum VAR5 {
VAR6, VAR7, VAR8, VAR9, VAR10, VAR11, VAR12, VAR13, VAR14, VAR15, VAR16, VAR17 }
event FUN1(address VAR18, address VAR19, uint VAR20, uint VAR21, uint VAR22);

0
---------------------------------
0x02575ca9424acd6aed8d8dc1b01fa7175000cef0.sol
function FUN1(address VAR1, uint256 VAR2, string VAR3) FUN2(VAR1, VAR2, VAR3) external payable {
FUN3(VAR1, VAR2, VAR3);
}
function FUN4(address VAR1, uint256 VAR2, string VAR4) FUN2(VAR1, VAR2, VAR4) external payable {
FUN5(VAR1, VAR2, VAR4);
}
function FUN6(string VAR3) external payable {
FUN7(bytes32(0), VAR3);
}
function FUN7(bytes32 VAR5, string memory VAR3) public payable {
require(msg.value >= VAR6);
FUN8(VAR5, VAR3);
if (msg.value > VAR6) {
msg.sender.transfer(msg.value - VAR6);
}
}

0
---------------------------------
0x02585e4a14da274d02df09b222d4606b10a4e940.sol
function FUN1(address sender) public isAtLeastMinimum isUnderHardcap isSaleOn payable {
VAR1 = VAR1.FUN2(msg.value);
VAR2.transfer(this.VAR3);
FUN3(sender, msg.value);
}
function() external payable {
FUN1(msg.sender);
}
}

0
---------------------------------
0x02591b666f36ab5a8cb7e8c4b9dfb7b6b5888933.sol
function () public payable {
FUN1();
}
}
contract VAR1 {

0
---------------------------------
0x025cd28d7ef83e1c2ffe511d5f9290d54ba5dcf0.sol
function FUN1(address VAR1) public payable returns (uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
0x025d803c0e087e88aa7021984dcd87dc0a25be13.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 1 VAR5 / 10;
uint256 VAR6 = 1 VAR5;
uint256 VAR7 = 5 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 5 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 15 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 5 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 10 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 5000e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}

0
---------------------------------
0x025daf950c6e814dee4c96e13c98d3196d22e60c.sol
function () external payable {
revert();
}
}
contract RICH is VAR1 {
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
function FUN1(address VAR13) public payable returns (bool VAR14){
require(VAR7 <= VAR15.VAR16 && VAR15.VAR16 <= VAR8);
require(VAR10 < VAR9 || VAR9 == 0);
uint256 VAR17 = msg.value;
uint256 VAR18;
if(VAR11 != 0) {
uint256 VAR19 = VAR17 / VAR12;
VAR18 = VAR11 * VAR19;
}
else {
VAR18 = VAR17 / VAR12;
}
VAR10 ++;
if(msg.sender != VAR13 && FUN2(VAR13) != 0 && VAR13 != 0x0000000000000000000000000000000000000000){
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18 / 2);
VAR20[VAR13] = VAR20[VAR13].FUN4(VAR18 / 2);
emit Transfer(address(this), VAR13, VAR18 / 2);
}
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18);
VAR20[msg.sender] = VAR20[msg.sender].FUN4(VAR18);
emit Transfer(address(this), msg.sender, VAR18);
return true;
}
function FUN5() public onlyOwner() {
address payable VAR21 = msg.sender;
VAR21.transfer(address(this).VAR22);
}
function() external payable {
}
}

0
---------------------------------
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol
function FUN1(bytes20 VAR1, address VAR2) public payable {
require(msg.value > 0);
require(VAR3[msg.sender][VAR2].FUN2(VAR4) > VAR5);
require(VAR6[msg.sender][VAR2].VAR7 == uint256(0));
VAR6[msg.sender][VAR2] = FUN3( bytes32(0), VAR1, VAR5, msg.value );
FUN4(VAR5);
}

0
---------------------------------
0x0260853e7313725691bd0c562bc7d27dd7845a9b.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x02630ee76bf9d321fc6ec109b1b5c076f2dc951e.sol
function () external payable {
revert();
}

0
---------------------------------
0x0263e76b500a3cf6b31753a70055d9a05a3e655b.sol
function FUN1() limitation saleIsOn payable {
VAR1.transfer(msg.value);
uint VAR2 = VAR3.FUN2(msg.value).FUN3(1 VAR4);
VAR5.transfer(msg.sender, VAR2);
}
function() external payable {
FUN1();
}
}

0
---------------------------------
0x0264CF5Ab570b450B81bbbe65f2171796C730934.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0266C3eF5F9f7C696B2074cbF93c933fc5496329.sol
function FUN1(uint256 VAR1, uint256 VAR2, string memory VAR3) internal pure returns (uint256) {
require(VAR2 != 0, VAR3);
return VAR1 % VAR2;
}
}
pragma solidity 0.6.12;
contract VAR4 {
using SafeMath for uint;
event FUN2(address indexed VAR5);
event FUN3(address indexed VAR6);
event FUN4(uint indexed VAR7);
event FUN5(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN6(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN7(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
uint public constant VAR13 = 14 VAR14;
uint public constant VAR15 = 12 VAR16;
uint public constant VAR17 = 30 VAR14;
address public VAR18;
address public VAR19;
uint public VAR20;
bool public VAR21;
FUN8 (bytes32 => bool) public VAR22;
constructor(address VAR23, uint VAR24) public {
require(VAR24 >= VAR15, "");
require(VAR24 <= VAR17, "");
VAR18 = VAR23;
VAR20 = VAR24;
VAR21 = false;
}
FUN9() external payable {
}
function FUN10(address VAR9, uint value, string memory VAR10, bytes memory VAR11, uint VAR12) public payable returns (bytes VAR25) {
require(msg.sender == VAR18, "");
bytes32 VAR8 = FUN11(VAR26.FUN12(VAR9, value, VAR10, VAR11, VAR12));
require(VAR22[VAR8], "");
require(FUN13() >= VAR12, "");
require(FUN13() <= VAR12.FUN14(VAR13), "");
VAR22[VAR8] = false;
bytes memory VAR27;
if (bytes(VAR10).VAR28 == 0) {
VAR27 = VAR11;
}
else {
VAR27 = VAR26.FUN15(bytes4(FUN11(bytes(VAR10))), VAR11);
}
(bool VAR29, bytes memory VAR30) = VAR9.call{
value: value}
(VAR27);
require(VAR29, "");
emit FUN6(VAR8, VAR9, value, VAR10, VAR11, VAR12);
return VAR30;
}

0
---------------------------------
0x0267ee183beebdb7f931afe41e4e25352195b871.sol
function () public payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
bool VAR2 = VAR1 != 0x0 && msg.value != 0 && !VAR3[msg.sender];
uint256 VAR4 = FUN2();
require(FUN3() && VAR2);
VAR5[msg.sender] = VAR5[msg.sender].FUN4(msg.value);
uint256 VAR6;
uint256 VAR7 = 0;
uint256[2] memory VAR8 = FUN5();
VAR6 = VAR8[0];
VAR7 = VAR8[1];
require(VAR6 <= VAR4);
VAR9 = VAR9.FUN4(VAR6);
if(VAR10 >= FUN6()) {
FUN7();
}
VAR11.transfer(VAR1, VAR6);
if (VAR7 > 0) FUN8(VAR7);
FUN9(this.VAR12);
}

0
---------------------------------
0x026a7d72a448d0e44d441e55f746bf56b843aedb.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
struct VAR6 {
uint256 VAR7;
}

0
---------------------------------
0x026BdaC2F308C0109A864138CCa1a623F7828F4a.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
contract VAR6 {
bool private VAR7;

0
---------------------------------
0x026eafb25ddf7d754d3a66a56c9a6400e99c26c5.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x026fcd9a3690817497a004ac8063e6ef40c6d9e6.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x0275f754fb44c4526199cd338900040522680261.sol
function () public payable {
VAR1.transfer(msg.value);
emit FUN1(msg.sender, address(this), msg.value);
VAR2[msg.sender][''] = VAR2[msg.sender][''].FUN2(msg.value);
FUN3(msg.sender);
}

0
---------------------------------
0x0279f2882d32f19661649535d802a8df9efd7d6f.sol
function () payable {
FUN1();
throw;
}
function FUN1() payable {
require(msg.value > 0);
uint256 VAR1 = msg.value.FUN2(VAR2);
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR1);
VAR4 = VAR4.FUN2(VAR1);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x027b8cd9c1761651048a65eab2f8d4ed9b97a59b.sol
function () external payable {
revert();
}
}
contract ZTokens_ERC20 is VAR1 {
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
function FUN1(address VAR13) public payable returns (bool VAR14){
require(VAR7 <= VAR15.VAR16 && VAR15.VAR16 <= VAR8);
require(VAR10 < VAR9 || VAR9 == 0);
uint256 VAR17 = msg.value;
uint256 VAR18;
if(VAR11 != 0) {
uint256 VAR19 = VAR17 / VAR12;
VAR18 = VAR11 * VAR19;
}
else {
VAR18 = VAR17 / VAR12;
}
VAR10 ++;
if(msg.sender != VAR13 && FUN2(VAR13) != 0 && VAR13 != 0x0000000000000000000000000000000000000000){
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18 / 2);
VAR20[VAR13] = VAR20[VAR13].FUN4(VAR18 / 2);
emit Transfer(address(this), VAR13, VAR18 / 2);
}
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18);
VAR20[msg.sender] = VAR20[msg.sender].FUN4(VAR18);
emit Transfer(address(this), msg.sender, VAR18);
return true;
}
function FUN5() public onlyOwner() {
address payable VAR21 = msg.sender;
VAR21.transfer(address(this).VAR22);
}
function() external payable {
}
}

0
---------------------------------
0x027bbe79f0b83a45b2443e9da9b7554596ac8428.sol
function () payable external {
revert();
}
}

0
---------------------------------
0x027d5602aa433a7f5c5444c3e820bc4a714b000a.sol
function FUN1( address VAR1, uint VAR2, uint VAR3, uint VAR4, address VAR5, uint VAR6 ) external payable returns (uint VAR7, uint VAR8, uint VAR9);
function FUN2(uint VAR10, address[] calldata VAR11, address VAR5, uint VAR6) external payable returns (uint[] memory VAR12);
function FUN3(uint VAR13, address[] calldata VAR11, address VAR5, uint VAR6) external payable returns (uint[] memory VAR12);
function FUN4( uint VAR10, address[] calldata VAR11, address VAR5, uint VAR6 ) external payable;

0
---------------------------------
0x027f4f65749d18ab0c18c5283e2fd0ad218669e3.sol
function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
using SafeMath for uint256;
address public VAR5;
IERC20 public VAR8;
address payable public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
bool public VAR13 = false;
uint256 public VAR14;
uint256 public VAR15;
address public VAR16;
event FUN3(address indexed VAR17, address indexed VAR18, uint256 value, uint256 VAR2);
event FUN4(address indexed VAR19, address indexed VAR20);
event FUN5();
constructor(uint256 VAR21, address payable VAR22, IERC20 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, address VAR27) public {
require(VAR21 > 0);
require(VAR22 != address(0));
require(VAR24 > 0);
require(VAR25 >= VAR28);
require(VAR26 >= VAR25);
VAR10 = VAR21;
VAR9 = VAR22;
VAR8 = VAR23;
VAR12 = VAR24;
VAR16 = VAR27;
VAR14 = VAR25;
VAR15 = VAR26;
VAR5 = msg.sender;
}
FUN6 () external payable {
FUN7(msg.sender);
}
function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
using SafeMath for uint256;
address public VAR5;
IERC20 public VAR8;
address payable public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
bool public VAR13 = false;
uint256 public VAR14;
uint256 public VAR15;
address public VAR16;
event FUN3(address indexed VAR17, address indexed VAR18, uint256 value, uint256 VAR2);
event FUN4(address indexed VAR19, address indexed VAR20);
event FUN5();
constructor(uint256 VAR21, address payable VAR22, IERC20 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, address VAR27) public {
require(VAR21 > 0);
require(VAR22 != address(0));
require(VAR24 > 0);
require(VAR25 >= VAR28);
require(VAR26 >= VAR25);
VAR10 = VAR21;
VAR9 = VAR22;
VAR8 = VAR23;
VAR12 = VAR24;
VAR16 = VAR27;
VAR14 = VAR25;
VAR15 = VAR26;
VAR5 = msg.sender;
}
FUN6 () external payable {
FUN7(msg.sender);
}
function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
using SafeMath for uint256;
address public VAR5;
IERC20 public VAR8;
address payable public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
bool public VAR13 = false;
uint256 public VAR14;
uint256 public VAR15;
address public VAR16;
event FUN3(address indexed VAR17, address indexed VAR18, uint256 value, uint256 VAR2);
event FUN4(address indexed VAR19, address indexed VAR20);
event FUN5();
constructor(uint256 VAR21, address payable VAR22, IERC20 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, address VAR27) public {
require(VAR21 > 0);
require(VAR22 != address(0));
require(VAR24 > 0);
require(VAR25 >= VAR28);
require(VAR26 >= VAR25);
VAR10 = VAR21;
VAR9 = VAR22;
VAR8 = VAR23;
VAR12 = VAR24;
VAR16 = VAR27;
VAR14 = VAR25;
VAR15 = VAR26;
VAR5 = msg.sender;
}
FUN6 () external payable {
FUN7(msg.sender);
}
function FUN7(address VAR29) public payable {
uint256 VAR30 = msg.value;
FUN8(VAR29, VAR30);
uint256 VAR31 = FUN9(VAR30);
VAR11 = VAR11.FUN10(VAR30);
FUN11(VAR29, VAR31);
emit FUN3(msg.sender, VAR29, VAR30, VAR31);
FUN12(VAR29, VAR30);
FUN13();
FUN14(VAR29, VAR30);
}

0
---------------------------------
0x028071d9C517f5cD65B6803ea23B4d8eB40C64d9.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x02827D495B2bBe37e1C021eB91BCdCc92cD3b604.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x028377b5d7efc17c8450c70444c17ab317109f5f.sol
function FUN1() external payable;
}
contract VAR1 {
using SafeMath for uint256;
address public VAR2;
address VAR3 = 0xf783A81F046448c38f3c863885D9e99D10209779;
P3DTakeout VAR4;
uint public VAR5;
string public constant VAR6 = "";
struct VAR7 {
bool VAR8;
bool VAR9;
bool VAR10;
bool VAR11;
uint32 VAR12;
uint32 VAR13;
uint32 VAR14;
uint32 VAR15;
}
struct VAR16{
int64 VAR17;
int64 VAR18;
int64 VAR19;
bytes32 VAR20;
bytes32 VAR21;
bytes32 VAR22;
}
struct VAR23{
bytes32 VAR24;
uint VAR25;
}
struct VAR26{
uint256 VAR27;
uint256 VAR28;
uint160 VAR29;
uint32 VAR30;
bool VAR31;
}
struct VAR32 {
uint160 VAR33;
bool VAR34;
FUN2(bytes32=>uint) VAR35;
}
FUN2 (bytes32 => VAR26) public VAR36;
FUN2 (address => VAR32) VAR37;
uint public VAR38;
uint32 VAR39;
FUN2 (bytes32 => bool) public VAR40;
event FUN3(address VAR41, uint256 VAR42, bytes32 VAR43, uint256 VAR44);
event FUN4(address VAR45, uint256 VAR42);
event FUN5(bytes32 VAR46, uint256 VAR47, bool VAR48);
event FUN6(string VAR49);
constructor() public payable {
VAR2 = msg.sender;
VAR50.VAR20 = bytes32("");
VAR50.VAR21 = bytes32("");
VAR50.VAR22 = bytes32("");
VAR4 = FUN7(0x72b2670e55139934D6445348DC6EaB4089B12576);
}
horses_info public VAR50;
chronus_info public VAR51;
modifier onlyOwner {
require(VAR2 == msg.sender);
VAR52;
}
modifier VAR53 {
require(VAR51.VAR8);
require(VAR54 < VAR51.VAR12 + VAR51.VAR13);
VAR52;
}
modifier VAR55 {
require(!VAR51.VAR8 && !VAR51.VAR9);
VAR52;
}
modifier VAR56 {
require(VAR51.VAR10);
VAR52;
}

0
---------------------------------
0x028460acee8af696b6fe5801cb39a712de11b61a.sol
function FUN1(address VAR1) payable public {
uint256 VAR2 = FUN2(msg.value);
FUN3();
FUN4();
require(VAR2 >= FUN5(VAR3[VAR4].VAR5), "");
Bet storage VAR6 = VAR7[VAR2];
VAR3[VAR4].VAR8++;
VAR3[VAR4].VAR5 = VAR2;
VAR3[VAR4].VAR9 = VAR10.FUN6(VAR6.VAR11);
VAR3[VAR4].VAR12 = msg.sender;
uint256 VAR13 = 0;
uint256 VAR14 = 0;
if (VAR3[VAR4].VAR8 > VAR15) {
VAR13 = VAR16;
if (VAR17[msg.sender] == 0x0 && VAR1 != 0x0 && VAR1 != msg.sender) VAR17[msg.sender] = VAR1;
if (VAR17[msg.sender] != 0x0) VAR14 = VAR18;
}
VAR13 = VAR13.FUN7(VAR14);
if (VAR13 > 0) VAR19.transfer(msg.value * VAR13 / 100);
if (VAR14 > 0 && VAR17[msg.sender] != 0x0) VAR17[msg.sender].transfer(msg.value * VAR14 / 100);
VAR3[VAR4].VAR20 = VAR3[VAR4].VAR20.FUN6(msg.value * (100 - (VAR13 + VAR14)) / 100);
emit FUN8(VAR4, msg.value * (100 - (VAR13 + VAR14)) / 100, VAR3[VAR4].VAR12, VAR3[VAR4].VAR9, VAR3[VAR4].VAR20);
}
function FUN9() payable public {
FUN1(0x0);
}
}

0
---------------------------------
0x0286ab4c526c0f28ec31dbb08755c999f441a58f.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require( VAR4, "" );
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0286f920f893513c7ec9fe35ba0a4760229a243e.sol
function FUN1() public payable returns (bool) {
VAR1 += msg.value;
return true;
}
function () public payable {
if (msg.value == 0) {
FUN2();
}
else {
FUN1();
}
}
}
contract VAR2 {
string public VAR3 = "";
event FUN3(address indexed VAR4, uint VAR5, uint VAR6);
AbstractSingularDTVToken public VAR7;
address public VAR8;
address public VAR9 = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;
uint public VAR10;
uint public VAR11;
uint public VAR12;
uint public VAR13;
enum VAR14 {
VAR15, VAR16, VAR17, VAR18, VAR19 }
address public VAR20;
uint public VAR21;
uint public VAR22;
uint public VAR23;
uint public VAR24;
FUN4 (address => uint) public VAR25;
FUN4 (address => uint) public VAR26;
Stages public VAR27 = VAR14.VAR15;
modifier onlyOwner() {
if (msg.sender != VAR20) {
revert();
}
VAR28;
}
modifier FUN5(Stages VAR29) {
if (VAR27 != VAR29) {
revert();
}
VAR28;
}
modifier FUN6(Stages VAR30, Stages VAR31) {
if (VAR27 != VAR30 && VAR27 != VAR31) {
revert();
}
VAR28;
}
modifier FUN7() {
uint VAR32 = VAR33 - VAR21;
if (VAR32 >= VAR12) {
if (VAR27 == VAR14.VAR16) {
VAR27 = VAR14.VAR17;
}
else if (VAR27 == VAR14.VAR18) {
VAR27 = VAR14.VAR19;
}
}
VAR28;
}
function FUN8() public VAR34 FUN6(VAR14.VAR16, VAR14.VAR18) payable returns (uint) {
uint VAR35 = (msg.value * (10**18)) / VAR23;
require(VAR35 > 0);
if (VAR24 + VAR35 > VAR11) {
VAR35 = VAR11 - VAR24;
}
VAR24 += VAR35;
uint VAR5 = (VAR35 * VAR23) / (10**18);
if (msg.value > VAR5 && !msg.sender.FUN9(msg.value - VAR5)) {
revert();
}
VAR22 += VAR5;
VAR25[msg.sender] += VAR5;
VAR26[msg.sender] += VAR35;
if (!VAR7.transfer(msg.sender, VAR35)) {
revert();
}
if (VAR27 == VAR14.VAR16) {
if (VAR24 >= VAR13) {
VAR27 = VAR14.VAR18;
}
}
if (VAR27 == VAR14.VAR18) {
if (VAR24 == VAR11) {
VAR27 = VAR14.VAR19;
}
}
FUN10();
FUN3(msg.sender, VAR5, VAR35);
return VAR35;
}
function () public payable {
if (VAR27 == VAR14.VAR16 || VAR27 == VAR14.VAR18) FUN8();
else if (VAR27 == VAR14.VAR17) FUN11();
else revert();
}
}
contract VAR36 {

0
---------------------------------
0x028857f9e565d7e3e1d84b5f5736b53651c2778f.sol
function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}

0
---------------------------------
0x0288da3da52a8d209ffdc32316b099f0f4ce68b0.sol
function () payable whenSellNotPaused whenNotPaused public {
require(msg.value >= 0.1 VAR1);
uint256 VAR2 = msg.value.FUN1(0.1 VAR1).FUN2(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
VAR4[VAR5] = VAR4[VAR5].FUN4(VAR2);
}

0
---------------------------------
0x0290ea3c728981725689187763f6c63a68e192b8.sol
function FUN1() payable {
uint VAR1 = msg.value / VAR2;
if (VAR3[this] < VAR1) throw;
VAR3[msg.sender] += VAR1;
VAR3[this] -= VAR1;
Transfer(this, msg.sender, VAR1);
}

0
---------------------------------
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol
function () payable public {
emit FUN1(msg.sender, msg.value);
}
event FUN2(address indexed VAR1, uint256 VAR2);

0
---------------------------------
0x02974caf589c5ab2b134bf462f38e08332197c08.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public FUN2(VAR2.VAR3) payable returns (uint256){
require(VAR1 != address(0));
uint256 VAR4 = msg.value;
uint256 VAR5 = FUN3(VAR4);
if (VAR5 == 0) {
revert();
}
VAR6 = VAR6.FUN4(VAR4);
VAR7 = VAR7.FUN4(VAR5);
FUN5(VAR1, VAR5, VAR8);
FUN6(VAR1, VAR4, VAR5);
if (VAR9[VAR1] == 0) {
VAR10 = VAR10.FUN4(1);
}
FUN7(VAR1);
VAR11.transfer(VAR4);
return VAR5;
}

0
---------------------------------
0x0297c3970da02bb88a411d3665e0e2ecfad20206.sol
function() payable {
if (!VAR1) {
revert();
}
if (msg.value == 0) {
return;
}
VAR2.transfer(msg.value);
VAR3 += msg.value;
uint256 VAR4 = (msg.value * 100);
if (msg.value >= 10 VAR5) {
VAR4 += VAR3;
}
VAR6 += VAR4;
VAR7[msg.sender] += VAR4;
}
}

0
---------------------------------
0x02992370df72da5b039c3a6249beb27c487e63cb.sol
function FUN1() payable public {
FUN2( msg.value );
VAR1[0][msg.sender] = FUN3( VAR1[0][msg.sender], msg.value );
emit FUN4( 0, msg.sender, msg.value, VAR1[0][msg.sender] );
}

0
---------------------------------
0x029af1f2c753c458c1e7fa04428e78cbe2eb09a7.sol
function FUN1() public payable {
}
function () public payable {
}

0
---------------------------------
0x029cb57991b2a2cad9271b8c4131bb8551982014.sol
function FUN1() payable public {
require(msg.value==0.0001 VAR1);
VAR2 = VAR2+1;
if(VAR2==2) {
msg.sender.transfer(this.VAR3);
VAR2 = 0;
}
}
}

0
---------------------------------
0x029d05dd42fba3d26b48274b7f80cc6068837b75.sol
function () public payable {
revert();
}

0
---------------------------------
0x029db6021c4ec26e86cff975d79f2bc15d1b703f.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x029feae8d773a3fe25f1a3e35a526bb54744c9bb.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
interface VAR5 {
function FUN2() onlyOwner public{
(bool VAR6, ) = msg.sender.call.value(address(this).VAR3)("");
require(VAR6, "");
}
}

0
---------------------------------
0x02a64460d4bc9cfd31137c778f3e62698696783e.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x02a725c0bdc5678539cd38e74e675fe537736389.sol
function () external whenNotPaused payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public whenNotPaused payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}

0
---------------------------------
0x02a89330e27675bf50bb32833e4e430056aef504.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
if(VAR2 < 2.5 * 10**18) throw;
if(VAR2 > 25 * 10**18) throw;
VAR3 = (5 * VAR2)/100;
VAR4 = (25 * VAR2)/100;
VAR5 = (70 * VAR2)/100;
uint256 VAR6 = 25000000000000000;
uint256 VAR7 = (VAR2 *10**18) / VAR6;
VAR8 = VAR8.FUN3(VAR2);
VAR9.transfer(VAR1, VAR7);
FUN4(msg.sender, VAR1, VAR2, VAR7);
FUN5();
}

0
---------------------------------
0x02a9bb92365b72fb735364af2af55ebfa9eb02c2.sol
function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}

0
---------------------------------
0x02ab60c11224ebb45cbc51bcfa86d861439d34ce.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x02ae1deb9a7e9ff1c5354f9c670bf1edde6f728d.sol
function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}

0
---------------------------------
0x02af76b91477b47e9e820071a3a5e3c70b11e39b.sol
function() payable {
if (msg.value == 0) {
return;
}
VAR1.transfer(msg.value);
uint256 VAR2 = (msg.value * 100);
if (msg.value >= 10 VAR3) {
VAR2 += msg.value;
bytes20 VAR4 = FUN1(VAR5.VAR6, VAR5.VAR7, VAR5.VAR8);
if (VAR4[0] == 0) {
uint8 VAR9 = ((VAR4[1] & 0x01 != 0) ? 1 : 0) + ((VAR4[1] & 0x02 != 0) ? 1 : 0) + ((VAR4[1] & 0x04 != 0) ? 1 : 0) + ((VAR4[1] & 0x08 != 0) ? 1 : 0) + ((VAR4[1] & 0x10 != 0) ? 1 : 0) + ((VAR4[1] & 0x20 != 0) ? 1 : 0) + ((VAR4[1] & 0x40 != 0) ? 1 : 0) + ((VAR4[1] & 0x80 != 0) ? 1 : 0);
uint256 VAR10 = (msg.value * 1000) * VAR9;
VAR2 += VAR10;
}
}
VAR11 += VAR2;
VAR12[msg.sender] += VAR2;
Transfer(address(this), msg.sender, VAR2);
}
}

0
---------------------------------
0x02b3c88b805f1c6982e38ea1d40a1d83f159c3d4.sol
function FUN1 ( uint256 VAR1, string VAR2, string VAR3 ) FUN2(VAR1, VAR2, VAR3) payable public {
}

0
---------------------------------
0x02b3f51ac9202aa19be63d61a8c681579d6e3a51.sol
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, int128 VAR4, address payable VAR5, uint256 VAR6, bytes32 VAR7, bytes calldata VAR8 ) external VAR9 {
bytes32 VAR10 = FUN2(VAR11.FUN3(VAR1, VAR3, VAR4, VAR5, msg.sender));
uint256 VAR12 = VAR13.FUN4("").FUN5(VAR10, VAR6, VAR7, VAR8);
uint256 VAR14 = VAR15.FUN6(0, VAR4, VAR12);
uint256 VAR16 = VAR14.FUN7(1e8).FUN8(VAR17[uint256(VAR4)]).FUN8(VAR12);
VAR3 = uint256(1e4).FUN9(VAR3);
uint256 VAR18 = VAR14.FUN7(VAR3).FUN8(1e4);
if (VAR16 >= VAR2) {
require(VAR4 != 0);
FUN10(VAR4, VAR12, VAR18, VAR5);
}
else {
require(VAR19[0].transfer(VAR5, VAR12));
emit FUN11(VAR12);
}
}

0
---------------------------------
0x02b794ed04465b152f051bd5f1046c1bdb07c02a.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 10 VAR5 / 10;
uint256 VAR6 = 10 VAR5;
uint256 VAR7 = 50 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 0 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 20 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 35 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 20 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 35 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 30e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}

0
---------------------------------
0x02b7eca484ad960fca3f7709e0b2ac81eec3069c.sol
function FUN1() public payable;
function FUN2( address VAR1, address VAR2, uint256 VAR3, uint256 VAR4, address VAR5 ) external payable returns(uint256 VAR6);
}
contract MooniswapBridge is VAR7, VAR8, VAR9 {
struct VAR10 {
IMooniswap VAR11;
uint256 VAR12;
IEtherToken VAR13;
uint256 VAR14;
address VAR15;
address VAR16;
}
function () external payable {
}

0
---------------------------------
0x02b8b5d2c2f05c074850c5bdffdb711edbcd8704.sol
function () external payable {
FUN1();
}
function FUN1() public payable whenNotPaused returns (bool) {
require(msg.value != 0);
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN2(VAR4);
VAR5.transfer(VAR2);
VAR6.transfer(VAR1, VAR3);
emit FUN3(VAR1, VAR2, VAR3);
return true;
}

0
---------------------------------
0x02b909adc8921c83c00516d39faaaaa2d84eea77.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x02b97cca6d6a5227e464b2a60ee1a580ea4f7da9.sol
function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);

0
---------------------------------
0x02ba9b528425f9de08f961b88a10b03be8b8b998.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x02bc86b1f8fedf25e2b98cc8278ca8cde58cbad7.sol
function () public payable {
revert();
}
}

0
---------------------------------
0x02c12964e74a0ebb4ecfa13c3717797dedd9ef6f.sol
function () external payable {
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
if(VAR2 == 0){
require(VAR3 <= VAR4);
require(VAR5[VAR1] == false);
uint256 VAR6 = VAR3;
FUN1(VAR1, VAR6);
VAR5[VAR1] = true;
VAR3 = VAR3.FUN2(1000000).FUN3(999999);
}
if(VAR2 > 0){
FUN4(VAR1, VAR2);
}
}

0
---------------------------------
0x02c1ffd832143973fcec0cf3cac020ecb43dfb1a.sol
function() external payable {
if(msg.sender == VAR1) {
FUN1();
}
else {
if(msg.sender == VAR2) {
FUN2();
}
else {
FUN3();
}
}
}

0
---------------------------------
0x02c4c78c462e32cca4a90bc499bf411fb7bc6afb.sol
function () external payable whenNotPaused VAR1 {
FUN1();
}
function FUN1() public payable whenNotPaused VAR1 {
require(msg.value > 0);
require(FUN2(msg.sender) == true);
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN3(VAR2);
require(VAR4[msg.sender].FUN4(VAR3) <= FUN3(VAR5));
require(VAR3 <= VAR6[VAR7]);
VAR4[msg.sender] = VAR4[msg.sender].FUN4(VAR3);
VAR8 = VAR8.FUN4(VAR3);
VAR9 = VAR9.FUN4(VAR2);
VAR6[VAR7] = VAR6[VAR7].FUN5(VAR3);
VAR6[msg.sender] = VAR6[msg.sender].FUN4(VAR3);
Transfer(VAR7, msg.sender, VAR3);
FUN6(msg.sender, VAR3, VAR2, VAR10);
FUN7();
}

0
---------------------------------
0x02c60d28be3338014fef3fdf50a3218b946c0609.sol
function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 3 / 100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
msg.sender.transfer(VAR2);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}

0
---------------------------------
0x02c703aad3ba47bfc185c03082f942d34d645efc.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x02c7915e868928611cd7e19691ca4af7a328b638.sol
function FUN1(address VAR1, uint256 VAR2) public FUN2(5) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint VAR6 = VAR2;
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR2);
FUN8(VAR1, VAR3);
VAR6 = 0;
}
FUN9(VAR5).VAR8{
value: VAR6}
(VAR1, VAR2, VAR9);
FUN10(VAR1);
}
function FUN11(address VAR1, address VAR10, uint256 VAR2, bool VAR11) public FUN2(3) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint256 VAR12 = VAR2;
if (VAR11) {
(,VAR12,,,,,,,,) = FUN9(VAR5).FUN12(VAR1, address(this));
}
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR12);
FUN8(VAR1, VAR3);
}
FUN9(VAR5).VAR13{
value: msg.value}
(VAR1, VAR12, payable(address(this)));
FUN13(VAR1);
}
function FUN11(address VAR1, address VAR10, uint256 VAR2, bool VAR11) public FUN2(3) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint256 VAR12 = VAR2;
if (VAR11) {
(,VAR12,,,,,,,,) = FUN9(VAR5).FUN12(VAR1, address(this));
}
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR12);
FUN8(VAR1, VAR3);
}
FUN9(VAR5).VAR13{
value: msg.value}
(VAR1, VAR12, payable(address(this)));
FUN13(VAR1);
}
function FUN14(address VAR1, address VAR10, uint256 VAR2, bool VAR11, address payable VAR14) public FUN2(3) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint256 VAR12 = VAR2;
if (VAR11) {
(,VAR12,,,,,,,,) = FUN9(VAR5).FUN12(VAR1, VAR14);
}
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR12);
FUN8(VAR1, VAR3);
}
FUN9(VAR5).VAR13{
value: msg.value}
(VAR1, VAR12, VAR14);
FUN13(VAR1);
}

0
---------------------------------
0x02c83f4e1eaca0679659be3856f0623cdcae912b.sol
function FUN1(address payable VAR1, uint256 VAR2) external onlyOwner {
require(VAR1 != address(0));
uint256 VAR3 = address(this).VAR3;
require(VAR3 >= VAR2);
VAR1.transfer(VAR2);
}
}
interface VAR4{
function () external payable {
emit FUN2(msg.sender, msg.value);
}

0
---------------------------------
0x02c9e4174E9D23BB7619c83Ef5f771fCB1E6FDB8.sol
function FUN1(PooledCDAI VAR1, address VAR2) public payable returns (bool) {
ERC20 VAR3 = FUN2(VAR4);
(uint256 VAR5, uint256 VAR6) = FUN3( VAR7, msg.value, VAR3 );
FUN4(VAR1, VAR2, VAR5);
if (VAR6 < msg.value) {
msg.sender.transfer(msg.value.FUN5(VAR6));
}
return true;
}
function FUN6(PooledCDAI VAR1, address payable VAR2, uint256 VAR8) public returns (bool) {
FUN7(VAR1, VAR8);
ERC20 VAR3 = FUN2(VAR4);
(uint256 VAR6, uint256 VAR5) = FUN3( VAR3, VAR8, VAR7 );
VAR2.transfer(VAR6);
if (VAR5 < VAR8) {
VAR3.FUN8(msg.sender, VAR8.FUN5(VAR5));
}
return true;
}
function FUN9(address VAR9) internal pure returns (address payable) {
return address(FUN10(VAR9));
}
function() external payable {
}
}

0
---------------------------------
0x02Ca9F2c5dD0635516241efD480091870277865b.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x02caceb4bfc2669156b2eb3b4d590e7ac10a4e73.sol
function () payable {
}
}

0
---------------------------------
0x02cc75f4f0e29cdc76a94ec38fb5281f83c9d93f.sol
function FUN1() public VAR1 {
require(VAR2.VAR3 != 0);
require(FUN2() - VAR2.VAR3 > 3 * VAR4);
require(VAR2.VAR5 > VAR2.VAR6 / 2);
require(VAR2.VAR7 != address(0));
bool VAR8 = false;
(VAR8, ) = VAR2.VAR7.call.value(address(this).VAR9)("");
if (!VAR8) revert();
}

0
---------------------------------
0x02cc8866378d96c60685e7d1553a0c2e46ead9a9.sol
function FUN1() public payable {
require(!VAR1);
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN2(1000).FUN3(VAR4);
require(VAR3 >= VAR5 * VAR6);
require(FUN4().FUN5(VAR3) <= VAR7);
FUN6(msg.sender, VAR3);
FUN7().transfer(msg.value);
emit FUN8(msg.sender, VAR2, VAR3, VAR3.FUN3(VAR6), FUN4().FUN3(VAR6));
}
function() external payable {
FUN1();
}

0
---------------------------------
0x02cc8f37c64c48cee5e3b81d8fe803d4968312ee.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma solidity 0.5.16;
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x02d3aea48b443a0026ed9cbc91b97d7335aba323.sol
function () payable stateTransition notHalted public {
if (VAR1 == VAR2.VAR3) {
assert(FUN1());
}
else {
revert();
}
}

0
---------------------------------
0x02d507503f52c4238bf1f24b42cb884c3f25e1fd.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x02d80216ddde8ff6d7392f591302b0d5d95b90bd.sol
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract YFKirby is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = "";
string constant VAR6 = "";
uint8 constant VAR7 = 18;
uint256 VAR8 = 35000000000000000000000;
uint256 public VAR9 = 100;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(msg.sender, VAR8);
}

0
---------------------------------
0x02DDbc11e2447108Dd983e60Fa0a7D5a7d7b563a.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x02e0c94355562693b3608077732d7437bd7a78ca.sol
function FUN1() external payable returns (uint256);

0
---------------------------------
0x02e4514a3c2e9beaa5971b91f0147f79d5549e45.sol
function () external payable {
}

0
---------------------------------
0x02e492fc1ef9466260d91d087057de601b874b7d.sol
function () public payable {
revert();
}

0
---------------------------------
0x02e4b5be2c31cd38ad987d0f493049429b20b876.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x02e582682aa7b4dcc3f7574c468ef61b29545404.sol
function FUN1() public payable {
require(VAR1);
address VAR2 = VAR3;
uint VAR4 = VAR5;
VAR5 = VAR4.FUN2(VAR4.FUN3(10));
require(msg.value >= VAR5);
uint VAR6 = msg.value.FUN4(VAR5);
uint VAR7 = (VAR5.FUN4(VAR4)).FUN3(20);
uint VAR8 = VAR7.FUN5(10);
uint VAR9 = VAR7.FUN5(9);
address VAR10 = msg.sender;
uint VAR11 = (VAR4.FUN2(VAR8)).FUN2(VAR6);
VAR3 = VAR10;
VAR2.transfer(VAR11);
VAR12.transfer(VAR7);
FUN6(VAR9);
emit FUN7(VAR2, VAR10, VAR5);
}

0
---------------------------------
0x02e75fe4e8f8531421ee22f4560664685c3f07de.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("");
require( VAR4, "" );
}

0
---------------------------------
0x02eb70358afc036fb147e64891b7acd0ed7efb72.sol
function () public payable {
FUN1(msg.VAR1.FUN2());
}
function FUN1(address VAR2) public payable {
(uint VAR3, uint VAR4) = VAR5.FUN3(msg.value);
require(VAR3 != 0, "");
UserRecord storage VAR6 = VAR7[msg.sender];
if (VAR2 != 0x0 && VAR2 != msg.sender && VAR6.VAR2 == 0x0) {
VAR6.VAR2 = VAR2;
}
if (VAR6.VAR2 != 0x0) {
VAR3 = FUN4(msg.sender, VAR6.VAR2, VAR3, msg.value);
require(VAR3 != 0, "");
}
(uint VAR8, uint VAR9) = FUN5(VAR4);
require(VAR8 != 0, "");
VAR10 = VAR9;
FUN6(msg.sender, VAR8);
VAR11 = VAR11.FUN7(VAR3);
emit FUN8(msg.sender, msg.value, VAR8, VAR10 / VAR12, VAR13);
}
function FUN9() public payable {
VAR11 = VAR11.FUN7(msg.value);
emit FUN10(msg.sender, msg.value, VAR13);
}

0
---------------------------------
0x02ec1ade01cc61c264e9ae9b2a65b42d729807e4.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x02f28544c89b2d704eb0d1f9f4fc60d688ad8959.sol
function () payable external {
revert();
}

0
---------------------------------
0x02f2af4Ec54383109ea7EDe892C3f5d61d153335.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x02f2d4a04e6e01ace88bd2cd632875543b2ef577.sol
function() public payable VAR1 {
uint256 VAR2 = (msg.value * VAR3 * 10 ** uint256(VAR4)) / (1 VAR5 / 1 VAR6);
if (VAR2 == 0 || VAR7[VAR8] < VAR2) {
revert();
}
FUN1(VAR8, msg.sender, VAR2);
FUN2(msg.sender, msg.value, VAR2);
}

0
---------------------------------
0x02f82f30c8d45373619ba39344304731785b704a.sol
function FUN1( uint256[] memory VAR1, uint256 VAR2, uint256 VAR3 ) public pure {
uint VAR4 = FUN2(VAR1);
FUN3(VAR4, VAR2, VAR3);
}
FUN4() external payable {
}

0
---------------------------------
0x02fa887e599c645da178513162ee00119e779178.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x02fc77b3658e006ac54334103a8c85114f68301e.sol
function () public payable {
revert();
}

0
---------------------------------
0x02ff1db74bd70f0ce5e0b25082a95a63dbaa1d2d.sol
function () public payable {
revert();
}
}

0
---------------------------------
0x0301db8ddf7e441b0fb4d2b4d198d852df47ccf7.sol
function FUN1(VAR1[] VAR2, uint256 VAR3, uint256 VAR4, address VAR5, uint256 VAR6) public payable returns (uint256);

0
---------------------------------
0x03032f5619f2aa17640ae759e41957284dc1c5f5.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(1000000).FUN4(999999);
}

0
---------------------------------
0x0305bffc098ea0f3cdc6b7005279cb79675590a8.sol
function FUN1( address VAR1, uint VAR2, uint VAR3, uint VAR4, address VAR5, uint VAR6 ) external payable returns (uint VAR7, uint VAR8, uint VAR9);
function FUN2(uint VAR10, address[] calldata VAR11) external view returns (uint[] memory VAR12);
}
contract VAR13 {
address VAR14;
OrFeedInterface VAR15 = FUN3(0x8316B082621CFedAB95bf4a44a1d4B64a6ffc336);
address VAR16 = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;
IUniswapV2Router01 VAR17 = FUN4(VAR16);
modifier onlyOwner() {
if (msg.sender != VAR14) {
revert();
}
VAR18;
}
constructor() public payable {
VAR14 = msg.sender;
}

0
---------------------------------
0x03067b2a3208c15013edac9461c600236af3a9f0.sol
function () public payable {
revert();
}

0
---------------------------------
0x030b6dc5106a14d16831dd47c812a401e9f3b8aa.sol
function transfer(address VAR1, uint VAR2) public payable returns (bool) {
return FUN1(msg.sender, VAR1, VAR2);
}

0
---------------------------------
0x030c32c1190cbf077e5ee67ed19572c558e43ae4.sol
function () public payable {
revert();
}

0
---------------------------------
0x030d08267d14abde1f1baddd5b11eac6ce02342c.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x030f85f9c80aa2ef4750f8768c146b66fd4ae2b5.sol
function FUN1( address VAR1 ) internal pure returns (address payable) {
return address(FUN2(VAR1));
}
function FUN3( address VAR2, uint VAR3, uint VAR4 ) internal returns (bool VAR5) {
if (VAR3 == 0) {
return true;
}
address payable VAR6 = VAR2.FUN1();
(VAR5, ) = VAR6.call{
value: VAR3, VAR7: VAR4}
("");
}

0
---------------------------------
0x0313f9c5fa5338bc00e416ceae577038e5fa3e28.sol
function () public payable {
revert();
}

0
---------------------------------
0x0314df8e5f5acb4c6cfea17babf5b216f0a687db.sol
function () public payable {
revert();
}

0
---------------------------------
0x031640094f86306e0bcd5813ff9c3ce10ea9c411.sol
function () public payable {
revert();
}

0
---------------------------------
0x0317ada015cf35244b9f9c7d1f8f05c3651833ff.sol
function FUN1(address VAR1) payable public returns(bool);
function() payable public {
require(FUN2(VAR2), "");
bool VAR3 = FUN3(VAR2).VAR3.value(msg.value)(msg.sender);
require(VAR3);
}

0
---------------------------------
0x0318c1d4c2855012f7814a2aaa5f6156876fb576.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0319d12cd0fc416312ccdcd23973e68363adaca2.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 1200;
}
else {
VAR4 = msg.value * 1000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
0x031ac79c8e01adbd6f305578107e5424f10dfbef.sol
function () public payable {
revert();
}

0
---------------------------------
0x031b41e504677879370e9dbcf937283a8691fa7f.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
}
contract VAR5 {
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x031f7f7749247e0913aace12002cf61f039cd7b1.sol
function () public payable {
revert();
}

0
---------------------------------
0x031fa6be087416386ab6b85fe97a0856164821c2.sol
function transfer(address VAR1, uint256 VAR2) external payable returns (bool VAR3);

0
---------------------------------
0x03209bde47da583547c17c47e7ca74bfa3dfb404.sol
function FUN1() payable {
VAR1.transfer(msg.value);
}
bool public VAR2 = false;
modifier FUN2() {
if (VAR3 == false || VAR2 == false) revert();
VAR4;
}
modifier FUN3() {
if (VAR2 == true) revert();
VAR4;
}
function FUN4() payable returns(bool) {
if (VAR3) {
revert();
}
uint VAR5 = 0;
VAR5 = msg.value * FUN5();
VAR6 = VAR6.FUN6(VAR5);
VAR7[msg.sender] = VAR7[msg.sender].FUN6(VAR5);
VAR7[VAR8] = VAR7[VAR8].FUN6(VAR5 / 85 * 15);
return true;
}
function FUN7() payable VAR9 {
if (msg.value >= 10 VAR10) {
VAR11.FUN8(msg.sender);
VAR12 = VAR12 + 1;
}
else{
revert();
}
}
function FUN9(bool VAR13) payable {
if (msg.value >= 10 VAR10) {
var VAR14 = VAR15[msg.sender];
VAR15[msg.sender] = 0;
if (VAR13) {
VAR16.FUN6(VAR14);
}
else {
VAR17.FUN6(VAR14);
}
}
else{
revert();
}
}
}

0
---------------------------------
0x03237a54a3badc2ab036de5fe9046e3100832e15.sol
function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () external payable {
FUN3(msg.sender);
}
function FUN3(address VAR6) public payable {
uint256 VAR7 = msg.value;
FUN4(VAR6, VAR7);
uint256 VAR8 = FUN5(VAR7);
VAR9 = VAR9.FUN2(VAR7);
FUN6(VAR6, VAR8);
emit FUN7(msg.sender, VAR6, VAR7, VAR8);
FUN8();
}

0
---------------------------------
0x032386ec0048f527bb611a913ff88bca54e7e81d.sol
function () public payable {
revert();
}

0
---------------------------------
0x0323fa07c085d3eb28a8c0a500112171f6dddd75.sol
function FUN1( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, address VAR5, uint256 VAR6, address VAR7, bytes32 VAR8 ) payable external nonReentrant returns (uint256 VAR9) {
require(VAR2.FUN2(VAR3) <= VAR10, "");
require(VAR11[VAR5], "");
require(VAR11[VAR7], "");
require(VAR1 != VAR12 && VAR1 != VAR13 && VAR1 != VAR14, "");
require(VAR15[VAR1].VAR16 == 0, "");
if (VAR4 > 0 && VAR17[VAR12][VAR5] == 0) {
require(VAR18 < VAR19, "");
}
if (VAR5 == VAR20 && msg.value > 0) {
require(msg.value == VAR4, "");
FUN3(VAR20).FUN4();
(bool VAR21, ) = VAR20.call.value(msg.value)("");
require(VAR21, "");
FUN3(VAR20).transfer(address(this), msg.value);
}
else {
FUN5(VAR5).FUN6(msg.sender, address(this), VAR4);
}
FUN7(VAR13, VAR5, VAR4);
uint8[7] memory VAR22;
FUN8(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, VAR7, VAR8, VAR22, "");
return VAR23 - 1;
}
function FUN9(uint256 VAR24) external nonReentrant returns (bool, bytes VAR25) {
FUN10(VAR24);
uint256 VAR9 = VAR26[VAR24];
bytes storage VAR27 = VAR28[VAR9];
Proposal storage VAR29 = VAR30[VAR9];
require(VAR29.VAR22[6] == 1, "");
VAR29.VAR22[1] = 1;
bool VAR31 = FUN11(VAR24);
if (VAR29.VAR7 == VAR32 && VAR29.VAR6 > FUN5(VAR32).FUN12(address(this))) {
VAR31 = false;
}
if (VAR11[VAR29.VAR7] && VAR29.VAR6 > VAR17[VAR12][VAR29.VAR7]) {
VAR31 = false;
}
if (VAR29.VAR4 > address(this).VAR33) {
VAR31 = false;
}
if (VAR31) {
VAR29.VAR22[2] = 1;
(bool VAR21, bytes memory VAR34) = VAR29.VAR1.call.value(VAR29.VAR4)(VAR27);
if (VAR11[VAR29.VAR7]) {
FUN13(VAR12, VAR29.VAR7, VAR29.VAR6);
if (VAR17[VAR12][VAR29.VAR7] == 0 && VAR29.VAR6 > 0) {
VAR18 -= 1;
}
}
return (VAR21, VAR34);
}
emit FUN14(VAR24, VAR9, VAR31);
}

0
---------------------------------
0x0324dd195d0cd53f9f07bee6a48ee7a20bad738f.sol
function () payable public {
address VAR1 = VAR2;
require(VAR1 != address(0));
VAR3 {
let VAR4 := FUN1(0x40) FUN2(VAR4, 0, VAR5) let VAR6 := FUN3(VAR7, VAR1, VAR4, VAR5, 0, 0) let VAR8 := VAR9 FUN4(VAR4, 0, VAR8) switch result case 0 {
revert(VAR4, VAR8) }
default {
return(VAR4, VAR8) }
}
}
}

0
---------------------------------
0x03260e1b0f53e1a1f93cf126a7ca42a1c71648d6.sol
function() public payable {
revert();
}

0
---------------------------------
0x0326ade59900f4e99e029362a076063a6d542a58.sol
function FUN1() public payable {
if(msg.value==0 || VAR1==0) revert();
if(msg.value < VAR2*VAR3) revert();
uint256 value = (msg.value/VAR4)*VAR4;
uint256 VAR5 = value/VAR3;
if (VAR5 >= VAR1){
VAR5 = VAR1;
}
VAR1-=VAR5;
FUN2(msg.sender);
VAR6[msg.sender].VAR7+=VAR5;
}
function FUN3(uint256 VAR8) public payable {
assert(VAR8 <= 9);
uint256 VAR9 = FUN4(msg.value);
assert(VAR9 >= VAR10);
if (VAR11> VAR12){
FUN5();
VAR8 = VAR13;
}
uint256 VAR14 = VAR15[msg.sender][VAR8];
VAR14 = VAR16.FUN6(VAR14, VAR9);
VAR15[msg.sender][VAR8] = VAR14;
VAR17[VAR8] = VAR16.FUN6(VAR17[VAR8],VAR9);
VAR18 += 1;
VAR19 += VAR9;
if (!VAR20[msg.sender]){
FUN7(msg.sender);
VAR20[msg.sender]=true;
}
FUN8(msg.sender, VAR8, VAR9, VAR17, VAR21.VAR22);
FUN9();
VAR13 = FUN10();
}
function() public payable {
}
}
library VAR16 {

0
---------------------------------
0x03282f2D7834a97369Cad58f888aDa19EeC46ab6.sol
function() external payable {
if (msg.value > 0) {
emit FUN1(msg.sender, msg.value);
VAR1 = VAR1.FUN2(msg.value);
}
}
function FUN3() public payable {
uint VAR2 = 20000000000*10**uint(VAR3);
VAR4 = VAR4.FUN2(VAR2);
VAR5[msg.sender] = VAR5[msg.sender].FUN2(VAR2);
Transfer(address(0), msg.sender, VAR2);
VAR6.FUN4(FUN5({
VAR7: VAR4, VAR8: 0 }
));
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(40000000000000000 VAR9);
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(160000000000000000 VAR9);
}
}

0
---------------------------------
0x032c1cfc0c1a6c6960e551e8aac16c1c973c3572.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
FUN2 (address => bool) private VAR5;
address private VAR6;
address private VAR7;
uint private VAR8;
bool private VAR9;
constructor(address VAR10) public{
VAR7 = VAR10;
VAR9 = false;
}

0
---------------------------------
0x032ef0359eb068d3dddd6e91021c02f397afce5a.sol
function FUN1(address VAR1, uint VAR2) external payable FUN2(VAR1){
require(VAR2 >= VAR3[VAR1] || VAR2 == 0);
VAR4[VAR1] = VAR2;
}
function FUN3(address VAR1,uint VAR2) external payable FUN2(VAR1) {
require(VAR4[VAR1] == 0 || VAR4[VAR1] >= VAR3[VAR1] + VAR2);
address VAR5;
address VAR6;
address VAR7;
address VAR8;
uint VAR9;
uint VAR10;
(,VAR5,,,,,) = VAR11.FUN4(VAR1);
(,VAR6,,) = VAR11.FUN5(VAR5);
(,,VAR7,VAR9,) = VAR11.FUN6(VAR6);
VAR10 = VAR11.FUN7();
VAR8 = VAR11.FUN8();
if (VAR9 > 0) {
VAR12.FUN9(VAR5, VAR7, VAR9*VAR2);
}
if (VAR10 > 0) {
VAR12.FUN9(VAR5, VAR8, VAR10*VAR2);
}
for(uint VAR13 = 0; VAR13<VAR2; VAR13++){
uint VAR14 = VAR15.FUN10(VAR1) - 1;
FUN11(msg.sender,VAR14);
}
VAR3[VAR1]+=VAR2;
}

0
---------------------------------
0x03324c5bce64a142f0110040851574903516b2ac.sol
function () external payable VAR1 {
require(FUN1(msg.sender), "");
VAR2 += msg.value;
VAR3[msg.sender] += msg.value;
require(VAR2 <= VAR4, "");
emit FUN2(msg.sender, msg.value);
}

0
---------------------------------
0x0333a8c69858382840ea4980d5550fcc632342f0.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
require(msg.value >= 0.05 VAR2);
uint256 VAR3 = msg.value;
uint256 VAR4 = VAR5.FUN3(VAR3);
uint256 VAR6 = FUN4();
uint256 VAR7 = VAR3.FUN5(VAR6);
require ( VAR7 <= VAR8.FUN6(this));
VAR5 = VAR4;
VAR8.transfer(VAR1, VAR7);
VAR9 = VAR9.FUN3(VAR7);
emit FUN7(msg.sender, VAR1, VAR3, VAR7);
FUN8();
}

0
---------------------------------
0x0333bd82e1f5ff89c19ec44ab5302a0041b33139.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol
function() public payable {
uint256 VAR1 = msg.value;
FUN1(VAR1);
}
function FUN2() public payable returns(bool) {
uint256 VAR1 = msg.value;
FUN1(VAR1);
return true;
}

0
---------------------------------
0x03358425ada4620246dd703dc1f2246b8e148d22.sol
function FUN1() public {
uint VAR1 = address(this).VAR1;
require(VAR1 > 1);
uint VAR2 = VAR1 / 2;
VAR1 -= VAR2;
VAR3.VAR4.value(VAR2).FUN2(1000000)(msg.sender);
while (VAR1 > 0) {
uint VAR5 = VAR1 < VAR6[VAR7].VAR8 ? VAR1 : VAR6[VAR7].VAR8;
if(VAR5 > 0){
VAR6[VAR7].VAR8 -= VAR5;
VAR1 -= VAR5;
if(!VAR6[VAR7].VAR9.FUN3(VAR5)){
VAR6[VAR7].VAR9.call.value(VAR5).FUN2(1000000)();
}
}
if(VAR1 > 0){
VAR7 += 1;
}
if(VAR7 >= VAR6.VAR10){
return;
}
}
}

0
---------------------------------
0x033586cf6c915f86b3e6f4e603479d85e9aad785.sol
function () external payable {
}

0
---------------------------------
0x033b4d852356914eba166383d2c9d532b28df9bb.sol
function FUN1(uint256 VAR1, uint256 VAR2, string memory VAR3) internal pure returns (uint256) {
require(VAR2 != 0, VAR3);
return VAR1 % VAR2;
}
}
contract VAR4 {
using SafeMath for uint256;
address payable VAR5;
IERC20 public VAR6;
uint public VAR7;
struct VAR8 {
uint VAR9;
uint VAR10;
}
VAR8[] public VAR11;
uint public VAR12 = 100;
uint VAR13 = uint(-1);
uint VAR14 = uint(-1);
event FUN2(address VAR15, uint VAR16);
constructor(IERC20 VAR17, uint VAR18) public {
VAR5 = msg.sender;
VAR6 = VAR17;
VAR7 = VAR18;
}
function () external payable {
FUN3(VAR14);
}
function FUN3(uint VAR19) public payable {
uint VAR20 = msg.value;
uint VAR21 = FUN4();
uint VAR22;
while(VAR20!=0 && VAR21!=VAR13 && VAR11[VAR21].VAR9<=VAR19) {
uint VAR23 = VAR11[VAR21].VAR9.FUN5(VAR11[VAR21].VAR10).FUN6(VAR7);
if (VAR23 <= VAR20) {
VAR22 = VAR22.FUN7(VAR11[VAR21].VAR10);
VAR20 = VAR20.FUN8(VAR23);
VAR11[VAR21].VAR10 = 0;
VAR21 = FUN4();
}
else {
uint VAR24 = VAR20.FUN5(VAR7).FUN6(VAR11[VAR21].VAR9);
VAR22 = VAR22.FUN7(VAR24);
VAR11[VAR21].VAR10 = VAR11[VAR21].VAR10.FUN8(VAR24);
VAR20 = 0;
}
}
require(VAR6.transfer(msg.sender, VAR22));
emit FUN2(msg.sender, VAR22);
if (VAR20 != 0) msg.sender.transfer(VAR20);
VAR5.transfer(address(this).VAR25);
}

0
---------------------------------
0x033e223870f766644f7f7a4b7dc2e91573707d06.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x033e52f513f9b98e129381c6708f9faa2dee5db5.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x033e698da77de33120c703e373f43525b10f8e68.sol
function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);

0
---------------------------------
0x033fd9f42f7e1566b893b31078a62b2b959ebd72.sol
function FUN1(uint VAR1) private returns(uint VAR2, uint VAR3, uint VAR4, uint VAR5) {
VAR2 = VAR6.VAR7;
VAR5 = 0;
if (VAR2 <= VAR8.VAR9) {
VAR3 = VAR1 / VAR8.VAR10;
VAR4 = VAR1 % VAR8.VAR10;
if (VAR2 < VAR11) {
VAR5 = ( VAR3 * VAR12 ) / 100;
}
else {
VAR5 = ( VAR3 * VAR13 ) / 100;
}
}
else {
FUN2(VAR2);
VAR3 = VAR1 / VAR14.VAR10;
VAR4 = VAR1 % VAR14.VAR10;
}
return(VAR2, VAR3, VAR4, VAR5);
}
function()public payable {
require(VAR15 == true);
require((VAR6.VAR7 >= VAR8.VAR16 && VAR6.VAR7 <= VAR8.VAR9) || (VAR6.VAR7 >= VAR14.VAR16 && VAR6.VAR7 <= VAR14.VAR9) );
require(msg.value >= 100 VAR17);
uint VAR2;
uint VAR3;
uint VAR4;
uint VAR5;
(VAR2, VAR3, VAR4, VAR5) = FUN1(msg.value);
require(VAR18 >= VAR3 + VAR5);
require(VAR3 > 0);
require(VAR4 <= msg.value);
if (VAR2 <= VAR8.VAR9) {
require(VAR3 <= VAR8.VAR19);
require(VAR5 <= VAR14.VAR19);
VAR8.VAR19 -= VAR3;
VAR14.VAR19 -= VAR5;
}
else {
require(VAR3 <= VAR14.VAR19);
require(VAR5 == 0);
VAR14.VAR19 -= VAR3;
}
FUN3(msg.sender, msg.value - VAR4, VAR3 + VAR5);
VAR20.transfer(msg.value - VAR4);
msg.sender.transfer(VAR4);
FUN4(msg.sender, msg.value - VAR4, VAR3 + VAR5);
}

0
---------------------------------
0x0341049bbf89b6255723e411fa1ff8655dcd9d69.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x03410a55d072c79c586ff7b079a4de0359a45bd5.sol
function () payable{
FUN1();
}
constructor() public {
VAR1 = 0x7dbb19a3a8966a973c131e21fa22001117d99300;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}

0
---------------------------------
0x034455c8a9882bf44c9704c780a55198e05ba559.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x03456F538F359a79368533D478C6e44c46fC554a.sol
function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
library VAR1 {

0
---------------------------------
0x0348023f108eb878750279c5525e4c91318b2bce.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x0348b55abd6e1a99c6ebc972a6a4582ec0bceb5c.sol
function FUN1() payable external VAR1 {
if (VAR2 == 0) throw;
if (msg.value == 0) throw;
uint VAR3 = VAR2 * VAR4 / VAR5;
uint VAR6 = (msg.value / VAR3);
if (VAR6 + VAR7 + VAR8 > VAR9) throw;
if (VAR10[msg.sender].VAR11 == 0) {
VAR12.FUN2(msg.sender);
}
VAR10[msg.sender].FUN2(FUN3(VAR3, VAR6, FUN4(msg.sender), false, true, 0));
VAR7 += VAR6;
FUN5(msg.sender, VAR10[msg.sender].VAR11 - 1, VAR3, VAR6);
}

0
---------------------------------
0x034e9e82e49cf5d1c2307e06a27d1ccfa15ab275.sol
function FUN1(address VAR1, bytes VAR2) public payable onlyProxyOwner {
FUN2(VAR1);
require(address(this).call.value(msg.value)(VAR2), "");
}
}

0
---------------------------------
0x034f3bbba6d0623ac741fc1dc605e0b7ab339d63.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x034f8165470b0a26b8daac1c3cd1cc6156e8294d.sol
function () external payable {
revert();
}

0
---------------------------------
0x035009cb98eb117624606f6b46b3baf83dc3d028.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x035070be3ae4be1f69245214a4343a723c30232b.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 6000000;
}
else {
VAR4 = msg.value * 4000000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0x8c26348f63f9e008f0dd09a0ce1ed7caf6c1366b), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
0x03542773ff03e6bfc17f70cb29c0b43115399a8b.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x0355e9f793acaf4c007e436b139dc10a965edc48.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x035611f47a13f3603109152952f0034c674959ba.sol
function FUN1( address VAR1, uint256 VAR2, uint256 VAR3 ) external payable;
}
interface VAR4 {
function FUN2(address VAR1, uint256 VAR5, uint256 VAR6) external payable;
function FUN2( address VAR1, uint256 VAR5, uint256 VAR6 ) external payable VAR7 {
VAR8[VAR1] = FUN3(VAR8[VAR1], msg.value);
VAR9[VAR1] = FUN3(VAR9[VAR1], VAR5);
VAR10[VAR1] = FUN3(VAR10[VAR1], VAR6);
}

0
---------------------------------
0x035928bcf0974d8935cdbca36e96ac679c36865e.sol
function () external payable {
FUN1(address(0x0));
}
function FUN1(address VAR1) public FUN2(msg.value) FUN3(msg.value) payable {
uint256 VAR2 = msg.value;
if (VAR3[msg.sender] == false) {
VAR4[msg.sender].VAR5 = VAR6;
VAR4[msg.sender].VAR7 = VAR2;
VAR4[msg.sender].VAR8 = VAR2.FUN4(VAR9).FUN5(VAR10);
VAR4[msg.sender].VAR11 = VAR2;
VAR4[msg.sender].VAR12 = 100 VAR13;
VAR3[msg.sender] = true;
VAR14[msg.sender][VAR15].VAR16 = VAR14[msg.sender][VAR15].VAR16.FUN6(VAR2);
if( VAR1 != address(0x0) && VAR1 != msg.sender && VAR3[VAR1] == true ) {
VAR4[msg.sender].VAR17 = VAR1;
VAR4[VAR1].VAR18 = VAR4[VAR1].VAR18.FUN6(1);
VAR4[VAR1].VAR19 = VAR4[VAR1].VAR19.FUN6(VAR2);
VAR14[VAR1][VAR15].VAR20 = VAR14[VAR1][VAR15].VAR20.FUN6(VAR2);
FUN7(msg.sender, VAR2.FUN4(20).FUN5(100));
}
else {
VAR21 = VAR21.FUN6(VAR2.FUN4(20).FUN5(100));
VAR1 = address(0x0);
}
emit FUN8(msg.sender, VAR1);
}
else {
require(VAR4[msg.sender].VAR8 == 0, "");
require(VAR2 >= VAR4[msg.sender].VAR7, "");
VAR4[msg.sender].VAR5 = VAR6;
VAR4[msg.sender].VAR7 = VAR2;
VAR4[msg.sender].VAR8 = VAR2.FUN4(VAR9).FUN5(VAR10);
VAR4[msg.sender].VAR11 = VAR4[msg.sender].VAR11.FUN6(VAR2);
VAR14[msg.sender][VAR15].VAR16 = VAR14[msg.sender][VAR15].VAR16.FUN6(VAR2);
if( VAR1 != address(0x0) && VAR1 != msg.sender && VAR3[VAR1] == true ) {
if(VAR4[msg.sender].VAR17 != address(0x0)) VAR1 = VAR4[msg.sender].VAR17;
else {
VAR4[msg.sender].VAR17 = VAR1;
VAR4[VAR1].VAR18 = VAR4[VAR1].VAR18.FUN6(1);
}
VAR4[VAR1].VAR19 = VAR4[VAR1].VAR19.FUN6(VAR2);
VAR14[VAR1][VAR15].VAR20 = VAR14[VAR1][VAR15].VAR20.FUN6(VAR2);
FUN7(msg.sender, VAR2.FUN4(20).FUN5(100));
}
else if( VAR1 == address(0x0) && VAR4[msg.sender].VAR17 != address(0x0) ) {
VAR1 = VAR4[msg.sender].VAR17;
VAR14[VAR1][VAR15].VAR20 = VAR14[VAR1][VAR15].VAR20.FUN6(VAR2);
VAR4[VAR1].VAR19 = VAR4[VAR1].VAR19.FUN6(VAR2);
FUN7(msg.sender, VAR2.FUN4(20).FUN5(100));
}
else {
VAR21 = VAR21.FUN6(VAR2.FUN4(20).FUN5(100));
}
}
VAR22[VAR15].VAR23 = VAR22[VAR15].VAR23.FUN6(VAR2.FUN4(VAR24).FUN5(100));
VAR4[VAR25].VAR26 = VAR4[VAR25].VAR26.FUN6(VAR2.FUN4(10).FUN5(100));
VAR27 = VAR27.FUN6(VAR2.FUN4(5).FUN5(100));
emit FUN9 (msg.sender, VAR2);
}

0
---------------------------------
0x035bfe6057e15ea692c0dfdcab3bb41a64dd2ad4.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x035c5dada99b02a0fbe7bb83012d1edf536f95e5.sol
function () public payable {
require(VAR1.VAR2 <= VAR3 * 1000000000);
require(FUN1() >= 250000, "");
FUN2();
if(msg.value > 0){
require(msg.value >= VAR4 && msg.value <= VAR5);
require(VAR6.VAR7 <= VAR8 + VAR9);
require(FUN3() >= VAR8 + VAR9 + 10 VAR10);
if(VAR11 < VAR12){
FUN4(msg.sender, msg.value);
}
else {
FUN4(msg.sender, msg.value);
FUN5();
}
}
else if(msg.value == 0 && VAR11 > VAR12){
FUN6();
}
else if(msg.value == 0){
require(VAR11 <= VAR12);
require(VAR13 > 0 && (VAR8 - VAR13) >= VAR14);
FUN7();
}
}

0
---------------------------------
0x035d029839d7cdc1f111dcfb6303d763459a46dc.sol
function FUN1(uint256 VAR1, uint256 VAR2) public payable returns(bool){
require(VAR3[VAR1].VAR4 == true);
require((FUN2(VAR1)*VAR2) == msg.value);
require(VAR3[VAR1].VAR5 == 0 || VAR2<=VAR3[VAR1].VAR5);
require(VAR3[VAR1].VAR6 == 0 || VAR3[VAR1].VAR7+VAR2<=VAR3[VAR1].VAR6);
VAR8.transfer(msg.value);
VAR3[VAR1].VAR7 += VAR2;
VAR9[msg.sender][VAR1] += VAR2;
emit FUN3(msg.sender, VAR1, VAR2);
}

0
---------------------------------
0x035df12e0f3ac6671126525f1015e47d79dfeddf.sol
function () public payable {
revert();
}

0
---------------------------------
0x035f99A181146219b396A69a422f7722b2c16400.sol
function FUN1(address payable VAR1) external onlyOwner {
VAR1.transfer(address(this).VAR2);
}

0
---------------------------------
0x035fb9efa7ed40a688044af22282fb19b64b5f60.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x0363611917dd6392baadb311686adfe77fe6b2f3.sol
function () external payable {
FUN1();
}
function FUN1() public onlyWhileOpen payable {
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3;
if(FUN3()){
VAR3 = VAR2.FUN4(VAR4.FUN5(VAR4.FUN4(30).FUN6(100)));
VAR5 = VAR5.FUN5(VAR2);
VAR6.transfer(VAR2);
}
else {
VAR3 = FUN7(VAR2);
VAR7 = VAR7.FUN5(VAR2);
}
VAR8[VAR1] = VAR2;
FUN8(VAR1, VAR3);
emit FUN9(VAR1, VAR2, VAR3);
}
function FUN10(address VAR9) public onlyWhileICOOpen payable {
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN7(VAR2).FUN5(FUN11(VAR2, 2));
uint256 VAR10 = FUN11(VAR2, 3);
VAR7 = VAR7.FUN5(VAR2);
VAR8[VAR1] = VAR2;
FUN8(VAR1, VAR3);
FUN8(VAR9, VAR10);
emit FUN9(VAR1, VAR2, VAR3);
}

0
---------------------------------
0x03698a26a6af930c76ee74a66eed6649fc511e6f.sol
function FUN1(address VAR1) payable returns(bool);
function () payable {
if (FUN2(VAR2)) {
if (! FUN3(VAR2).VAR3.value(msg.value)(msg.sender)) throw;
}
else {
throw;
}
}

0
---------------------------------
0x036ba95116edf4f79d5c0da9639ed1f31b1ebcd9.sol
function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x036d80f9abe266b7c6ec0a9bd078fac3a90d4239.sol
function () public payable {
revert();
}

0
---------------------------------
0x03702910bd90cfd32f23a79e9d0d2d7f31bf51f7.sol
function() public payable {
revert();
}
constructor(address VAR1) public {
VAR2=msg.sender;
VAR3[VAR1] = VAR4;
VAR5 = VAR4;
emit Transfer(0x0, VAR1, VAR4);
}
}

0
---------------------------------
0x037213960f5fec272c05dda062c23b828de39445.sol
function() public payable {
if (FUN1()) {
FUN2();
}
else if (FUN3()) {
FUN4();
}
else {
revert();
}
}
function FUN2() VAR1 FUN5(msg.sender) whenNotPaused public payable {
require(FUN1());
require(msg.value > 0);
uint256 VAR2 = msg.value;
uint256 VAR3 = 0;
uint256 VAR4 = VAR5.FUN6(VAR2);
if (VAR4 > VAR6) {
VAR3 = VAR4.FUN7(VAR6);
VAR2 = VAR6.FUN7(VAR5);
}
VAR7[msg.sender] = VAR7[msg.sender].FUN6(VAR2);
VAR8 = VAR8.FUN6(VAR2);
VAR5 = VAR5.FUN6(VAR2);
FUN8(msg.sender, VAR2);
if (VAR3 > 0) {
msg.sender.transfer(VAR3);
}
}
function FUN4() VAR1 FUN5(msg.sender) whenNotPaused public payable {
require(FUN3());
require(msg.value > 0);
uint256 VAR2 = msg.value;
uint256 VAR3 = 0;
uint256 VAR4 = VAR5.FUN6(VAR2);
if (VAR4 > VAR6) {
VAR3 = VAR4.FUN7(VAR6);
VAR2 = VAR6.FUN7(VAR5);
}
uint256 VAR9 = VAR2.FUN9(VAR10);
if (VAR9 > VAR11) {
uint256 VAR12 = VAR11.FUN10(VAR10);
VAR3 = VAR3.FUN6(VAR2.FUN7(VAR12));
VAR9 = VAR11;
VAR2 = VAR12;
}
VAR7[msg.sender] = VAR7[msg.sender].FUN6(VAR2);
VAR13 = VAR13.FUN6(VAR9);
VAR14 = VAR14.FUN6(VAR9);
VAR11 = VAR11.FUN7(VAR9);
VAR15 = VAR15.FUN6(VAR2);
VAR5 = VAR5.FUN6(VAR2);
VAR16.FUN11(msg.sender, VAR9);
if (VAR3 > 0) {
msg.sender.transfer(VAR3);
}
}

0
---------------------------------
0x0372ddb7c5e849383252243348bbe65da456e97d.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
require(VAR3.VAR4 == VAR2);
uint256 VAR5 = value;
FUN2(VAR2, VAR5);
if (VAR5 > 0) {
VAR6[VAR2] = true;
}
value = value.FUN3(99999).FUN4(100000);
}

0
---------------------------------
0x0373bd549897b97bfdc17e9be3f576eb03916857.sol
function FUN1() payable public {
if (msg.value > 0.000001 VAR1) {
VAR2 = FUN2(VAR2, msg.value);
FUN3();
}
else {
revert();
}
}
function () payable public {
if (msg.value > 0) {
FUN1();
}
else {
FUN4(msg.sender);
}
}
}

0
---------------------------------
0x0373ead1b067793d8338ba4d21782dd082c02a00.sol
function FUN1(uint256 VAR1) external payable VAR2 {
require(VAR3 - VAR4[VAR1].VAR5 <= VAR6);
uint256 VAR7 = VAR4[VAR1].VAR8;
require(VAR7 <= msg.value);
address VAR9 = VAR10[VAR1];
uint256 VAR11 = msg.value * VAR12 / 100;
uint256 VAR13 = msg.value - VAR11;
uint256 VAR14 = VAR7 * 120 / 100;
VAR9.transfer(VAR13);
FUN2(VAR9, msg.sender, VAR1);
VAR4[VAR1].VAR5 = VAR3;
VAR4[VAR1].VAR8 = VAR14;
}
function FUN3(uint256 VAR1) external payable VAR2 {
require(VAR15[VAR1].VAR8 != 0);
uint256 VAR7 = VAR15[VAR1].VAR8;
require(msg.value >= VAR7);
FUN2(VAR16, msg.sender, VAR1);
uint256 VAR14 = VAR7 * 120 / 100;
VAR4[VAR1].VAR5 = VAR3;
VAR4[VAR1].VAR8 = VAR14;
delete VAR15[VAR1];
}

0
---------------------------------
0x0376411338c0dab5dd5e78b3d717284fa2774eb4.sol
function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2(address => uint) private VAR3;
FUN2(address => FUN2(address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x0377ea0201218c87988269097fe291ba800eb182.sol
function () public payable {
VAR1.transfer(msg.value);
FUN1(msg.sender, msg.value);
}
}

0
---------------------------------
0x0379445ca151bb3287cd5ae5dd433c9c77593026.sol
function FUN1() public view returns (uint8) {
return VAR1;
}
}
contract Degen is VAR2 {
using SafeMath for uint256;
FUN2(address => uint256) private VAR3;
FUN2(address => FUN2(address => uint256)) private VAR4;
string constant VAR5 = "";
string constant VAR6 = "";
uint8 constant VAR7 = 18;
uint256 VAR8 = 6400 * (10**18);
uint256 public VAR9 = 100;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(0x54b0b7cD5268793062E0978542166Af8e7b279F9, VAR8);
}

0
---------------------------------
0x037c51c8756a217a74e25a4f40fc7641452bc57c.sol
function() payable public {
require(VAR1 < VAR2);
require(VAR3[msg.sender].VAR4);
require(msg.value >= 0.01 VAR5);
uint256 VAR6 = VAR7.FUN1(msg.value, VAR8);
require(VAR6 <= VAR7.FUN2(VAR9.FUN3(this), VAR10));
VAR3[msg.sender].VAR11 = VAR7.FUN4(VAR3[msg.sender].VAR11, VAR6);
VAR12 = VAR7.FUN4(VAR12, msg.value);
VAR10 = VAR7.FUN4(VAR10, VAR6);
}

0
---------------------------------
0x037d67c29f19a5451c731312a4c02043143c61ca.sol
function () payable internal {
uint VAR1 = msg.value * VAR2;
uint VAR3;
VAR3 += msg.value;
require(VAR4[VAR5] >= VAR1);
require(msg.value <= 10**17);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
Transfer(VAR5, msg.sender, VAR1);
VAR5.transfer(VAR3);
}
}

0
---------------------------------
0x037fc8e71445910e1e0bbb2a0896d5e9a7485318.sol
function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
pragma VAR7 ^0.6.8;
interface VAR8 {
FUN3() external payable;

0
---------------------------------
0x03805a2347e4d0c07b7159d8f8f8f8b1482c1425.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 70000;
}
else {
VAR4 = msg.value * 50000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
0x0381e7c68a576403988336e8c6ad25409f883138.sol
function() FUN1() FUN2() FUN3(msg.value) public payable {
VAR1.EventReturns memory VAR2 = FUN4(VAR2);
uint256 VAR3 = VAR4[msg.sender];
FUN5(VAR3, 2, VAR2);
}
function FUN6(uint256 VAR5) FUN1() FUN2() FUN3(msg.value) public payable {
VAR1.EventReturns memory VAR2 = FUN4(VAR2);
uint256 VAR3 = VAR4[msg.sender];
VAR5 = FUN7(VAR5);
FUN5(VAR3, VAR5, VAR2);
}

0
---------------------------------
0x038698e3bae6b3e30d6b94202299192bfe69c692.sol
function FUN1() public onlyOwner {
FUN2(payable(VAR1));
}

0
---------------------------------
0x0386D41FfdfA1f5Bf24Ef2b19FD21683B8A1e3f5.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
contract VAR5 {
bool private VAR6;

0
---------------------------------
0x0389be0964125349c47309fa40d1f7f5f061c9d7.sol
function() payable public {
}
}

0
---------------------------------
0x038d5044c7a8e7146763524f84f8850e2805673b.sol
function() payable public {
revert();
}
}

0
---------------------------------
0x038da599a137f89f49b43cd0d561d5e159058b60.sol
function() public payable {
revert();
}
}

0
---------------------------------
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol
function FUN1() payable {
VAR1 = msg.sender;
FUN2();
}

0
---------------------------------
0x0391386dd6656fe5275a7641ecb789e856cf3998.sol
function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
address VAR3 = 0x4Ca280ce432295982Bd6b0d8946564bEe68B4Ad0;
FUN2(address => uint) private VAR4;
FUN2(address => FUN2(address => uint)) private VAR5;
uint private VAR6;

0
---------------------------------
0x039200dceb9bd2cb1da57356b1c0c7220948cfc7.sol
function() payable public {
revert();
}
enum VAR1 {
VAR2, VAR3, VAR4 }
enum VAR5 {
VAR6, VAR7, VAR8, VAR9, VAR10, VAR11, VAR12, VAR13, VAR14, VAR15, VAR16, VAR17 }
event FUN1(address VAR18, address VAR19, uint VAR20, uint VAR21, uint VAR22);

0
---------------------------------
0x0393774a6016069c2884b4e592b0104d3a185ba7.sol
function transfer(address VAR1, uint value) public returns (bool VAR2);
event Transfer(address indexed VAR3, address indexed VAR1, uint value);
event FUN1(address indexed VAR4, address indexed VAR5, uint value);
}
contract CORE20 is VAR6{
uint8 public constant VAR7 = 18;
uint256 VAR8 = 2020*10**uint256(VAR7);
string public constant VAR9 = "";
string public constant VAR10 = "";
address payable VAR11;
function () external payable {
VAR11.transfer(msg.value);
}
constructor () public payable {
VAR11 = msg.sender;
VAR12[VAR11] = VAR8;
}
}

0
---------------------------------
0x039aA54fEbe98AaaDb91aE2b1Db7aA00a82F8571.sol
function FUN1(address VAR1, uint VAR2, bytes calldata VAR3) external allowAuthorizedLogicContractsCallsOnly returns (bytes memory VAR4) {
bool VAR5;
(VAR5, VAR4) = VAR1.call.value(VAR2)(VAR3);
require(VAR5, "");
emit FUN2(msg.sender, VAR1, VAR2, VAR3);
}

0
---------------------------------
0x039edb0d0613c58f45a777ab5dbf7cafcc7de9cd.sol
function FUN1 () payable {
VAR1 = 0xF12B75857E56727c90fc473Fe18C790B364468eD;
VAR2 = 0x0e2Bec7F14F244c5D1b4Ce14f48dcDb88fB61690;
VAR3 = 90;
VAR4 = 10;
VAR5 = 300 * 1 VAR6;
VAR7 = 1509321600;
VAR8 = 1511049600;
VAR9 = 1511568000;
VAR10 = 1514678399;
VAR11 = 775000 * 1 VAR6;
VAR12 = 47225000 * 1 VAR6;
}
modifier FUN2(uint value) {
require((VAR13+VAR5.FUN3(value).FUN4(1 VAR6)+VAR5.FUN3(value).FUN4(1 VAR6).FUN3(FUN5(value).FUN4(100))) <= VAR11);
VAR14;
}
modifier FUN6(uint value) {
require((VAR13+VAR5.FUN3(value).FUN4(1 VAR6)+VAR5.FUN3(value).FUN4(1 VAR6).FUN3(FUN7(value).FUN4(100))) <= VAR12);
VAR14;
}
function() external payable {
if (VAR15 >= VAR7 && VAR15 < VAR8) {
FUN8(msg.value, msg.sender);
}
else if (VAR15 >= VAR9 && VAR15 < VAR10) {
FUN9(msg.value, msg.sender);
}
}
}

0
---------------------------------
0x039f5050de4908f9b5ddf40a4f3aa3f329086387.sol
function () payable internal {
uint VAR1 = msg.value * VAR2 ;
uint VAR3;
uint VAR4 = 0;
VAR4 = FUN1(VAR1);
VAR1 = VAR1 + VAR4;
require(VAR5[VAR6] >= VAR1);
require(msg.value > 0);
VAR3 = FUN2(VAR3, msg.value);
VAR5[msg.sender] = FUN2(VAR5[msg.sender], VAR1);
VAR5[VAR6] = FUN3(VAR5[VAR6], VAR1);
Transfer(VAR6, msg.sender, VAR1);
VAR6.transfer(VAR3);
}

0
---------------------------------
0x03a2f2eb836fdd6ef462edc65bccd358ba1f2375.sol
function() public payable {
revert();
}
}

0
---------------------------------
0x03a71d713cbcfcb27a4172117718e63f50f571a0.sol
function FUN1(address VAR1) onlyOwner public{
require(VAR1 != address(0));
emit FUN2(VAR2, VAR1);
VAR2 = VAR1;
}
}
contract ITCMoney is VAR3{
using SafeMath for uint;
string public constant VAR4 = "";
string public constant VAR5 = "";
uint32 public constant VAR6 = 18;
address payable public VAR7 = address(0);
address public constant VAR8 = 0xaEA6949B27C44562Dd446c2C44f403cF6D13a2fD;
address public constant VAR9 = 0xe0b70c54a1baa2847e210d019Bb8edc291AEA5c7;
address public constant VAR10 = 0x95E1f32981F909ce39d45bF52C9108f47e0FCc50;
uint public VAR11 = 0;
uint public VAR12 = 17000000000 * 1 VAR13;
FUN3(address => uint) VAR14;
FUN3 (address => FUN3 (address => uint)) internal VAR15;
bool public VAR16 = false;
FUN3(address => bool) internal VAR17;
uint public VAR18 = 170 * 1 VAR19;
uint private VAR20 = 0;
uint[2][] private VAR21 = [ [1538784000, 100], [1554422400, 19], [1564617600, 17], [1572566400, 0] ];
uint public VAR22 = 0;
FUN3(address => uint) VAR23;
bool public VAR24 = true;
uint[2][] private VAR25 = [ [FUN4(2000), 500], [FUN4(8000), 700], [FUN4(17000), 1000], [FUN4(50000), 1500], [FUN4(100000), 1750], [FUN4(150000), 2000], [FUN4(500000), 2500] ];
uint[2][] private VAR26 = [ [1535673600, 2000], [1535760000, 1800], [1538784000, 1500], [1541462400, 1000], [1544054400, 800], [1546732800, 600], [1549411200, 300], [1551830400, 200] ];
uint private VAR27 = 1554508800;
uint public VAR28 = 0;
event Transfer(address indexed VAR29, address indexed VAR30, uint value);
event FUN5(address indexed VAR2, address indexed VAR31, uint value);
event FUN6(address indexed VAR32, address indexed VAR1);
event FUN7();
event FUN8(address indexed VAR30);
event FUN9();
event FUN10(address indexed VAR30, uint value);
event FUN11(uint value);
event FUN12(uint VAR33, uint VAR34);
event FUN13(uint value);
event FUN14(uint VAR18);
function FUN15(address payable VAR35) onlyOwner public{
require(VAR35 != address(0));
emit FUN6(VAR7, VAR35);
VAR7 = VAR35;
}
function () external payable {
require(msg.VAR36.VAR37 == 0);
require(msg.value > 0);
require(VAR22 > 0);
uint VAR38 = (msg.value * VAR22 * 1 VAR19) / FUN16();
uint VAR39 = (msg.value * VAR22) / 10000 / 1 VAR13;
uint VAR40 = VAR23[msg.sender].FUN17(VAR39);
emit FUN10(msg.sender, VAR39);
uint VAR41 = 0;
uint VAR42 = 0;
uint VAR43 = 0;
uint VAR44 = 0;
if(VAR28 > 0){
VAR44 = VAR38.FUN18(VAR28).FUN19(10000);
}
else if(VAR45 < VAR27){
VAR41 = VAR26.VAR37;
VAR43 = 0;
for(VAR42 = 0; VAR42 < VAR41; VAR42++){
if(VAR45 >= VAR26[VAR42][0]){
VAR43 = VAR26[VAR42][1];
}
else{
break;
}
}
if(VAR43 > 0){
VAR44 = VAR38.FUN18(VAR43).FUN19(10000);
}
}
if(VAR24){
VAR41 = VAR25.VAR37;
VAR43 = 0;
for(VAR42 = 0; VAR42 < VAR41; VAR42++){
if(VAR40 >= VAR25[VAR42][0]){
VAR43 = VAR25[VAR42][1];
}
else{
break;
}
}
if(VAR43 > 0){
VAR44 = VAR44.FUN17(VAR38.FUN18(VAR43).FUN19(10000));
}
}
VAR38 = VAR38.FUN17(VAR44);
uint VAR46 = VAR38.FUN18(3).FUN19(87);
uint VAR47 = VAR38.FUN18(10).FUN19(87);
uint VAR48 = VAR38.FUN17(VAR46).FUN17(VAR47);
require(VAR48 <= VAR12);
VAR12 = VAR12.FUN20(VAR48);
VAR11 = VAR11.FUN17(VAR48);
VAR14[msg.sender] = VAR14[msg.sender].FUN17(VAR38);
VAR23[msg.sender] = VAR40;
VAR14[VAR8] = VAR14[VAR8].FUN17(VAR46);
VAR14[VAR9] = VAR14[VAR9].FUN17(VAR47);
VAR7.transfer(msg.value);
emit Transfer(address(0), msg.sender, VAR38);
emit Transfer(address(0), VAR8, VAR46);
emit Transfer(address(0), VAR9, VAR47);
}
}

0
---------------------------------
0x03a7ec8d4712a31c46cf264a4aa7d37915b07d47.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}

0
---------------------------------
0x03ac6ea89607d372675187cff3acf392f329d76f.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x03b42a5e68d5a0bc47ad52d1decf3752d6091264.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x03b9445a4f6a6d78fdc1b77c38425e7128afe212.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma solidity 0.5.13;
library VAR5 {
using Address for address;
bytes4 constant private VAR6 = bytes4(FUN2(bytes("")));
bytes4 constant private VAR7 = bytes4(FUN2(bytes("")));
bytes4 constant private VAR8 = bytes4(FUN2(bytes("")));
function FUN3(address VAR9, bytes memory VAR10, uint256 VAR11) public onlyOwner returns(bool VAR4, bytes memory VAR12) {
(VAR4, VAR12) = VAR9.call.value(VAR11)(VAR10);
emit FUN4(VAR9, VAR10, VAR11, VAR4);
}

0
---------------------------------
0x03bbeab8d41fbac2477b417b5df7cbc7d939c44a.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x03bC6CDE6be15AA7D366AFd6925FD92FF60e1768.sol
function FUN1( VAR1.Deposit storage VAR2, bytes8 VAR3, bytes memory VAR4, address payable VAR5 ) internal {
require(VAR2.FUN2(), "");
require(VAR4.VAR6 > 0, "");
VAR2.VAR7 = VAR5;
FUN3(VAR2);
uint256 VAR8 = VAR9.FUN4(VAR3).FUN5().FUN6();
uint256 VAR10 = VAR2.FUN7().FUN8(VAR8);
require(VAR10 >= VAR11.FUN9(), "");
bytes32 VAR12 = VAR13.FUN10( VAR2.VAR14, VAR2.FUN11(), VAR2.VAR15, VAR3, VAR4);
VAR2.VAR16 = VAR4;
VAR2.VAR17 = VAR10;
VAR2.VAR18 = VAR10;
VAR2.VAR19 = VAR20.VAR21;
VAR2.VAR22 = VAR12;
FUN12(VAR2, VAR12);
VAR2.FUN13();
VAR2.FUN14( VAR5, VAR12, VAR2.FUN7(), VAR4, VAR10, VAR2.VAR14);
}
function FUN15( VAR1.Deposit storage VAR2, bytes8 VAR3, bytes memory VAR4, address payable VAR23 ) public {
VAR2.VAR24.FUN16(msg.sender, VAR23, uint256(address(this)));
FUN1(VAR2, VAR3, VAR4, VAR23);
}

0
---------------------------------
0x03c302f638d6773b40af8d02b563858a49c5cc23.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x03c607ef1b416b4ec5e78bf9c05d7f75c05c19d5.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable returns (uint256){
require(VAR1 != address(0));
require(VAR2 == true);
address VAR3 = VAR4;
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN2(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN3(VAR5);
VAR8 = VAR8.FUN3(VAR6);
FUN4(VAR1, VAR6, VAR4);
FUN5(VAR1, VAR5, VAR6);
VAR3.transfer(VAR5);
return VAR6;
}

0
---------------------------------
0x03c9458cef76439365cb1b4c44ea307c8e990b81.sol
function() public payable {
emit FUN1(msg.sender, msg.value);
}

0
---------------------------------
0x03cad458791705817ac7f24fed1d2d3f5fec0f8c.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}

0
---------------------------------
0x03cc979c46b030c4abd7d4063cd075cb38cd0919.sol
function() public payable {
revert();
}
event FUN1(address indexed VAR1, uint VAR2);
event FUN2(address indexed VAR1, uint VAR2, address VAR3);
event FUN3(address indexed VAR1, uint VAR2);
event FUN4(address indexed VAR1, uint VAR2, address VAR3);
function FUN5() public payable {
FUN6(msg.value, msg.sender);
emit FUN1(msg.sender, msg.value);
}

0
---------------------------------
0x03ccebcbb831c0ad807ce43cb65c2151b5612854.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x03cd7d4706dfdb2c69efc12cabf2a9a1eb3fc981.sol
function () payable VAR1 {
FUN1(msg.sender);
}
function FUN1(address VAR2) payable {
if (msg.value == 0) {
throw;
}
uint VAR3 = FUN2(FUN3(msg.value, VAR4), 1 VAR5);
VAR6 = FUN4(VAR6, VAR3);
VAR7[VAR2] = FUN4(VAR7[VAR2], VAR3);
if (!VAR8.FUN5(msg.value)) {
throw;
}
}
string public VAR9 = "";
string public VAR10 = "";
uint public VAR11 = 0;
uint256 public VAR12 = 70000000;
uint256 public VAR13 = 130000000;
address public VAR8;

0
---------------------------------
0x03cf94938696812a3615a98cdfcf82598ef30158.sol
function FUN1 (address[] VAR1, uint[] VAR2) public payable;

0
---------------------------------
0x03cfb7e0117e7ca6536f1117ca54f5ed35b143a2.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x03d577ead53c9b7a713229c8ad966f43d8e349d7.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 1 VAR5 / 2;
uint256 VAR6 = 1 VAR5;
uint256 VAR7 = 3 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 5 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 15 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 15 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 5000e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}

0
---------------------------------
0x03dc9b46243703fa1c1f95c2693212635f742204.sol
function FUN1() payable {
}
function FUN2(address VAR1) external payable onlyMonetha VAR2 {
require(VAR1 != 0x0);
uint VAR3 = msg.value.FUN3(VAR4.FUN4(msg.value).FUN5(1000));
uint VAR5 = msg.value.FUN3(VAR3);
VAR1.transfer(VAR3);
VAR6.transfer(VAR5);
FUN6(VAR1, VAR3, VAR5);
}

0
---------------------------------
0x03e0f73a93993e5101362656af1162ed80fb54f2.sol
function () payable public {
revert();
}
function () payable public {
revert();
}
function () payable public {
revert();
}
function () payable public {
revert();
}

0
---------------------------------
0x03E48857621881eBBD986b6763C1505FF17456D9.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x03e4bdce611104289333f35c8177558b04cc99ff.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x03e53ffab44c5b60ad7f4eda5969773717007056.sol
function FUN1() payable {
VAR1 = msg.sender;
}
function FUN2() payable onlyOwner {
VAR1.transfer(this.VAR2-msg.value);
}
modifier onlyOwner {
require(msg.sender == VAR1);
VAR3;
}
}

0
---------------------------------
0x03e5793400dfb62f8eb469f4ffa84862cc1e6acc.sol
function() FUN1() public payable {
FUN2(msg.value);
}
function FUN3() external payable {
FUN2(msg.value);
}

0
---------------------------------
0x03e82c5c236da52a7f5f44d811f324ab437e151e.sol
function FUN1(address payable VAR1) public payable {
(new VAR2).value(msg.value)(VAR1);
}
}
contract VAR2 {
constructor(address payable VAR1) public payable {
FUN2(VAR1);
}
}
function FUN1(address payable VAR1) public payable {
(new VAR2).value(msg.value)(VAR1);
}
}
contract VAR2 {
constructor(address payable VAR1) public payable {
FUN2(VAR1);
}
}

0
---------------------------------
0x03e86d24c462fa6ad88568053361186e4a5af68e.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
interface VAR6 {

0
---------------------------------
0x03e8f56ad0d759bcfff960863388bfdb2efd1579.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x03eb69807f87afa5419649c7602ba5501c1c2307.sol
function () public payable {
revert();
}

0
---------------------------------
0x03ec7bb59be036870ef696a2abf124f496d6735a.sol
function () public payable {
revert();
}
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}

0
---------------------------------
0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8.sol
function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value > 2 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
bytes32 VAR4;
FUN3 (bytes32=>bool) VAR8;

0
---------------------------------
0x03f69791513022d8b67facf221b98243346df7cb.sol
function () public payable {
require(FUN1() >= 220000, "");
require((msg.value >= VAR1) && (msg.value <= VAR2));
uint VAR3 = FUN2(msg.sender);
VAR4.FUN3(FUN4(msg.sender, uint128(msg.value), uint128(msg.value * VAR3/100)));
VAR5[msg.sender] = VAR5[msg.sender] + 1;
uint VAR6 = msg.value * VAR7/100;
VAR8.transfer(VAR6);
uint VAR9 = msg.value * VAR10/100;
VAR11.transfer(VAR9);
FUN5();
}

0
---------------------------------
0x03f725ffec59473805649b621ff085dd3760bc91.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN3(address payable VAR1, uint256 VAR2) public onlyOwner {
require(VAR2 <= address(this).VAR3);
VAR1.transfer(VAR2);
}
}
contract DTWDToken is VAR5, VAR6, VAR7, VAR8 {
uint8 public VAR9 = 18;
uint256 public VAR10 = 300000000000 * (10 ** uint256(VAR9));
constructor() public FUN4("", ""){
FUN5(msg.sender, VAR10);
}

0
---------------------------------
0x03fb189560402ffdf206fa013931918a4b700185.sol
function () public payable {
revert();
}

0
---------------------------------
0x03fb52d4ee633ab0d06c833e32efdd8d388f3e6a.sol
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract BlackHole is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = "";
string constant VAR6 = "";
uint8 constant VAR7 = 18;
uint256 VAR8 = 2500000000000000000000000;
uint256 public VAR9 = 100;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(msg.sender, VAR8);
}

0
---------------------------------
0x040007b1804AD78a97F541beBeD377dcB60e4138.sol
function() external payable {
if (msg.value > 0) emit FUN1(msg.sender, msg.value);
}
constructor(address[] memory VAR1, uint VAR2) public FUN2(VAR1.VAR3, VAR2) {
for (uint VAR4 = 0; VAR4 < VAR1.VAR3; VAR4++) {
require(!VAR5[VAR1[VAR4]] && VAR1[VAR4] != address(0), "");
VAR5[VAR1[VAR4]] = true;
}
VAR6 = VAR1;
VAR7 = VAR2;
}

0
---------------------------------
0x04023aa3cee210695fa7fe237b1d8d4a91cee469.sol
function () public payable {
revert();
}

0
---------------------------------
0x0404c78F23bAbD3F62f69a077faA2406d7Ee2027.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x04050c588decfcd1e852434a52dcb1587be79fd2.sol
function () public payable {
revert();
}

0
---------------------------------
0x0405f9a93d1ccd333039b74ae7d7c003e6b6ba76.sol
function () payable external {
FUN1(msg.sender,msg.value);
}

0
---------------------------------
0x04069fd0fe1c0ed5106ad9f65f3e44d8cf3311b1.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x0407b4c4eaed35ce3c5b852bdfa1640b09eeedf4.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6();
emit FUN7(msg.sender, VAR1, VAR2, VAR3);
}

0
---------------------------------
0x04084c8780f60c02700b0a4da3724defc052ae76.sol
function() public payable {
require( msg.value > 0 );
uint VAR1 = msg.value/VAR2;
VAR3[msg.sender] += VAR1;
VAR3[VAR4] -= VAR1;
emit Transfer(0, msg.sender, VAR1);
FUN1();
}

0
---------------------------------
0x0408d7ed44de8d93a2510caef3db4ac7a4a1dfec.sol
function () external payable {
revert();
}
}
contract BundableToken is VAR1 {

0
---------------------------------
0x040d11c850fb167cddb1e4d308fe9062fddaebd1.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
0x04123a57e3d3708dbdb9a5db801ea7a11bae0292.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x04129cff7d79a652256c73b1407f34828e79a4de.sol
function FUN1() public payable returns (bool) {
if (msg.value > 0.000001 VAR1) FUN2();
else return false;
return true;
}
function () payable public {
if (msg.value > 0) FUN2();
else FUN3(msg.sender);
}
}

0
---------------------------------
0x041b820c8750276618160bc56d7463082406bb9b.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x041fe8df8b4aaa868941eb877952f17babe57da5.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}

0
---------------------------------
0x04220cb64879a6196b5d57e7f54663b7e0136b41.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
address payable public VAR5;
uint8 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
bytes32 public VAR10;
bytes32 constant public VAR11 = FUN2("");
string public VAR12;
string public VAR13;
string[]public VAR14;
string public VAR15;
bool public VAR16;
bool private VAR17;
bool public VAR18;
FUN3(address => FUN3(address => uint256)) public VAR19;
FUN3(address => uint256) public VAR20;
FUN3(address => uint256) public VAR21;
event FUN4(uint256 VAR22, string VAR23);
event FUN5(uint256 VAR22, string VAR23);
event FUN6(address indexed VAR24, address indexed VAR25, uint256 value);
event FUN7(string VAR26);
event Transfer(address indexed VAR27, address indexed VAR28, uint256 value);
event FUN8(address indexed VAR5, string VAR12);
event FUN9(uint256 VAR7, uint256 VAR29, bool VAR30, bool VAR16);
event FUN10(bool VAR18);

0
---------------------------------
0x04232C296F6847558876F0E925A24a9eD2b6A406.sol
function FUN1(address VAR1, uint256 VAR2, address VAR3, bytes memory VAR4) public {
require(FUN2(VAR3) == VAR5, "");
require(VAR2 >= FUN3(), "");
require(VAR4.VAR6 == 60, "");
address payable VAR7 = address(FUN4(VAR4.FUN5(0)));
address VAR8 = VAR4.FUN5(20);
require(VAR9[VAR8].VAR10 == address(0), "");
address VAR11 = VAR4.FUN5(40);
VAR5.FUN6(VAR1, address(this), VAR2);
VAR9[VAR8] = FUN7( VAR12.FUN8(VAR2, VAR13.VAR14, 0), VAR1, VAR7, VAR11 );
VAR15[VAR1].FUN9(VAR8);
emit FUN10(VAR8, VAR2);
}

0
---------------------------------
0x0427e00ed0cab57b7fbeab1d6213d3b8fe04f003.sol
function () external payable {
VAR1.transfer(msg.value);
FUN1(msg.sender, msg.value);
}
}

0
---------------------------------
0x0428328f26e97118b03535695c61474b604273d6.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x0428acd58dc71f7b121191b36c13db536e0ab8b4.sol
function () public payable {
require(msg.value == 0, "");
}
function () public payable {
FUN1();
}
function FUN1() public payable {
require(msg.value > 0, "");
VAR1 = VAR1.FUN2(msg.value);
emit FUN3 ( msg.sender, address(this), address(0x0), msg.value, VAR2.VAR3, VAR4.VAR5 );
}
function () external payable {
emit FUN4(msg.sender, msg.value);
}

0
---------------------------------
0x042969acfa0a586a939652612458a2387ab0073a.sol
function () payable public {
FUN1();
}
function FUN2() payable public {
FUN1();
}

0
---------------------------------
0x04299958f29fa5b8383f7bbd0c98ab86bef81363.sol
function FUN1(uint VAR1) public payable {
require(!VAR2[msg.sender].VAR3, "");
require(VAR1 > 0 && VAR1 <= VAR4, '');
require(msg.value == VAR5, '');
UserStruct memory VAR6;
VAR4++;
VAR6 = FUN2({
VAR3: true, VAR7: VAR4, VAR8: VAR1, VAR9:0 }
);
VAR2[msg.sender] = VAR6;
VAR10[VAR4]=msg.sender;
VAR2[VAR10[VAR2[msg.sender].VAR8]].VAR9=VAR2[VAR10[VAR2[msg.sender].VAR8]].VAR9+1;
FUN3(1,msg.sender);
emit FUN4(msg.sender, VAR10[VAR1], VAR11);
}

0
---------------------------------
0x042a277368cb43a70b06361e7ab7d1d0a2096b0e.sol
function FUN1() payable {
if(msg.sender == VAR1) VAR2[VAR3.VAR4] += msg.value;
}
}

0
---------------------------------
0x042ab1e1a158dc9e6cd9012d5c12a4d6f0aad734.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x042afd3869a47e2d5d42cc787d5c9e19df32185f.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x042c5509e618d901df9750772b51c8f168599877.sol
function FUN1(address VAR1, address VAR2, string[] calldata VAR3, uint256 VAR4, string[] calldata VAR5) external payable returns (bool);
}
contract VAR6 {
using SafeMath for uint256;
struct VAR7 {
string VAR8;
bool VAR9;
}
OrFeedInterface VAR10= FUN2(0x8316B082621CFedAB95bf4a44a1d4B64a6ffc336);
DyDx VAR11 = FUN3(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);
LendingPoolCore VAR12 = FUN4(0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3);
uint256 constant VAR13 = 45;
uint256 constant VAR14 = 48;
uint256 constant VAR15 = 88;
uint256 constant VAR16 = 120;
uint256 constant VAR17 = 10 ** 18;
address VAR18;
uint256 VAR19 = 2102400;
constructor() public payable {
VAR18 = msg.sender;
}
function FUN1(address VAR1, address VAR2, string[] calldata VAR3, uint256 VAR4, string[] calldata VAR5) external payable returns (bool);
}
contract VAR6 {
using SafeMath for uint256;
struct VAR7 {
string VAR8;
bool VAR9;
}
OrFeedInterface VAR10= FUN2(0x8316B082621CFedAB95bf4a44a1d4B64a6ffc336);
DyDx VAR11 = FUN3(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);
LendingPoolCore VAR12 = FUN4(0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3);
uint256 constant VAR13 = 45;
uint256 constant VAR14 = 48;
uint256 constant VAR15 = 88;
uint256 constant VAR16 = 120;
uint256 constant VAR17 = 10 ** 18;
address VAR18;
uint256 VAR19 = 2102400;
constructor() public payable {
VAR18 = msg.sender;
}

0
---------------------------------
0x0433c529bb7fa84f18dfe49f0234c6815bd441fa.sol
function FUN1(string VAR1, uint256 VAR2, bool VAR3) FUN2() public payable {
require (msg.value >= VAR4, "");
bytes32 VAR5 = VAR6.FUN3(VAR1);
address VAR7 = msg.sender;
bool VAR8 = FUN4(VAR7);
uint256 VAR9 = VAR10[VAR7];
if (VAR2 != 0 && VAR2 != VAR11[VAR9].VAR12 && VAR2 != VAR9) {
VAR11[VAR9].VAR12 = VAR2;
}
else if (VAR2 == VAR9) {
VAR2 = 0;
}
FUN5(VAR9, VAR7, VAR2, VAR5, VAR8, VAR3);
}

0
---------------------------------
0x04355cc59b514a68cf0248df5312bbcb3e709fb3.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol
function FUN1() public payable {
VAR1[msg.sender] = FUN2(msg.value, VAR2 = FUN3(msg.value, 0), VAR3.FUN4(VAR4 = msg.sender));
FUN5(VAR5 = VAR6 = VAR7, msg.sender, msg.value, VAR2);
}
function () public payable {
FUN6();
}
function FUN6() public payable returns (uint) {
uint value = msg.value;
uint VAR8 = FUN3(value, (VAR7 - VAR5) / 1 VAR9);
if (VAR8 > 0) {
for (uint VAR10 = VAR3.VAR11; VAR10 > 0; VAR10--) {
Record storage VAR12 = VAR1[VAR3[VAR10 - 1]];
VAR12.VAR13 += value * VAR12.VAR8 / VAR2;
}
address VAR14 = msg.sender;
VAR12 = VAR1[VAR14];
if (VAR12.VAR15 > 0) {
VAR12.VAR8 += VAR8;
}
else {
VAR12.VAR8 = VAR8;
VAR12.VAR15 = VAR3.FUN4(VAR14);
}
VAR2 += VAR8;
FUN5(VAR6 = VAR7, VAR14, value, VAR8);
}
return VAR8;
}

0
---------------------------------
0x04392398673e6247ba7b781029c4ab2aad9efc28.sol
function FUN1() payable{
VAR1 = 0x87b0de512502f3e86fd22654b72a640c8e0f59cc;
VAR2 = 1000;
VAR3 = msg.sender;
VAR4=1496251740;
VAR5=1499880540;
VAR6=2000000000000000;
VAR7=1000000000000000;
VAR8=200;
VAR9=0;
VAR10.FUN2(6045);
VAR11=1;
uint16 VAR12 = VAR8;
for(uint VAR13 = 0; VAR13 < VAR10.VAR14; VAR13++) {
VAR12 += VAR10[VAR13];
}
if(VAR12>10000) throw;
else if(VAR12 < 10000 && VAR11 == 0) throw;
}
function FUN3() payable {
if(msg.value < VAR6) throw;
else if (VAR15 >= VAR4) throw;
else if (VAR16[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else {
VAR19.FUN2(msg.sender);
VAR16[msg.sender]=true;
if(VAR20.VAR14 < VAR10.VAR14) VAR20.FUN2(msg.sender);
}
}
function FUN4(address VAR21) payable{
if(msg.value < VAR7) throw;
else if(VAR15 < VAR4 || VAR15 >=VAR5) throw;
else if(VAR22[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else if(!VAR16[VAR21]) throw;
else{
VAR23.FUN2(msg.sender);
VAR22[msg.sender] = true;
VAR24[VAR21]++;
for(var VAR13 = 0; VAR13 < VAR20.VAR14; VAR13++){
if(VAR20[VAR13]==VAR21) break;
if(VAR24[VAR21]>VAR24[VAR20[VAR13]]){
for(var VAR25 = FUN5(VAR21, VAR13+1); VAR25>VAR13; VAR25--){
VAR20[VAR25]=VAR20[VAR25-1];
}
VAR20[VAR13]=VAR21;
break;
}
}
}
}

0
---------------------------------
0x043a0f6f167c81d6bc22066c0525fe88a2da3c5a.sol
function() payable public {
require(!VAR1);
require(VAR2 == msg.value);
require(VAR3 == msg.sender);
require(VAR4 <= VAR5);
uint256 VAR6 = msg.value.FUN1(VAR7);
VAR8 = VAR8.FUN2(VAR6);
VAR9 = VAR9.FUN2(VAR6.FUN3(1 VAR10));
VAR1 = true;
VAR11.transfer(msg.value);
FUN4(msg.sender, VAR6, VAR7);
}

0
---------------------------------
0x043aabf85dc6955b0e4a9c9a83864889f6599f16.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x043bbf1af93df1220dacc94b9ca58b789bf20dc3.sol
function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4) public payable;

0
---------------------------------
0x043bef377cb396756d177fda57f1ff941959a0cd.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
0x043d032c3fa1b0afd0238f09b9681c959f3a42a2.sol
function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x043ecb56497230946fc1a22d1e3eaef2cc659366.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x0441bd48ab53e0a1d5a2a3bad522377301bf6cc2.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0441db9fbcc1686e39bcebd24b49aef259179e4e.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
0x044324535936ede7d3971f21a393841f7a00cadb.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x0444113cad736b6452c824c642fed8a4df1c4a34.sol
function FUN1(uint VAR1, string memory VAR2) public payable {
require(VAR3[VAR1].VAR4);
require(msg.value==VAR3[VAR1].VAR5+VAR3[VAR1].VAR6);
VAR7[VAR1].FUN2(FUN3( msg.sender, VAR2, false, false, "", "" ));
VAR3[VAR1].VAR8.transfer(VAR3[VAR1].VAR5);
emit FUN4(VAR1, VAR2);
}

0
---------------------------------
0x044a4C29dcAD5FE3DA932155F949FC0564F8fCae.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x044b82c8b84a4d8feafc5dec914c363a7ea1b8d5.sol
function () public payable {
revert();
}

0
---------------------------------
0x044dad5c0da888c93d8244261b67bd431b47ca14.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
interface VAR5 {
function FUN2() onlyOwner public{
(bool VAR6, ) = msg.sender.call.value(address(this).VAR3)("");
require(VAR6, "");
}
}

0
---------------------------------
0x044deaa1e5a8593adcead599e8d66fb5d3f677b5.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x044ed85880c7df6c1491b140e46af893e0b30b77.sol
function FUN1(IERC20 VAR1, uint256 VAR2, IERC20 VAR3, address VAR4, uint256 VAR5, uint256 VAR6, bytes memory VAR7) public nonReentrant payable returns(uint256) {
if (address(VAR1) != VAR8) {
require(msg.value == 0);
VAR1.FUN2(msg.sender, address(this), VAR2);
VAR1.FUN3(address(VAR9), VAR2);
}
uint256 VAR10 = VAR9.VAR11.value((address(VAR1) == VAR8) ? VAR2 : 0)(VAR1, VAR2, VAR3, address(this), ~uint256(0), VAR5, VAR12.FUN4());
require(VAR10 >= VAR6);
if (address(VAR3) != VAR8) VAR3.FUN3(VAR4, VAR10);
(bool VAR13, ) = VAR4.call.value((address(VAR3) == VAR8) ? VAR10 : 0)(VAR7);
require(VAR13, "");
uint256 VAR14 = (address(VAR3) == VAR8) ? address(this).VAR15 : VAR3.FUN5(address(this), VAR4);
(VAR14 > 0 && address(VAR3) == VAR8) ? msg.sender.transfer(VAR14) : VAR3.FUN6(msg.sender, VAR14);
emit FUN7(VAR1, VAR2, VAR3, VAR4, VAR10.FUN8(VAR14));
return VAR10.FUN8(VAR14);
}
}

0
---------------------------------
0x0452dd090288a5197cb4c375611b70bcfa5eb18c.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns(uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address payable internal VAR5;
address payable internal VAR6;
address payable internal VAR7;
address payable internal VAR8;
modifier onlyOwner {
require(VAR5 == msg.sender);
VAR9;
}

0
---------------------------------
0x0453965956b6afbf5e758f16713dc5c0e114275f.sol
function() public payable {
uint VAR1 = msg.value/VAR2;
VAR3[msg.sender]+=VAR1;
Transfer(0,msg.sender,VAR1);
}

0
---------------------------------
0x04562d368e202f7e9470f3e238e92c2582c8dcec.sol
function FUN1(address VAR1) public payable {
require(msg.value >= 0.01 VAR2);
if(FUN2(msg.sender) > 0){
uint256 VAR3 = FUN2(msg.sender);
VAR4[msg.sender] = VAR5;
msg.sender.transfer(VAR3);
}
uint256 VAR6 = msg.value;
uint256 VAR7 = VAR8.FUN3(VAR6, 10);
if(VAR1 != msg.sender && VAR1 != 0x1 && VAR1 != VAR9 && VAR1 != VAR10){
VAR11[VAR1] = VAR8.FUN4(VAR11[VAR1], VAR7);
}
VAR11[VAR9] = VAR8.FUN3(VAR6, 40);
VAR11[VAR10] = VAR8.FUN3(VAR6, 40);
VAR12[msg.sender] = VAR8.FUN4(VAR12[msg.sender], VAR6);
VAR4[msg.sender] = VAR5;
}

0
---------------------------------
0x045b1dd8dcb653e57ff8542f8bc6a972970e0944.sol
function () payable internal {
uint VAR1 = msg.value * VAR2;
uint VAR3;
VAR3 += msg.value;
require(VAR4[VAR5] >= VAR1);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
Transfer(VAR5, msg.sender, VAR1);
VAR5.transfer(VAR3);
}
}

0
---------------------------------
0x045fbc16f17f202ad3adb5ab06d486d9fbc0f10c.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
0x0461c4e4b916bfc9449f853c7a854033b43c3a6c.sol
function FUN1(address VAR1, address VAR2, uint VAR3) public returns (bool) {
if (VAR1 != msg.sender && VAR4[VAR1][msg.sender] != uint(-1)) {
VAR4[VAR1][msg.sender] = VAR4[VAR1][msg.sender].FUN2(VAR3);
}
VAR5[VAR1] = VAR5[VAR1].FUN2(VAR3);
VAR5[VAR2] = VAR5[VAR2].FUN3(VAR3);
emit Transfer(VAR1, VAR2, VAR3);
return true;
}
}
pragma VAR6 ^0.6.12;
contract VAR7 {
string public VAR8 = "";
string public VAR9 = "";
uint8 public VAR10 = 18;
event FUN4(address indexed VAR1, address indexed VAR11, uint VAR3);
event Transfer(address indexed VAR1, address indexed VAR2, uint VAR3);
event FUN5(address indexed VAR2, uint VAR3);
event FUN6(address indexed VAR1, uint VAR3);
FUN7 (address => uint) public VAR5;
FUN7 (address => FUN7 (address => uint)) public VAR4;
FUN8() external payable {
FUN9();
}

0
---------------------------------
0x0461f8c84a87083436256f1bda7f54a5c56fb5d1.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require( VAR4, "" );
}
function FUN2( address VAR5, bytes memory VAR6, uint256 VAR7, string memory VAR8 ) private returns (bytes VAR9) {
require(FUN3(VAR5), "");
(bool VAR4, bytes memory VAR10) = VAR5.call.value(VAR7)( VAR6 );
if (VAR4) {
return VAR10;
}
else {
if (VAR10.VAR11 > 0) {
VAR12 {
let VAR13 := FUN4(VAR10) revert(FUN5(32, VAR10), VAR13) }
}
else {
revert(VAR8);
}
}
}
}
pragma VAR14 ^0.5.15;
library VAR15 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0463d394d383f8e56561120ff00834fef8a5afac.sol
function FUN1(uint256 VAR1, uint8 VAR2) external;
}
contract FixMarketPlace is VAR3, VAR4 {
using SafeMath for uint256;
DragonsETH public VAR5;
address payable VAR6;
uint256 public VAR7 = 50;
FUN2(uint256 => address payable) public VAR8;
FUN2(uint256 => uint256) public VAR9;
FUN2(uint256 => uint256) public VAR10;
FUN2(address => uint256) public VAR11;
FUN2(uint256 => uint256) public VAR12;
uint256[] public VAR13;
event FUN3(address indexed VAR14, address indexed VAR15, uint256 VAR16, uint256 VAR17);
event FUN4(address indexed VAR14, uint256 VAR16, uint256 VAR17);
event FUN5(address indexed VAR14, uint256 VAR16, uint256 VAR17);
constructor(address payable VAR18, address VAR19) public {
VAR6 = VAR18;
VAR5 = FUN6(VAR19);
}

0
---------------------------------
0x04666cdf77621dbee1b21988739dd3c12620a719.sol
function FUN1(bytes32 VAR1) payable returns(bool);
function FUN2(bytes32 VAR2) onlyAdmin payable {
require(!VAR3);
uint VAR4 = VAR5.FUN3();
VAR6 = VAR2;
VAR5.VAR7.value(VAR4)(VAR2);
VAR3 = true;
}
function() payable public {
uint VAR8 = FUN4(msg.sender);
FUN5(msg.sender, VAR8 + msg.value);
VAR9.FUN6(msg.value * VAR10 / 100);
VAR11.FUN6(this.VAR12);
emit FUN7(msg.sender, msg.value);
}

0
---------------------------------
0x046ec9bb312c51425f7a00b2ab7525afe7db52e6.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
0x04705b497c48df4f863b313722a82c51d2167abb.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x0470c8c6546e4eb668aead38dc024ec6ab48980e.sol
function FUN1(uint256 VAR1) public payable {
address VAR2 = VAR3[VAR1];
address VAR4 = msg.sender;
uint256 VAR5 = VAR6[VAR1];
require(VAR2 != VAR4);
require(FUN2(VAR4));
require(msg.value >= VAR5);
uint256 VAR7 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 5), 100));
uint256 VAR9 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 5), 100));
uint256 VAR10 = VAR5 - VAR7 - VAR7 - VAR9 - VAR9;
uint256 VAR11 = VAR8.FUN5(msg.value,VAR5);
if (VAR5 < VAR12) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 200), 100);
}
else if (VAR5 < VAR13) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 180), 100);
}
else {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 150), 100);
}
FUN6(VAR2, VAR4, VAR1);
FUN7(VAR1, VAR5, VAR6[VAR1], VAR2, VAR4, VAR14[VAR1].VAR15);
if (VAR2 != address(this)) {
VAR2.transfer(VAR10);
}
msg.sender.transfer(VAR11);
FUN8(VAR7, VAR9, VAR1);
}

0
---------------------------------
0x047187e53477be70dbe8ea5b799318f2e165052f.sol
function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) throw;
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}

0
---------------------------------
0x0472e3ccb2a3601b39880fb1059b466aa6151662.sol
function() external payable {
}
function FUN1() public payable {
if (msg.value >= address(this).VAR1) msg.sender.transfer(address(this).VAR1);
}
}

0
---------------------------------
0x0475675085484498c003fc02fd58bb34a8397484.sol
function FUN1(uint VAR1, uint VAR2, uint VAR3, uint VAR4) external view returns (uint);
}
pragma VAR5 ^0.5.16;
contract VAR6 {
bool internal VAR7;
string public VAR8;
string public VAR9;
uint8 public VAR10;
uint internal constant VAR11 = 0.0005e16;
uint internal constant VAR12 = 1e18;
address payable public VAR13;
address payable public VAR14;
ControllerInterface public VAR15;
InterestRateModel public VAR16;
uint internal VAR17;
uint public VAR4;
uint public VAR18;
uint public VAR19;
uint public VAR20;
uint public VAR21;
uint public VAR22;
FUN2 (address => uint) internal VAR23;
FUN2 (address => FUN2 (address => uint)) internal VAR24;
struct VAR25 {
uint VAR26;
uint VAR27;
}
FUN2(address => VAR25) internal VAR28;
}
contract ATokenInterface is VAR6 {
bool public constant VAR29 = true;
event FUN3(uint VAR30, uint VAR31, uint VAR19, uint VAR20);
event FUN4(address VAR32, uint VAR33, uint VAR34);
event FUN5(address VAR35, uint VAR36, uint VAR37);
event FUN6(address VAR38, uint VAR39, uint VAR28, uint VAR20);
event FUN7(address VAR40, address VAR38, uint VAR41, uint VAR28, uint VAR20);
event FUN8(address VAR42, address VAR38, uint VAR41, address VAR43, uint VAR44);
event FUN9(address VAR45, address VAR46);
event FUN10(address VAR47, address VAR48);
event FUN11(ControllerInterface VAR49, ControllerInterface VAR50);
event FUN12(InterestRateModel VAR51, InterestRateModel VAR52);
event FUN13(uint VAR53, uint VAR54);
event FUN14(address VAR55, uint VAR56, uint VAR57);
event FUN15(address VAR13, uint VAR58, uint VAR57);
event Transfer(address indexed VAR59, address indexed VAR60, uint VAR61);
event FUN16(address indexed VAR62, address indexed VAR63, uint VAR61);
event FUN17(uint VAR64, uint VAR65, uint VAR66);

0
---------------------------------
0x0475cad90f0e134969aecd27dfdc8c02b6ec0026.sol
function() payable public {
address VAR1 = msg.sender;
require(msg.value >= 0);
if(msg.value == 0){
require(!FUN1(VAR1));
FUN2(VAR1);
}
else{
FUN3(VAR1);
}
}

0
---------------------------------
0x0475db744818f6f1a7224886a1b4927670790924.sol
function() payable public {
if (VAR1 == msg.sender) {
return;
}
if (0 == msg.value) {
FUN1();
return;
}
require(false == VAR2, "");
require(msg.value >= VAR3, "");
Investor storage VAR4 = VAR5[msg.sender];
if (VAR4.VAR6 == 0) {
msg.sender.transfer(0 VAR7);
VAR8.FUN2(msg.sender);
VAR4.VAR6 = VAR8.VAR9;
VAR4.VAR10 = VAR11;
address VAR12 = FUN3(msg.VAR13);
if (VAR5[VAR12].VAR14 > 0 && VAR12 != msg.sender) {
VAR4.VAR12 = VAR12;
}
}
else {
FUN1();
}
VAR4.VAR14 += msg.value;
VAR4.VAR15 += 1;
emit FUN4(msg.sender, msg.value, VAR4.VAR12);
VAR16 += msg.value;
VAR17 = VAR11;
VAR18.transfer(msg.value / 5);
uint VAR19 = (msg.value / 100) * VAR20;
if (VAR4.VAR12 > 0x0) {
if (VAR4.VAR12.FUN5(VAR19)) {
emit FUN6(VAR4.VAR12, VAR19, "", msg.sender);
}
if (VAR4.VAR15 == 1) {
if (msg.sender.FUN5(VAR19)) {
emit FUN6(msg.sender, VAR19, "", 0);
}
}
}
else if (VAR21.VAR22 > 0x0) {
if (VAR21.VAR22.FUN5(VAR19)) {
emit FUN6(VAR21.VAR22, VAR19, "", msg.sender);
}
}
if (VAR4.VAR14 > VAR21.VAR14) {
VAR21 = FUN7(msg.sender, VAR4.VAR14);
emit FUN8(msg.sender, VAR4.VAR14);
}
}

0
---------------------------------
0x047686fb287e7263a23873dea66b4501015a2226.sol
function FUN1( uint40 VAR1, uint256 VAR2, address VAR3 ) public payable;
function FUN2( uint40 VAR1, uint256 VAR2, address VAR4 ) external payable;
function () payable public {
revert();
}

0
---------------------------------
0x0477b3b746F99010D255F6556444039e2e58864e.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x04797c1ae852a31665d8e512ddae33e6044ef39d.sol
function FUN1(uint VAR1, string VAR2) public returns (uint VAR3) {
address VAR4 = msg.sender;
uint VAR5 = FUN2();
uint VAR6 = address(this).VAR7;
uint VAR8 = VAR6 > VAR5 ? VAR6 - VAR5 : 0;
if (VAR1 > VAR8) VAR1 = VAR8;
VAR1 = VAR9.FUN3(VAR4, VAR1);
VAR10 = VAR9.FUN4();
if (VAR1 == 0) return;
bytes4 VAR11 = bytes4(FUN5(VAR2));
require(VAR4.call.value(VAR1)(VAR11));
emit FUN6(VAR12, VAR4, VAR1, VAR10);
return VAR1;
}
function FUN7() public returns (uint VAR13) {
int VAR14 = FUN8();
if (VAR14 <= 0) return;
VAR13 = uint(VAR14);
VAR15 += VAR13;
address VAR16 = FUN9();
require(VAR16.call.value(VAR13)());
emit FUN10(VAR12, VAR16, VAR13);
}
function FUN11(User memory VAR17, Stats memory VAR18) private {
assert(VAR17.VAR19 != FUN12(VAR20.VAR21));
assert(VAR17.VAR19 != 0);
uint8 VAR22 = FUN13(VAR17.VAR19, VAR17.VAR23);
bool VAR24 = VAR22 <= VAR17.VAR25;
if (VAR24) {
require(msg.sender.call.value(VAR17.VAR26)());
VAR18.VAR27 += VAR17.VAR26;
}
emit FUN14(VAR12, VAR17.VAR23, msg.sender, VAR22, VAR24 ? VAR17.VAR26 : 0);
}
function FUN15(string VAR28, uint VAR29, uint8 VAR30) private {
require(msg.sender.call.value(msg.value)());
emit FUN16(VAR12, msg.sender, VAR28, VAR29, VAR30);
}

0
---------------------------------
0x04798662a6938772e5d2e006aa10a5f2b2ae9869.sol
function FUN1() public payable {
VAR1.FUN2(FUN3('','',0));
}
struct VAR2 {
string VAR3;
string VAR4;
bytes32 VAR5;
}
event FUN4(uint256 VAR6, string VAR3, string VAR4, bytes32 VAR5);
string public constant VAR7 = '';
string public constant VAR8 = '';
string public constant VAR9 = '';
VAR2[] public VAR1;
FUN5 (bytes32 => uint256) VAR10;
FUN5 (bytes32 => uint256) VAR11;
FUN5 (bytes32 => uint256) VAR12;

0
---------------------------------
0x047a2c85394dd7f475027fc2bf1753babb454094.sol
function FUN1(address VAR1, bytes VAR2) external payable onlyOwner returns (bool) {
return VAR1.call.value(msg.value)(VAR2);
}
}
contract ERC1003Token is VAR3 {
ERC1003Caller public VAR4 = VAR5 FUN2();
address[] internal VAR6;

0
---------------------------------
0x047a68fc8aaa9109346c726c696986f4b5792658.sol
function FUN1( uint24 VAR1, uint VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6, uint VAR7, uint VAR8, bytes32 VAR9, bytes32 VAR10 ) external payable {
require (VAR11, "");
require (VAR2 + VAR3 + VAR4 + VAR5 + VAR6 == msg.value, "");
Game storage VAR12 = VAR13[VAR8];
require (VAR12.VAR14 == address(0), "");
require (VAR15.VAR16 <= VAR7, "");
bytes32 VAR17 = FUN2(VAR18.FUN3(FUN4(VAR7), VAR8));
require (VAR19 == FUN5(VAR17, 27, VAR9, VAR10), "");
FUN6( VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, 1 );
VAR12.VAR20 = FUN4(VAR15.VAR16);
VAR12.VAR21 = FUN7(VAR1);
VAR12.VAR14 = msg.sender;
VAR12.VAR2 = VAR2;
VAR12.VAR3 = VAR3;
VAR12.VAR4 = VAR4;
VAR12.VAR5 = VAR5;
VAR12.VAR6 = VAR6;
}
function () public payable {
}

0
---------------------------------
0x047ba332817849e6ca0a3f9ba75060e99eafa9bb.sol
function FUN1(bytes32 VAR1, address VAR2, uint VAR3) payable public {
require(VAR4[msg.sender][VAR1].VAR5 == 0, "");
require(msg.value == VAR6, "");
require(VAR3 > 0, "");
VAR4[msg.sender][VAR1] = FUN2(VAR2, VAR3, VAR7, 0);
emit FUN3(msg.sender, VAR1, VAR2, VAR3);
}

0
---------------------------------
0x047c216ebe3fa55544e04a72264e1016531a6d6f.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x047ebd5f7431c005c9d3a59ce0675ac998417e9d.sol
function () payable external {
FUN1();
}

0
---------------------------------
0x04823640da2509874e0c65ebcf7e2050dba99bc5.sol
function () payable{
FUN1();
}
constructor() public {
VAR1 = 0xb3beac54c341adb4aa3f8480bef0a6aceb76256a;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}

0
---------------------------------
0x04830e45762f09853b398d1d03003fda7c978597.sol
function () payable {
FUN1(msg.sender);
}

0
---------------------------------
0x0485a423c0b8ff2f5aa2ec35a32d1c67a2e99b6c.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0485d2be00eda257b6e7868950616ad2a8cc44b6.sol
function FUN1() public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
require(msg.value == 0);
if (VAR4 > 0 && VAR5[msg.sender] >= VAR4) {
revert();
}
FUN2(VAR6, msg.sender, VAR7);
VAR5[msg.sender] += 1;
FUN3(msg.sender, VAR5[msg.sender], VAR7);
}
}
contract ICOToken is VAR8 {
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
address public VAR12;
address public VAR13;
event FUN4(address indexed VAR14, uint256 indexed value, uint256 VAR15);
event FUN5(address indexed VAR14, address indexed VAR16, uint256 value);
function FUN6() public payable {
require(VAR1 >= VAR10 && VAR1 <= VAR11);
uint256 VAR15 = (msg.value * VAR9 * 10 ** uint256(VAR17)) / (1 VAR18 / 1 VAR19);
if (VAR15 == 0 || VAR20[VAR12] < VAR15) {
revert();
}
FUN2(VAR12, msg.sender, VAR15);
FUN4(msg.sender, msg.value, VAR15);
}
function() public payable {
if (msg.value == 0) {
FUN1();
}
else {
FUN6();
}
}
}

0
---------------------------------
0x0486506702b47fd838f3b8ead7fc9509f012f4a7.sol
function () public payable {
require(msg.value >= 1000000000000);
require(VAR1+(msg.value*VAR2)<=VAR3);
uint VAR4;
VAR4 = msg.value*VAR2;
VAR5[msg.sender] += VAR4;
VAR1 += VAR4;
Transfer(address(0), msg.sender, VAR4);
}

0
---------------------------------
0x048694443ce5587f76d7233d0e475b14000a3f5c.sol
function() payable external {
require (msg.value == 0);
uint256 VAR1 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (!VAR3.transfer(msg.sender, VAR1)) {
revert();
}
}

0
---------------------------------
0x048717ea892f23fb0126f00640e2b18072efd9d2.sol
function FUN1() public payoutsAreActive returns (bool) {
uint VAR1 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (msg.sender.call.value(VAR1)()) {
return true;
}
else {
VAR2[msg.sender] = VAR1;
return false;
}
}

0
---------------------------------
0x0487ac46bd41f4b734e08eab479330e3bd9b6cf5.sol
function FUN1(address VAR1, uint VAR2) external onlyOwner {
VAR3 = VAR3.FUN2(VAR2);
super.FUN3(VAR1, VAR2);
}
FUN4() external payable {
uint VAR2 = msg.value;
msg.sender.transfer(VAR2);
}
}

0
---------------------------------
0x0487fc87df11933ace3c3dd98e287fd53c2109b4.sol
function () external payable {
}

0
---------------------------------
0x0488401c3f535193fa8df029d9ffe615a06e74e6.sol
function () public payable {
revert();
}

0
---------------------------------
0x0488a7b65e8a07db4642a1cbe75434b4c4524026.sol
function FUN1(address payable VAR1) public onlyOwner {
VAR2 = VAR1;
}
function FUN2(address VAR3, address VAR4) view public returns (uint256 VAR5) {
return VAR6[VAR3][VAR4];
}
}
contract MIKI is VAR7,VAR8{
uint256 public VAR9;
constructor(address VAR3) {
VAR10 = "";
VAR11 = "";
VAR12 = 18;
VAR13 = 10000000000000000000000;
VAR9 = 10000000000000000000000;
VAR14 = VAR3;
VAR15[VAR14] = VAR13;
}
FUN3() external payable {
revert();
}
}

0
---------------------------------
0x0488f94c063abff57d9fb8edba343f2e9aeeea1d.sol
function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address payable private VAR5;
event FUN2(address indexed VAR6, address indexed VAR7);

0
---------------------------------
0x048b70f7aa0466c3d1f3f3c22f32fd0689ca5cec.sol
function () payable {
if (!VAR1) throw;
if (msg.value == 0) throw;
if (VAR2.VAR3 < VAR4) throw;
if (VAR2.VAR3 > VAR5) throw;
uint256 VAR6 = FUN1(msg.value, VAR7);
if (VAR6 + VAR8 > VAR9) throw;
VAR8 = FUN2(VAR8, VAR6);
VAR10[msg.sender] += VAR6;
FUN3(msg.sender, VAR6);
}
}

0
---------------------------------
0x048f43402b2fb294f363e1d8e9f49474b9fc6af1.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x048f616fcc4dd825f4a0a3b095d2ef70046b30c3.sol
function() public payable {
if (msg.sender == VAR1) {
return;
}
FUN1();
FUN2();
FUN3();
FUN4();
FUN5();
}

0
---------------------------------
0x048fe0f263b8c3cef3f3e6b0e4f1b8cba55453cd.sol
function FUN1(address VAR1) public payable;
}
interface VAR2 {

0
---------------------------------
0x049135b904148a0cf263f064d7f7c702dd34d72e.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3, string VAR4)private returns(bool VAR5) {
require(FUN2(msg.sender) > VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4)public returns(bool VAR5) {
require(!VAR7[msg.sender]);
require(!VAR7[VAR1]);
if (FUN6(VAR1)) {
return FUN1(VAR1, VAR2, VAR3, VAR4);
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
0x049158da08568d1973dc951ec758873bf7125478.sol
function () public payable {
bytes memory VAR1;
if (msg.value == 0) {
revert();
}
uint256 VAR2 = msg.value.FUN1(VAR3);
if (VAR2 == 0) {
revert();
}
if (VAR2 > VAR4[0x0]) {
revert();
}
VAR5.transfer(msg.value);
VAR4[0x0] = VAR4[0x0].FUN2(VAR2);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
emit Transfer(0x0, msg.sender, VAR2);
emit FUN4(0x0, msg.sender, VAR2, VAR1);
emit FUN5(msg.sender, VAR2);
}
}

0
---------------------------------
0x04950c94f4cbf9b3eb7b3ddd48e6aef176e3f73f.sol
function () external payable {
address sender = msg.sender;
uint256 VAR1 = 0;
if (VAR2[sender] != 0) {
VAR1 = VAR2[sender] * VAR3 / 100 * (VAR4 - VAR5[sender]) / 1 VAR6;
if (msg.value == 0) {
if (VAR1 >= address(this).VAR7) {
VAR1 = (address(this).VAR7);
}
if ((VAR8[sender] + VAR1) > VAR2[sender] * VAR9 / 100) {
VAR1 = VAR2[sender] * VAR9 / 100 - VAR8[sender];
VAR2[sender] = 0;
VAR8[sender] = 0;
sender.transfer(VAR1);
return;
}
else {
sender.transfer(VAR1);
VAR8[sender] += VAR1;
VAR1 = 0;
}
}
}
VAR5[sender] = VAR4;
VAR2[sender] += (msg.value + VAR1);
if (msg.value != 0) {
VAR10.transfer(msg.value * VAR11 / 100);
if (VAR2[sender] > VAR2[VAR10]) {
VAR10 = sender;
}
}
}

0
---------------------------------
0x0496d94ef879de321cb968be9f356c51fad024e0.sol
function () external payable {
address VAR1 = VAR2;
VAR3 {
let VAR4 := FUN1(0x40) FUN2(VAR4, 0, VAR5) let VAR6 := FUN3(VAR7, VAR1, VAR4, VAR5, 0, 0) let VAR8 := VAR9 FUN4(VAR4, 0, VAR8) switch result case 0 {
revert(VAR4, VAR8) }
default {
return(VAR4, VAR8) }
}
}
}

0
---------------------------------
0x04986b3ea83b0f5d628e216f77f03cb691f5c3dd.sol
function() external payable {
FUN1();
}
function FUN1() public payable {
uint256 VAR1;
uint256 VAR2 = VAR3.FUN2(msg.sender);
require(VAR2 > 0);
if (FUN3(VAR4, VAR5)) {
uint256 VAR6 = VAR3.FUN4(msg.sender, VAR2.FUN5(1));
uint256 VAR7 = uint(VAR3.FUN6(VAR6, 0));
require(VAR7 > 1);
require(msg.value >= VAR8);
VAR1 = FUN7(msg.value, VAR9);
require(VAR1 <= VAR10);
}
else if (FUN3(VAR5, VAR11)) {
VAR1 = FUN7(msg.value, VAR12);
}
else if (FUN3(VAR11, VAR13)) {
VAR1 = FUN7(msg.value, uint256(0));
}
else {
revert("");
}
require(VAR14.FUN8(VAR1) <= VAR15);
VAR14 = VAR14.FUN8(VAR1);
VAR16.transfer(msg.value);
require(VAR17.FUN9(VAR17.FUN10(), msg.sender, VAR1));
emit FUN11(msg.sender, msg.sender, msg.value, VAR1);
}

0
---------------------------------
0x049a0b974add339d04565f6e407edfdd95218d3e.sol
function FUN1(uint256 VAR1) FUN2() FUN3() FUN4() public payable {
uint256 VAR2 = 0;
if(VAR1 == 1 || VAR1 == 2){
if(VAR3 < VAR4[VAR5].VAR6){
VAR2 = FUN5(VAR1);
VAR4[VAR5].VAR7 = VAR4[VAR5].VAR7.FUN6((VAR2.FUN7(VAR7)).FUN8(100));
}
else if(VAR3 >= VAR4[VAR5].VAR6){
FUN9();
VAR2 = FUN5(VAR1);
VAR4[VAR5].VAR7 = VAR4[VAR5].VAR7.FUN6((VAR2.FUN7(VAR7)).FUN8(100));
}
}
else {
msg.sender.transfer(msg.value);
}
}
function FUN1(uint256 VAR1, address VAR8) FUN2() FUN3() FUN4() public payable {
uint256 VAR2 = 0;
if(VAR1 == 1 || VAR1 == 2){
if(VAR3 < VAR4[VAR5].VAR6){
VAR2 = FUN5(VAR1);
FUN10(VAR2, VAR8);
}
else if(VAR3 >= VAR4[VAR5].VAR6){
FUN9();
VAR2 = FUN5(VAR1);
FUN10(VAR2, VAR8);
}
}
else {
msg.sender.transfer(msg.value);
}
}

0
---------------------------------
0x049d6c8a9592e29884801a7aafb0f7ac66a7e22c.sol
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract LOKI is VAR2 {
using SafeMath for uint256;
uint256 public VAR3 = 0;
FUN2 (address => uint256) private VAR4;
FUN2 (address => FUN2 (address => uint256)) private VAR5;
FUN2 (address => bool) public VAR6;
string constant VAR7 = "";
string constant VAR8 = "";
uint8 constant VAR9 = 18;
uint256 VAR10 = 100000*10**uint(VAR9);
IERC20 VAR11 ;
address payable public VAR12;
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
address VAR14 = 0x49A6ca6e8Aa682c9d108767711E11B73056B879c;
constructor() public payable FUN3(VAR7, VAR8, VAR9) {
FUN4(VAR14, VAR10);
VAR12 = msg.sender;
}
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract LOKI is VAR2 {
using SafeMath for uint256;
uint256 public VAR3 = 0;
FUN2 (address => uint256) private VAR4;
FUN2 (address => FUN2 (address => uint256)) private VAR5;
FUN2 (address => bool) public VAR6;
string constant VAR7 = "";
string constant VAR8 = "";
uint8 constant VAR9 = 18;
uint256 VAR10 = 100000*10**uint(VAR9);
IERC20 VAR11 ;
address payable public VAR12;
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
address VAR14 = 0x49A6ca6e8Aa682c9d108767711E11B73056B879c;
constructor() public payable FUN3(VAR7, VAR8, VAR9) {
FUN4(VAR14, VAR10);
VAR12 = msg.sender;
}

0
---------------------------------
0x049e6eb92fc1ca6bc6eca9f34ab43a9ad28d014b.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x04a2045f76e890a6430b5fa66ab2b3bac59ce51c.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x04a28b7b45db608cc9dcc2dd247ede17164849f8.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
0x04a487afd662c4f9deacc07a7b10cfb686b682a4.sol
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool);
function FUN2() public payable;
function() public payable {
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool) {
require(VAR7);
require(msg.sender == VAR8);
require(FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6));
return true;
}
event FUN4(bool VAR9);

0
---------------------------------
0x04a4b43352a78294bc7b6d520450825ac639ea21.sol
function FUN1() payable public {
uint VAR1 = msg.value * VAR2;
FUN2(this, msg.sender, VAR1);
}
function FUN1() public payable {
FUN3(msg.sender);
}
function() payable {
FUN1();
}

0
---------------------------------
0x04a6e67d14715dd0e267b35805fea24fd0b5f70b.sol
function () public payable {
require(VAR1 != VAR2.VAR3);
require(!VAR4 && msg.sender != VAR5);
if( VAR1 == VAR2.VAR6 && VAR7 <= VAR8 ) {
require (VAR9 <= 1500 VAR10);
VAR9 = (VAR9).FUN1(msg.value);
VAR11 =((msg.value).FUN2(VAR12));
VAR13 = ((VAR11).FUN2(58)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR1 == VAR2.VAR15 && VAR7 <= VAR16 ){
if( VAR7 < VAR17 ) {
VAR11 =(msg.value).FUN2(VAR18);
VAR13 = ((VAR11).FUN2(15)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR7 >= VAR17 && VAR7 < VAR19) {
VAR11 =(msg.value).FUN2(VAR18);
VAR13 = ((VAR11).FUN2(10)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR7 >= VAR19 && VAR7 < VAR20) {
VAR11 =(msg.value).FUN2(VAR18);
VAR13 = ((VAR11).FUN2(5)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR7 >= VAR20 && VAR7 < VAR16) {
VAR11 =(msg.value).FUN2(VAR18);
VAR14 = VAR11;
FUN4(msg.sender,VAR14);
}
}
else {
revert();
}
}

0
---------------------------------
0x04a734a6c3e415fff3149f0cb5f4719554974cc2.sol
function FUN1() external payable;

0
---------------------------------
0x04a84b5368c9006ed05e837f8132e9f1c0287482.sol
function() external payable {
FUN1();
}

0
---------------------------------
0x04aa51bbcb46541455ccf1b8bef2ebc5d3787ec9.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x04adfd46590db157a20d88e6d10b783617aadb7e.sol
function FUN1(address VAR1, uint256 VAR2, address VAR3, bytes memory VAR4) public;
}
contract VAR5 {
address public VAR6;
address public VAR7;
event FUN2(address indexed VAR8, address indexed VAR9);
constructor() public {
VAR6 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR6);
VAR10;
}
}
contract PRESALE is VAR5{
using SafeMath for uint;
ERC20Interface public VAR3;
uint256 public VAR11;
address VAR12;
uint256 public VAR13;
uint public VAR14;
address payable VAR15;
constructor(ERC20Interface VAR16) public {
VAR3 = VAR16;
VAR6 = msg.sender;
}
function FUN3(address VAR17, uint VAR18, address payable VAR19) public onlyOwner{
VAR12 = VAR17;
VAR14 = VAR18*10**18;
VAR15 = VAR19;
}
function () external payable {
require(VAR12 != 0x0000000000000000000000000000000000000000, "");
require(msg.value <= 10 VAR20, "");
require(msg.value != 0 VAR20, "");
uint VAR21 = msg.value;
VAR11 = (VAR21 / 0.00022 VAR20)*10**18;
require(VAR3.FUN4(VAR12, address(this)) >= VAR11, "");
require(VAR3.FUN5(VAR12) >= VAR11, "");
require(VAR13 <= VAR14, "");
VAR15.transfer(msg.value);
VAR3.FUN6(VAR12, msg.sender, VAR11);
VAR13 += VAR11;
}
function FUN7() public payable{
require(VAR12 != 0x0000000000000000000000000000000000000000, "");
require(msg.value <= 10 VAR20, "");
require(msg.value != 0 VAR20, "");
uint VAR21 = msg.value;
VAR11 = (VAR21 / 0.00022 VAR20)*10**18;
require(VAR3.FUN4(VAR12, address(this)) >= VAR11, "");
require(VAR3.FUN5(VAR12) >= VAR11, "");
require(VAR13 <= VAR14, "");
VAR15.transfer(msg.value);
VAR3.FUN6(VAR12, msg.sender, VAR11);
VAR13 += VAR11;
}
}

0
---------------------------------
0x04af24e2e590c9597890924de4dcdb8c9b32df6b.sol
function () payable{
FUN1();
}
constructor() public {
VAR1 = 0xeaf03a0a94ffd66a4eaa82701323fe4cd33565c3;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}

0
---------------------------------
0x04b29d1686fd5bcfc99b95fd9159357cb3478786.sol
constructor (string memory VAR1, string memory VAR2, uint256 VAR3,address payable VAR4) public {
VAR5 = VAR1;
VAR6 = VAR2;
VAR7 = 18;
VAR8 = VAR4;
FUN1(VAR8, VAR3);
}

0
---------------------------------
0x04b710d1fc77c8e7002f539bb48feb560cb2892c.sol
function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
require(VAR4 == false, "");
VAR4 = true;
require(VAR1.call.value(VAR3)(VAR2), "");
VAR4 = false;
}
}
contract payoutAllC is VAR5 {
address private VAR6;
event FUN2(address VAR7, uint value);
constructor(address VAR8) public {
assert(VAR8 != address(0));
VAR6 = VAR8;
}
function FUN3(address VAR1, uint VAR3) internal {
FUN1(VAR1, "", VAR3);
}

0
---------------------------------
0x04baddfb21723ec467e9993b715c5e0d673bac96.sol
function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 20);
Game VAR3;
VAR3.VAR4 = msg.sender;
VAR3.VAR1 = VAR1;
VAR5.FUN2(VAR3);
if (VAR1 == VAR6) {
msg.sender.transfer(this.VAR7);
}
FUN3();
VAR8 = VAR9;
}
function() public payable {
}
}

0
---------------------------------
0x04bba664ea822924ff435ce1b3fad3e8dcc69481.sol
function FUN1() public payable;
}
pragma VAR1 ^0.4.24;
contract KingOfEthReferencer is VAR2 {
address public VAR3;
modifier FUN2() {
require(VAR3 == msg.sender);
VAR4;
}

0
---------------------------------
0x04bc0ab673d88ae9dbc9da2380cb6b79c4bca9ae.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x04bd346f40fe66303a39225bec1f28f66711582e.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x04c1fd58951e72e8eec932c2766ed97d049aeb9f.sol
function () public payable {
revert();
}

0
---------------------------------
0x04c21da065bda1f4780495693ff1b952468ee151.sol
function() public payable {
VAR1 += msg.value;
}
function FUN1(uint8 VAR2, bool VAR3, address VAR4) isActivated VAR5 FUN2(VAR4) public payable {
require(msg.value > 0);
uint256 VAR6 = msg.value;
if (VAR7[msg.sender].VAR8 == 0) {
VAR7[msg.sender].VAR9.VAR10 = 0;
}
if (VAR7[msg.sender].VAR11 == 0) {
VAR12 ++;
VAR7[msg.sender].VAR11 = VAR12;
VAR13[VAR12] = msg.sender;
}
if (VAR6 < VAR14 * VAR2 || VAR6 > VAR15 * VAR2) {
VAR1 += VAR6;
return;
}
if (VAR7[msg.sender].VAR8 > 0) {
require(VAR7[msg.sender].VAR8.FUN3(VAR16).FUN3(VAR2) >= VAR6);
}
if (VAR3 == false && VAR7[msg.sender].VAR17 > 100) {
FUN4();
VAR7[msg.sender].VAR9.VAR10 = 0;
}
if (VAR3 && VAR2 == 1) {
require( VAR7[msg.sender].VAR9.VAR10 > 0 && VAR7[msg.sender].VAR18 == false && VAR7[msg.sender].VAR19 > 0 && VAR7[msg.sender].VAR20 <= (VAR21 - 1 VAR22), '' );
VAR7[msg.sender].VAR18 = true;
VAR7[msg.sender].VAR19 --;
VAR7[msg.sender].VAR20 = VAR21;
uint16 VAR23 = VAR7[msg.sender].VAR9[VAR7[msg.sender].VAR9.VAR10 - 1];
VAR7[msg.sender].VAR17 -= VAR23;
VAR7[msg.sender].VAR9.VAR10 = VAR7[msg.sender].VAR9.VAR10 - 1;
VAR7[msg.sender].VAR9.FUN5(100 + VAR23);
}
VAR1 += VAR6.FUN6(100);
VAR24 += VAR6.FUN7(VAR6.FUN6(100));
VAR7[msg.sender].VAR8 += VAR6.FUN7(VAR6.FUN6(100));
if ( VAR7[msg.sender].VAR25 == address(0x0) && VAR4 != address(0x0) && VAR4 != msg.sender && VAR7[VAR4].VAR11 > 0 ) {
VAR7[msg.sender].VAR25 = VAR4;
}
for (uint16 VAR26 = 1; VAR26 <= VAR2; VAR26++) {
uint16 VAR27 = FUN8(VAR26);
VAR7[msg.sender].VAR9.FUN5(VAR27);
VAR7[msg.sender].VAR17 += VAR27;
}
uint16 VAR28 = FUN9();
if (VAR28 > 0) {
VAR29 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(36).FUN6(10);
if (VAR6 >= VAR31) {
VAR7[msg.sender].VAR30 += VAR24.FUN3(VAR28).FUN6(100);
}
FUN4();
return;
}
if (VAR7[msg.sender].VAR17 > 100 || VAR7[msg.sender].VAR17 == VAR32) {
VAR7[msg.sender].VAR30 = 0;
if (VAR7[msg.sender].VAR18 == false && VAR7[msg.sender].VAR19 > 0) {
return;
}
if (VAR7[msg.sender].VAR17 == VAR32) {
VAR33++;
}
else {
VAR34 ++;
}
uint VAR35 = VAR7[msg.sender].VAR8.FUN6(50);
VAR1 += VAR35;
FUN10(VAR35);
FUN4();
return;
}
if (VAR7[msg.sender].VAR17 > VAR36) {
VAR37 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR38).FUN6(10);
return;
}
if (VAR7[msg.sender].VAR17 > VAR39) {
VAR40 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR41).FUN6(10);
return;
}
if (VAR7[msg.sender].VAR17 > VAR42) {
VAR43 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR44).FUN6(10);
return;
}
if (VAR7[msg.sender].VAR17 > VAR45) {
VAR46 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR47).FUN6(10);
}
}
event FUN11(address indexed VAR48, uint16[] VAR49, uint16 indexed VAR50, uint VAR51, uint VAR52, uint VAR53, uint16 VAR54, uint16 VAR32);
function FUN12() isActivated isHuman public payable {
(uint VAR55, uint VAR56) = FUN13(msg.sender);
uint VAR6 = VAR55 + VAR56;
require(VAR6 > 0, '');
if (VAR6 > address(this).VAR57) VAR6 = address(this).VAR57;
msg.sender.transfer(VAR6);
VAR7[msg.sender].VAR58 = 0;
VAR7[msg.sender].VAR59 = 0;
VAR60 = VAR60.FUN7(VAR56);
}
event FUN14(address VAR61, uint16 VAR27);

0
---------------------------------
0x04c62019ab478bff5874e7b7d9bc84fcf7e30025.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
0x04c6daf9c3fea6ac055d20f76ef88361986366eb.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3) external payable returns (uint256);

0
---------------------------------
0x04c874b39ed85a95043f170090fb68c379e3741f.sol
function () payable internal {
uint VAR1 = msg.value * VAR2;
uint VAR3;
VAR3 += msg.value;
require(VAR4[VAR5] >= VAR1);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
Transfer(VAR5, msg.sender, VAR1);
VAR5.transfer(VAR3);
}
}

0
---------------------------------
0x04ce99ba020bdac42fc42330da489afd6515a862.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x04cf8057cdf25204c30cf1ccf919f801c0a2da44.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x04d01b6145bc9db925ec1e80bc85f936a961210e.sol
function () public payable {
revert();
}

0
---------------------------------
0x04d660832910ff492e940daff9ec7b3497e886ac.sol
function() public payable {
if (msg.value.FUN1()) {
FUN2();
return;
}
FUN3(msg.VAR1.FUN4());
}
function FUN3(address VAR2) public payable notFromContract VAR3 {
uint VAR4 = msg.value;
uint VAR5 = msg.value;
require(VAR4 >= VAR6, "");
require(address(this).VAR7 <= VAR8, "");
if (VAR5 > VAR4) {
uint VAR9 = VAR5 - VAR4;
msg.sender.transfer(VAR9);
VAR5 = VAR4;
emit FUN5(msg.sender, VAR10, msg.value, VAR4, VAR9);
}
VAR11.FUN6(VAR12.FUN7(VAR5));
VAR13.FUN6(VAR14.FUN7(VAR5));
bool VAR15 = VAR16.FUN8(msg.sender);
if (VAR2.FUN9() && !VAR15 && !VAR17[msg.sender] && VAR2 != msg.sender && VAR16.FUN8(VAR2)) {
VAR17[msg.sender] = true;
uint VAR18 = VAR19.FUN10(VAR4);
uint VAR20 = VAR21.FUN10(VAR4);
assert(VAR16.FUN11(VAR2, VAR18));
VAR4 += VAR20;
emit FUN12(msg.sender, VAR2, VAR10, VAR20);
}
uint VAR22 = FUN13(msg.sender);
if (VAR15 && VAR22.FUN9()) {
VAR4 += VAR22;
emit FUN14(msg.sender, VAR10, VAR22);
}
if (VAR23 % 20 == 0) {
VAR4 += VAR24.FUN10(VAR4);
}
else if(VAR23 % 15 == 0) {
VAR4 += VAR25.FUN10(VAR4);
}
else if(VAR23 % 10 == 0) {
VAR4 += VAR26.FUN10(VAR4);
}
if (VAR15) {
assert(VAR16.FUN11(msg.sender, VAR4));
assert(VAR16.FUN15(msg.sender, VAR10));
}
else {
if (VAR23 <= 50) {
VAR4 += VAR27.FUN10(VAR4);
}
assert(VAR16.FUN16(msg.sender, VAR4, VAR10));
emit FUN17(msg.sender, VAR10);
}
VAR23++;
emit FUN18(msg.sender, VAR10, VAR4, VAR5);
}

0
---------------------------------
0x04d6edcfc557a8cff318277c34c7478403315de3.sol
function FUN1(address VAR1) internal {
require(VAR1 != address(0));
emit FUN2(VAR2, VAR1);
VAR2 = VAR1;
}
}
contract RektFyi is VAR3 {
using DSMath for uint;
struct VAR4 {
uint VAR5;
uint VAR6;
uint VAR7;
uint VAR8;
uint VAR9;
address payable sender;
}
struct VAR10 {
uint VAR11;
uint VAR6;
uint VAR12;
uint VAR7;
}
struct VAR13 {
uint VAR14;
uint VAR15;
}
FUN3(address => VAR4) public VAR16;
FUN3(address => uint) public VAR17;
FUN3(address => address[]) private VAR18;
FUN3(address => VAR13) public VAR19;
FUN3(address => VAR10) public VAR20;
Pot public VAR21 = FUN4(0,0);
uint public VAR22 = 0;
bool public VAR23 = false;
uint public VAR24 = 0;
uint public VAR25 = 1300000000000000000;
uint public VAR26 = 10000000000000000;
uint public VAR27 = 3628800;
address public VAR28;
Medianizer VAR29;
bool public VAR30 = false;
uint public VAR31 = 0;
address public VAR32;
address public VAR33;
Dai VAR34;
Dai VAR35;
constructor(address VAR36, address VAR37) public {
VAR28 = VAR36;
VAR29 = FUN5(VAR28);
VAR32 = VAR37;
VAR34 = FUN6(VAR32);
VAR35 = VAR34;
}
string public constant VAR38 = "";
string public constant VAR39 = "";
uint8 public constant VAR40 = 0;
uint public constant VAR41 = 1000000000000000000;
uint public constant VAR42 = 100000000000000;
uint public constant VAR43 = 1000000000000000000;
uint public constant VAR44 = 10000000000000000000;
uint public constant VAR45 = 1250000000000000000;
uint public constant VAR46 = 1800000000000000000;
uint public constant VAR47 = 5000000000000000000;
uint public constant VAR48 = 1000000000000000000000000000;
uint public constant VAR49 = 100000000000000000;
uint public constant VAR50 = 23670000;
uint public constant VAR51 = 100000000000000000;
event FUN7(address indexed VAR52, string indexed VAR53, uint value);
event FUN8(address indexed VAR54, uint VAR55, uint VAR35, uint VAR34);
event Transfer(address indexed VAR56, address indexed VAR54, uint VAR57);
event FUN9(uint indexed VAR56, uint indexed VAR54, uint VAR58, address indexed VAR59);
event FUN10( address indexed sender, address indexed VAR16, uint VAR60, uint VAR25, uint VAR61, uint VAR9, uint VAR6, uint VAR7, uint VAR62 );
event FUN11(address indexed sender, address indexed VAR16);
modifier FUN12() {
require(VAR23 == false, "");
VAR63;
}
modifier FUN13(address VAR64) {
require(address(VAR64) != address(0), "");
require(VAR64 != msg.sender, "");
require(FUN14(VAR64) == 0, "");
require(VAR64.VAR17 > 0, "");
VAR63;
}

0
---------------------------------
0x04da1cd6498986015f700397a8b4bfbaa70c9399.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *4000000;
}
else {
VAR7 = msg.value *10000;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}

0
---------------------------------
0x04da2043c361113deeb52a4c3834d877586bbebd.sol
function FUN1(address VAR1, bytes memory VAR2) public virtual payable returns (bytes32);

0
---------------------------------
0x04e0e2dd8fdbca1d584927cdbdeb7a1314dff1f4.sol
function () payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable public {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
emit FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
0x04e9b27dc521158035764e96917813093bc2f748.sol
function () external payable {
require(!VAR1, '');
uint VAR2;
if(msg.value == VAR3[1]){
VAR2 = 1;
}
else if(msg.value == VAR3[2]){
VAR2 = 2;
}
else if(msg.value == VAR3[3]){
VAR2 = 3;
}
else if(msg.value == VAR3[4]){
VAR2 = 4;
}
else if(msg.value == VAR3[5]){
VAR2 = 5;
}
else if(msg.value == VAR3[6]){
VAR2 = 6;
}
else if(msg.value == VAR3[7]){
VAR2 = 7;
}
else if(msg.value == VAR3[8]){
VAR2 = 8;
}
else if(msg.value == VAR3[9]){
VAR2 = 9;
}
else if(msg.value == VAR3[10]){
VAR2 = 10;
}
else if(msg.value == VAR3[11]){
VAR2 = 11;
}
else if(msg.value == VAR3[12]){
VAR2 = 12;
}
else if(msg.value == VAR3[13]){
VAR2 = 13;
}
else if(msg.value == VAR3[14]){
VAR2 = 14;
}
else if(msg.value == VAR3[15]){
VAR2 = 15;
}
else if(msg.value == VAR3[16]){
VAR2 = 16;
}
else {
revert('');
}
if(VAR2 == 1){
uint VAR4 = 0;
address VAR5 = FUN1(msg.VAR6);
if (VAR7[VAR5] > 0 && VAR7[VAR5] <= VAR8){
VAR4 = VAR7[VAR5];
}
else {
revert('');
}
if(VAR9[VAR7[msg.sender]].VAR10){
FUN2(VAR4);
}
else {
FUN3(VAR4);
}
}
else if(VAR9[VAR7[msg.sender]].VAR10){
FUN4(VAR2);
}
else {
revert("");
}
}

0
---------------------------------
0x04ead19ff234b55a6e65391fe553d4baaa5b7ebb.sol
function () payable external {
revert();
}

0
---------------------------------
0x04eaf26f259521ea20f151118e556adc7e725c0f.sol
function () payable public {
require(false);
}
}

0
---------------------------------
0x04eb05e09ef4b9efdebbad449307c70d06f58b3e.sol
function() public payable VAR1 {
VAR2.FUN1(FUN2(msg.sender, (msg.value * VAR3) / 100));
uint VAR4 = msg.value;
while (VAR4 > 0) {
uint VAR5 = VAR4 < VAR2[VAR6].VAR7 ? VAR4 : VAR2[VAR6].VAR7;
VAR2[VAR6].VAR7 -= VAR5;
VAR4 -= VAR5;
VAR2[VAR6].VAR8.transfer(VAR5);
if(VAR4 > 0){
VAR6 += 1;
}
}
}

0
---------------------------------
0x04eb6febda6646032c6de98554e607f430c39797.sol
function() payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) canBuyTokens whenNotPaused payable {
require(msg.value != 0);
require(VAR1 != 0x0);
uint256 VAR2 = msg.value;
uint256 VAR3 = 0;
VAR3 = FUN2();
uint256 VAR4 = VAR2.FUN3(VAR5);
if (VAR3 > 0) {
VAR4 += VAR4.FUN3(VAR3).FUN4(100);
}
require(VAR6.FUN5(VAR4) <= VAR7);
require(FUN6(VAR1, VAR4));
VAR8 = VAR8.FUN5(VAR2);
FUN7(msg.sender, VAR1, VAR4);
FUN8();
}

0
---------------------------------
0x04ebe325519223119ab6bde2b84e23a6ecd05d65.sol
function () payable public {
FUN1();
}
function FUN1() payable public {
uint VAR1 = msg.value;
while (VAR1 >= VAR2 && VAR3 <= VAR4) {
uint VAR5 = 0;
if (VAR6.VAR7 > 0) {
VAR5 = VAR6[VAR6.VAR7-1];
VAR6.VAR7--;
}
else {
VAR5 = VAR3++;
}
VAR8[VAR5] = FUN2(msg.sender, VAR9);
VAR1 -= VAR2;
}
if (VAR3 > VAR4) {
FUN3();
}
if (VAR1 > 0) {
msg.sender.transfer(VAR1);
}
}

0
---------------------------------
0x04edcf348026794caf7ae9f092e80ac3d33f4686.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR13;
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}

0
---------------------------------
0x04ee4af9082746db738e7e5b49b733493a6bd81f.sol
function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 4 / 100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
address sender = msg.sender;
sender.FUN1(VAR2);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}

0
---------------------------------
0x04ee4f8f199a767e66248207eb8687d840b9fec9.sol
function () isWhitelisted acceptingPayments payable public {
require(msg.value >= 0.2 VAR1);
require(msg.value <= 500 VAR1);
require(msg.sender != address(0));
uint256 VAR2 = msg.value;
VAR3[msg.sender] += msg.value;
VAR4 = VAR4.FUN1(msg.value);
if (VAR4 > VAR5) {
uint256 VAR6 = VAR4.FUN2(VAR5);
msg.sender.transfer(VAR6);
VAR2 = VAR2.FUN2(VAR6);
VAR6 = 0;
VAR4 = VAR5;
VAR7 = false;
}
VAR8.transfer(VAR2);
}

0
---------------------------------
0x04ee65ae77471de8fbf1d08c9ef209184531424e.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x04ef8121ad039ff41d10029c91ea1694432514e9.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;
function FUN2() onlyOwner public{
(bool VAR6, ) = msg.sender.call.value(address(this).VAR3)("");
require(VAR6, "");
}
}

0
---------------------------------
0x04efc7daef8e5ba7b23f1cc1b3a36e2d50000ff7.sol
function FUN1(address VAR1, uint256 VAR2) payable public returns (uint256){
ERC721Basic VAR3 = FUN2(VAR1);
require(VAR3.FUN3(VAR2) == address(this), "");
require(VAR4[VAR1][VAR2] <= msg.value, "");
VAR3.FUN4(this, msg.sender, VAR2);
}
function FUN5() payable public returns (uint256){
uint256 value = msg.value.FUN6(1 VAR5);
uint256 VAR6 = VAR7;
if (VAR8 > 0) {
VAR6 = VAR6.FUN7(VAR6.FUN6(VAR8).FUN8(100));
}
uint256 VAR9 = value.FUN8(VAR6);
require(VAR10.FUN9(this) >= VAR9, "");
require(VAR10.transfer(msg.sender, VAR9), "");
emit FUN10(msg.sender, VAR9, msg.value);
return VAR9;
}

0
---------------------------------
0x04f062809b244e37e7fdc21d9409469c989c2342.sol
function FUN1(address VAR1, uint256 VAR2, address VAR3) external payable returns (bool);
}
contract VAR4 {
function FUN2() external payable {
require(msg.value > 0);
FUN3(msg.sender);
VAR5[0][msg.sender] = VAR5[0][msg.sender].FUN4(msg.value);
FUN5( 0, msg.sender, msg.value, VAR5[0][msg.sender] );
}

0
---------------------------------
0x04f2e7221fdb1b52a68169b25793e51478ff0329.sol
function() payable public {
revert();
}

0
---------------------------------
0x04f816ba8f8a46e0b5a1ea9fb29dcf03fb09cb67.sol
function () external payable {
revert();
}

0
---------------------------------
0x04fa0d235c4abf4bcf4787af4cf447de572ef828.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x04ff2ab42fc7868b8a4f12150950fc3604b8d3ba.sol
function FUN1() public payable onlyValid VAR1 {
require(VAR2 == true, "");
require(msg.value >= VAR3, "");
address VAR4 = VAR5;
VAR5 = msg.sender;
VAR2 = false;
emit FUN2 ( VAR6, VAR7, VAR2, VAR5, VAR3, VAR8.VAR9, VAR10.VAR9 );
uint VAR11 = VAR12[VAR4];
VAR12[VAR4] = VAR11.FUN3(VAR3);
}

0
---------------------------------
0x04ff3d111894399fa662082ededc4d7315232f8c.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x050163597d9905ba66400f7b3ca8f2ef23df702d.sol
function FUN1(address VAR1) external payable {
uint256 VAR2 = msg.value / VAR3;
uint256 VAR4 = VAR5.FUN2(address(this));
uint256 VAR6 = msg.value % VAR3;
if (VAR7 < VAR4) {
VAR7 = VAR4;
}
if (VAR2 > VAR7) {
VAR2 = VAR7;
VAR6 = msg.value - VAR2 * VAR3;
}
uint256 VAR8 = FUN3(VAR2);
VAR9 += VAR2;
if (VAR4 < VAR2 + VAR8) {
VAR5.transfer(msg.sender, VAR4);
}
else {
VAR5.transfer(msg.sender, VAR2 + VAR8);
}
if (VAR1 != address(this) && VAR1 != address(0)) {
VAR1.FUN4( msg.value * VAR10 / 100 );
}
if (VAR6 > 0) {
msg.sender.transfer(VAR6);
}
FUN5(msg.sender, VAR1, VAR2, VAR11);
}

0
---------------------------------
0x05052425f8ce5b4b7d04091ce06f9c69a8c1fefa.sol
function FUN1(address VAR1) internal pure returns (address payable) {
return address(FUN2(VAR1));
}

0
---------------------------------
0x05057637bdc43815a29a4b93cb760ad3c7d590e7.sol
function FUN1( address VAR1 ) internal pure returns (address payable) {
return payable(VAR1);
}

0
---------------------------------
0x05064de4d8fcc27c0aad610277ff3e40d422e3f2.sol
function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);

0
---------------------------------
0x050663fa3f625e9accf534fb188bcb1dca0579b5.sol
function FUN1(address VAR1) public isUnderHardCap saleIsOn payable {
uint VAR2 = VAR3.FUN2("");
uint VAR4 = VAR2.FUN3(msg.value).FUN4(1 VAR5);
VAR6.FUN5(VAR1, VAR4);
require(VAR7.FUN6(msg.value));
FUN7(VAR1, msg.value, VAR4, VAR2);
}
function() external payable {
FUN1(msg.sender);
}
}

0
---------------------------------
0x0507567f1ce102b70b27da7d74d52daa2d9b3011.sol
function () public payable {
revert();
}

0
---------------------------------
0x05086b34c8cf1531cd4d2af7bfbf3d39f5b2477f.sol
function () public payable {
revert();
}
}

0
---------------------------------
0x050921f845d384a786c38296ef42cb276194c642.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x050a0bb563e7cf21eb29df0bb39e9f092fa2cd3f.sol
function () payable public{
require(!VAR1);
uint VAR2 = msg.value ;
VAR3+=VAR2;
FUN1(VAR4, msg.sender, VAR2 * VAR5);
}

0
---------------------------------
0x050cd4835b08babfc6ff92187971b3253e92640e.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x0510657eae43aef3a8c7113655637a3710ec7018.sol
function() public payable {
VAR1.transfer(this.VAR2);
FUN1("");
}

0
---------------------------------
0x0511926471CdcF840c8145c1Fbcbb0A8c495c1a9.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1) external onlyOwner {
VAR1.transfer(address(this).VAR2);
}
function FUN3(uint256 VAR3) public payable whenInProgress VAR4 {
require(VAR3 > 0, "");
address VAR5 = msg.sender;
uint256 VAR6 = FUN4(VAR5);
require( VAR3 <= VAR6, "" );
require( msg.value >= FUN5(VAR3), "" );
uint256[] memory VAR7 = new uint256[](VAR3);
uint256[] memory VAR8 = new uint256[](VAR3);
for (uint256 VAR9 = 0; VAR9 < VAR3; VAR9++) {
VAR7[VAR9] = FUN6();
VAR8[VAR9] = 1;
}
VAR10[VAR5] += VAR3;
VAR11.FUN7( address(this), VAR5, VAR7, VAR8, "" );
}

0
---------------------------------
0x0513125C4ffDF276c6Bb9B67DbB532a9BA9804eD.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x05133e67d16b6596c3523fb826fc385e7b26c8df.sol
function FUN1(uint VAR1) external payable VAR2 FUN2(VAR1) {
require (msg.value == VAR3, '');
if (VAR4[msg.sender].sender == 0x0) {
VAR4[msg.sender] = FUN3({
VAR5: new uint[](VAR6.VAR7), sender: msg.sender, VAR8: false }
);
VAR6[VAR1].VAR4.FUN4(msg.sender);
}
VAR4[msg.sender].VAR5[VAR1]++;
VAR9++;
VAR6[VAR1].VAR10++;
uint VAR11 = VAR12.FUN5(msg.value, VAR13);
VAR6[VAR1].VAR14 = VAR12.FUN6(VAR6[VAR1].VAR14, VAR11);
VAR15 = VAR12.FUN6(VAR15, VAR11);
VAR16.transfer(VAR13);
}

0
---------------------------------
0x0513ce8013f27a47a0088ffaac94fbb0fe6309d8.sol
function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 1 / 100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
address sender = msg.sender;
sender.FUN1(VAR2);
}
if (msg.value != 0) {
VAR6.FUN1(msg.value * 15 / 100);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}

0
---------------------------------
0x05159559b45296b0a96097351e17ab1619bc9431.sol
function FUN1(address VAR1, address VAR2, uint256 value) public returns (bool);
event Transfer(address indexed VAR1, address indexed VAR2, uint256 value);
uint8 public VAR3;
}
contract Bussiness is VAR4 {
using SafeMath for uint256;
address public VAR5 = address(0xFce92D4163AA532AA096DE8a3C4fEf9f875Bc55F);
ERC20BasicInterface public VAR6 = FUN2(0xEc7ba74789694d0d03D458965370Dc7cF2FE75Ba);
uint256 public VAR7 = 1000;
uint256 public VAR8 = 21;
struct VAR9 {
address payable VAR10;
uint256 VAR11;
uint256 VAR12;
uint256 VAR13;
bool VAR14;
}
struct VAR15 {
FUN3(uint256 => VAR9) VAR16;
uint256[] VAR17;
uint256 VAR18;
uint256 VAR19;
uint256 VAR20;
uint256 VAR21;
}
FUN3(address => VAR15) public VAR22;
address[] VAR23;
constructor() public {
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR18 = 0;
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR19 = 0;
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR20 = 0;
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B));
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR18 = 0;
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR19 = 0;
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR20 = 0;
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea));
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR18 = 0;
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR19 = 0;
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR20 = 0;
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x273f7F8E6489682Df756151F5525576E322d51A3));
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR18 = 0;
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR19 = 0;
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR20 = 0;
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d));
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR18 = 0;
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR19 = 0;
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR20 = 0;
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392));
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR18 = 0;
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR19 = 0;
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR20 = 0;
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f));
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR18 = 0;
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR19 = 0;
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR20 = 0;
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340));
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR18 = 0;
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR19 = 0;
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR20 = 0;
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b));
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR18 = 0;
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR19 = 0;
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR20 = 0;
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xf26A23019b4699068bb54457f32dAFCF22A9D371));
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR18 = 0;
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR19 = 0;
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR20 = 0;
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099));
}
function FUN5(address VAR24, uint256 VAR25, uint256 VAR26, uint VAR27) public payable FUN6(VAR24, VAR25) {
require(VAR22[VAR24].VAR16[VAR25].VAR11 != VAR26);
uint256 VAR28;
uint256 VAR29 = 0;
if (VAR27 == 1 && (VAR22[VAR24].VAR16[VAR25].VAR11 == 0 || !VAR22[VAR24].VAR16[VAR25].VAR14)) {
VAR29 = VAR22[VAR24].VAR21;
}
if (VAR22[VAR24].VAR16[VAR25].VAR11 < VAR26) {
VAR28 = VAR26.FUN7(VAR22[VAR24].VAR16[VAR25].VAR11).FUN8(VAR22[VAR24].VAR18).FUN9(VAR7);
if(VAR22[VAR24].VAR16[VAR25].VAR11 == 0) {
if (VAR28 >= VAR22[VAR24].VAR19) {
require(msg.value == VAR28.FUN10(VAR29));
}
else {
require(msg.value == VAR22[VAR24].VAR19.FUN10(VAR29));
VAR28 = VAR22[VAR24].VAR19;
}
}
VAR28 = VAR28.FUN10(VAR22[VAR24].VAR16[VAR25].VAR12);
}
else VAR28 = VAR26.FUN8(VAR22[VAR24].VAR18).FUN9(VAR7);
FUN11(VAR24, VAR25, VAR26, VAR28, 0, VAR27 == 1);
}
function FUN12(address VAR24, uint256 VAR30) public payable {
IERC721 VAR31 = FUN13(VAR24);
require(FUN14(VAR24, VAR30) == address(this));
require(VAR22[VAR24].VAR16[VAR30].VAR11 > 0 && VAR22[VAR24].VAR16[VAR30].VAR11 == msg.value);
VAR31.FUN1(VAR22[VAR24].VAR16[VAR30].VAR10, msg.sender, VAR30);
VAR22[VAR24].VAR16[VAR30].VAR10.transfer(msg.value);
FUN15(VAR24, VAR30);
}
function FUN16(address VAR24, uint256 VAR30) public payable {
IERC721 VAR31 = FUN13(VAR24);
require(VAR22[VAR24].VAR16[VAR30].VAR11 > 0 && VAR22[VAR24].VAR16[VAR30].VAR11 == msg.value);
VAR31.FUN1(VAR22[VAR24].VAR16[VAR30].VAR10, msg.sender, VAR30);
VAR22[VAR24].VAR16[VAR30].VAR10.transfer(msg.value);
FUN15(VAR24, VAR30);
}

0
---------------------------------
0x05196e85fcfe0ed4b7978a83966e6748ba8e60e6.sol
function FUN1(uint256 VAR1) public payable {
address VAR2 = VAR3[VAR1];
address VAR4 = msg.sender;
uint256 VAR5 = FUN2(VAR1);
require(VAR2 != VAR4);
require(FUN3(VAR4));
require(msg.value >= VAR5);
uint256 VAR6 = uint256(VAR7.FUN4(VAR7.FUN5(VAR5, VAR8[VAR1]), 100));
uint256 VAR9 = uint256(VAR7.FUN4(VAR7.FUN5(VAR5, VAR10[VAR1]), 100));
uint256 VAR11 = uint256(VAR7.FUN6(VAR5, VAR7.FUN7(VAR6, VAR9)));
FUN8(VAR2, VAR4, VAR1);
if ( VAR2 != address(this) ) {
VAR2.transfer(VAR11);
}
FUN9(VAR1, VAR5, VAR2, VAR4, VAR12[VAR1].VAR13);
msg.sender.transfer(VAR9);
address VAR14 = VAR15[VAR1];
VAR14.transfer(VAR6);
VAR16.transfer(VAR9);
}

0
---------------------------------
0x051CaEFA90aDf261B8E8200920C83778b7B176B6.sol
function () payable external {
FUN1();
}
function FUN2( address VAR1, address VAR2, bytes memory VAR3 ) public payable onlyGovernor {
require(FUN3() == address(0));
assert( VAR4 == bytes32(uint256(FUN4("")) - 1) );
FUN5(VAR1);
if (VAR3.VAR5 > 0) {
(bool VAR6, ) = VAR1.FUN6(VAR3);
require(VAR6);
}
FUN7(VAR2);
}
function FUN8(address VAR7, bytes calldata VAR8) external payable onlyGovernor {
FUN9(VAR7);
(bool VAR6, ) = VAR7.FUN6(VAR8);
require(VAR6);
}
}

0
---------------------------------
0x051fda7486480dd5abcf5dd742ef002a2ebb9ea0.sol
function FUN1(address VAR1) payable returns(bool);
function () payable {
if (FUN2(VAR2)) {
if (! FUN3(VAR2).VAR3.value(msg.value)(msg.sender)) throw;
}
else {
throw;
}
}
function () public payable VAR4 {
FUN1(msg.sender);
}
function FUN1(address VAR5) public payable notPaused initialized contributionOpen returns (bool) {
require(VAR5 != 0x0);
FUN4(VAR5);
return true;
}

0
---------------------------------
0x0520959c7b38a2db9f9ed0f7b0fc621cf22c07a0.sol
function () payable public {
revert();
}
}
contract TokenLocker is VAR1, VAR2 {
using SafeERC20 for VAR3;
using SafeMath for uint;
CommunityCoin public VAR4;
string public constant VAR5 = "";
string public constant VAR6 = "";
uint8 public constant VAR7 = 18;
FUN1(address => uint) VAR8;
uint private VAR9;
uint public VAR10;
uint constant public VAR11 = 180 VAR12;
event FUN2(address VAR13, uint VAR14);
function () payable public{
revert();
}
}

0
---------------------------------
0x05215fce25902366480696f38c3093e31dbce69a.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
0x05235e3493d1db3283d140d2dddd6956bef43059.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
0x0524f3c7fb46abc0f6c715ba1b559259350387e0.sol
function FUN1( address payable VAR1, address VAR2, uint VAR3, bytes calldata VAR4) external VAR5;

0
---------------------------------
0x0525ccb9b7df582db9913b4d4cff5eef4b3f2379.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, "" );
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require( VAR4, "" );
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x052874643c388bb2ae101f25e41e1f1778f61364.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x0529663bd4d73d3dd06f90247d8c2e802755b7ec.sol
function FUN1(uint VAR1) public payable {
var VAR2 = VAR3[msg.sender];
if( VAR2.VAR4>=VAR5 && VAR2.VAR4>=VAR1 && VAR6>VAR2.VAR7) {
if(msg.sender.call.value(VAR1)()) {
VAR2.VAR4-=VAR1;
VAR8.FUN2(msg.sender,VAR1,"");
}
}
}

0
---------------------------------
0x052ad390d8f86c878ec7d48fd20ca004bdab144d.sol
function FUN1(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, "");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
require(VAR9[VAR7], "");
require(FUN4() >= VAR4, "");
require(FUN4() <= VAR4.FUN5(VAR10), "");
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)(VAR11);
require(VAR13, "");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}

0
---------------------------------
0x052b412bf5d2c219a68a309abd76bb16f0a43d38.sol
function FUN1( IMultiToken VAR1, uint256 VAR2, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, "");
require(VAR7.VAR8 == VAR4.VAR8, "");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.FUN2(VAR4[VAR9], 0);
VAR3.FUN2(VAR4[VAR9], VAR3.FUN3(this));
require(VAR4[VAR9].call(VAR10), "");
VAR3.FUN2(VAR4[VAR9], 0);
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), "");
}
}
VAR12 = VAR1.FUN4();
uint256 VAR13 = uint256(-1);
for (VAR9 = VAR1.FUN5(); VAR9 > 0; VAR9--) {
ERC20 VAR14 = VAR1.FUN6(VAR9 - 1);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR14.FUN3(this));
uint256 VAR15 = VAR12.FUN7(VAR14.FUN3(this)).FUN8(VAR14.FUN3(VAR1));
if (VAR15 < VAR13) {
VAR13 = VAR15;
}
}
require(VAR13 >= VAR2, "");
VAR1.FUN9(msg.sender, VAR13);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
function FUN10( IMultiToken VAR1, uint256 VAR2, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, "");
require(VAR7.VAR8 == VAR4.VAR8, "");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.transfer(VAR4[VAR9], VAR7[VAR9]);
require(VAR4[VAR9].call(VAR10), "");
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), "");
}
}
VAR12 = VAR1.FUN4();
uint256 VAR13 = uint256(-1);
for (VAR9 = VAR1.FUN5(); VAR9 > 0; VAR9--) {
ERC20 VAR14 = VAR1.FUN6(VAR9 - 1);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR14.FUN3(this));
uint256 VAR15 = VAR12.FUN7(VAR14.FUN3(this)).FUN8(VAR14.FUN3(VAR1));
if (VAR15 < VAR13) {
VAR13 = VAR15;
}
}
require(VAR13 >= VAR2, "");
VAR1.FUN9(msg.sender, VAR13);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
function FUN11( IMultiToken VAR1, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, "");
require(VAR7.VAR8 == VAR4.VAR8, "");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.FUN2(VAR4[VAR9], 0);
VAR3.FUN2(VAR4[VAR9], VAR3.FUN3(this));
require(VAR4[VAR9].call(VAR10), "");
VAR3.FUN2(VAR4[VAR9], 0);
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), "");
}
}
uint VAR17 = VAR1.FUN5();
uint256[] memory VAR18 = new uint256[](VAR17);
for (VAR9 = 0; VAR9 < VAR17; VAR9++) {
ERC20 VAR14 = VAR1.FUN6(VAR9);
VAR18[VAR9] = VAR14.FUN3(this);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR18[VAR9]);
}
VAR1.FUN12(msg.sender, msg.value.FUN7(1000), VAR18);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
function FUN13( IMultiToken VAR1, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, "");
require(VAR7.VAR8 == VAR4.VAR8, "");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.transfer(VAR4[VAR9], VAR7[VAR9]);
require(VAR4[VAR9].call(VAR10), "");
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), "");
}
}
uint VAR17 = VAR1.FUN5();
uint256[] memory VAR18 = new uint256[](VAR17);
for (VAR9 = 0; VAR9 < VAR17; VAR9++) {
ERC20 VAR14 = VAR1.FUN6(VAR9);
VAR18[VAR9] = VAR14.FUN3(this);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR18[VAR9]);
}
VAR1.FUN12(msg.sender, msg.value.FUN7(1000), VAR18);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
}

0
---------------------------------
0x052d01d58729839b0fb9e321c63caf4f7a3de7fe.sol
function FUN1(address VAR1) public isUnderHardCap saleIsOn payable {
uint VAR2 = VAR3.FUN2("");
uint VAR4 = VAR2.FUN3(msg.value).FUN4(1 VAR5);
VAR6.FUN5(VAR1, VAR4);
require(VAR7.FUN6(msg.value));
FUN7(VAR1, msg.value, VAR4, VAR2);
}
function() external payable {
FUN1(msg.sender);
}
}

0
---------------------------------
0x05316c4bbf2521bb529ca47dd66212d34ed1f6a3.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(address(this), msg.sender, VAR1);
}

0
---------------------------------
0x0531c928d539cbee3aa3bb3dae37ad507c750efc.sol
function FUN1() payable public {
require(VAR1==msg.sender);
VAR2.FUN2(address(this));
VAR2.FUN3();
}
function () payable public {
}
}

0
---------------------------------
0x0532dd9ecb00c424c72335df4f60c11c03229ec0.sol
function () external payable {
if(msg.sender == VAR1) {
require(FUN1() && VAR2 < VAR3);
}
else {
FUN2(msg.sender);
}
}
function FUN2(address VAR4) public payable {
require(VAR4 != address(0));
require(FUN3());
require(VAR5 < FUN4());
uint256 value = msg.value;
VAR6 = VAR6.FUN5(value);
uint256 VAR7 = FUN6(VAR5);
uint256 VAR8 = 0;
uint256 VAR9 = 0;
if(VAR6 > VAR7){
VAR8 = VAR6.FUN7(VAR7);
value = value.FUN7(VAR8);
if(VAR5 == FUN4() - 1){
VAR9 = VAR8;
VAR6 = VAR6.FUN7(VAR8);
VAR8 = 0;
}
}
FUN8(value, VAR4);
if(VAR8 > 0){
VAR5 = VAR5 + 1;
FUN8(VAR8, VAR4);
}
if(VAR2 == VAR10) {
VAR11.FUN9(VAR12 + 2 VAR13);
}
if(VAR9 > 0) {
msg.sender.transfer(VAR9);
}
}

0
---------------------------------
0x0534384a98fcfb9cf0514706f02c6697f0e40bca.sol
function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
constructor() public {
VAR5 = msg.sender;
}
address payable VAR5;
modifier onlyOwner {
require( msg.sender == VAR5, "" );
VAR8;
}
}
interface VAR9{
struct VAR10 {
uint96 VAR11;
address VAR12;
}
struct VAR13 {
uint40 VAR14;
uint40 VAR15;
FUN3(uint256 => VAR10) VAR16;
}

0
---------------------------------
0x053889176621886e8ca98F349C1DEeB3612D2960.sol
function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, "");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
if (VAR9) {
require(VAR10[VAR7], "");
require(FUN4() >= VAR4, "");
require(FUN4() <= VAR4.FUN5(VAR11), "");
VAR10[VAR7] = false;
}
bytes memory VAR12;
if (bytes(VAR2).VAR13 == 0) {
VAR12 = VAR3;
}
else {
VAR12 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR14, bytes memory VAR15) = VAR1.call.value(value)(VAR12);
require(VAR14, "");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR15;
}

0
---------------------------------
0x053a65075e4fb3a3024518d232aed752d9a711a1.sol
function() external payable {
if(msg.VAR1.VAR2 == 0 && msg.value > 0) {
emit FUN1(msg.value, msg.sender, msg.VAR1);
}
else {
VAR3 {
let VAR4 := FUN2(0) FUN3(0, 0, FUN4()) let VAR5 := FUN5(VAR6, VAR4, 0, FUN4(), 0, 0) FUN6(0, 0, FUN7()) switch result case 0 {
revert(0, FUN7())}
default {
return (0, FUN7())}
}
}
}
}

0
---------------------------------
0x053b278e22e6119f1e333b10bd6d0ad3d7a8cd20.sol
function () public payable {
revert();
}
}
library VAR1 {

0
---------------------------------
0x053e43d155519efc4616bdc2a8fef5a4eb4cec4e.sol
function FUN1(string VAR1) public payable {
Candy storage VAR2 = VAR3[VAR1];
require(VAR2.VAR4 != msg.sender);
require(msg.sender != address(0));
uint256 VAR5 = (VAR6.VAR7 - VAR2.VAR8);
while(VAR5 >= VAR9){
VAR5 = (VAR5 - VAR9);
VAR2.VAR10 = VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 90);
}
if(VAR2.VAR10 < 1000000000000000){
VAR2.VAR10 = 1000000000000000;
}
require(msg.value >= VAR2.VAR10);
uint256 VAR12 = VAR11.FUN4(msg.value, VAR2.VAR10);
if(VAR2.VAR4 == address(this)){
VAR13.transfer(VAR2.VAR10);
}
else {
VAR13.transfer(uint256(VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 10)));
VAR2.VAR4.transfer(uint256(VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 90)));
}
VAR2.VAR10 = VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 160);
VAR2.VAR4 = msg.sender;
VAR2.VAR8 = VAR6.VAR7;
msg.sender.transfer(VAR12);
}

0
---------------------------------
0x054337fc42496bebdd530805b98e211f73c01105.sol
function() public payable {
FUN1(msg.sender, msg.value);
}

0
---------------------------------
0x054404c4cbe5273b7045eae7d4aa66db12391bfa.sol
function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x05448eafc212805495de1a82ff6807fd729cbefa.sol
function transfer(address VAR1, uint value) public returns (bool VAR2);
event Transfer(address indexed VAR3, address indexed VAR1, uint value);
event FUN1(address indexed VAR4, address indexed VAR5, uint value);
}
contract UniversalBasicIncome is VAR6{
uint8 public constant VAR7 = 18;
uint256 VAR8 = 100000*10**uint256(VAR7);
string public constant VAR9 = "";
string public constant VAR10 = "";
address payable VAR11;
function () external payable {
VAR11.transfer(msg.value);
}
constructor () public payable {
VAR11 = msg.sender;
VAR12[VAR11] = VAR8;
}
}

0
---------------------------------
0x0545590d1ce8a60db943f7cf64f60cca44895da6.sol
function() external payable {
emit FUN1(msg.value);
if ( !(msg.value == 10000000000 || msg.value == 20000000000 || msg.value == 30000000000) ) {
revert("");
}
if (msg.value == 10000000000) {
VAR1 += 100 * 1 VAR2;
VAR3[msg.sender] += 100 * 1 VAR2;
}
if (msg.value == 20000000000) {
VAR1 += 10000 * 1 VAR2;
VAR3[msg.sender] += 10000 * 1 VAR2;
}
if (msg.value == 30000000000) {
VAR1 += 1000000 * 1 VAR2;
VAR3[msg.sender] += 1000000 * 1 VAR2;
}
}

0
---------------------------------
0x05461124c86c0ad7c5d8e012e1499fd9109ffb7d.sol
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool);
function() public payable {
FUN2(VAR7, msg.value);
}
event FUN3( address indexed VAR8, address VAR9, uint VAR2, address VAR3, uint VAR10, address VAR4 );
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool) {
require(VAR11);
require(msg.sender == VAR12);
require(FUN4(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6));
return true;
}
event FUN5(bool VAR13);

0
---------------------------------
0x05484e280743ae0ca8072ea0faf571dda0b75fa8.sol
function () public payable {
revert();
}
}

0
---------------------------------
0x0549282eb828861a0effa4c5cc281a1afec0fa21.sol
function FUN1() external payable;
function FUN2( VAR1[][] memory VAR2, TokenInterface VAR3, TokenInterface VAR4, uint VAR5, uint VAR6, uint8 VAR7 ) public payable FUN3(VAR7) returns (uint VAR8) {
FUN4(VAR3, VAR5);
for (uint VAR9 = 0; VAR9 < VAR2.VAR10; VAR9++) {
uint VAR11;
for (uint VAR12 = 0; VAR12 < VAR2[VAR9].VAR10; VAR12++) {
Swap memory VAR13 = VAR2[VAR9][VAR12];
TokenInterface VAR14 = FUN5(VAR13.VAR3);
if (VAR12 == 1) {
VAR13.VAR15 = VAR11;
}
PoolInterface VAR16 = FUN6(VAR13.VAR16);
if (VAR14.FUN7(address(this), VAR13.VAR16) > 0) {
VAR14.FUN8(VAR13.VAR16, 0);
}
VAR14.FUN8(VAR13.VAR16, VAR13.VAR15);
(VAR11,) = VAR16.FUN9( VAR13.VAR3, VAR13.VAR15, VAR13.VAR4, VAR13.VAR17, VAR13.VAR18 );
}
VAR8 = FUN10(VAR11, VAR8);
}
require(VAR8 >= VAR6, "");
FUN11(VAR4, VAR8);
FUN11(VAR3, FUN12(VAR3));
}
function FUN13( VAR1[][] memory VAR2, TokenInterface VAR3, TokenInterface VAR4, uint VAR19, uint8 VAR7 ) public payable FUN3(VAR7) returns (uint VAR5) {
FUN4(VAR3, VAR19);
for (uint VAR9 = 0; VAR9 < VAR2.VAR10; VAR9++) {
uint VAR20;
if (VAR2[VAR9].VAR10 == 1) {
Swap memory VAR13 = VAR2[VAR9][0];
TokenInterface VAR14 = FUN5(VAR13.VAR3);
PoolInterface VAR16 = FUN6(VAR13.VAR16);
if (VAR14.FUN7(address(this), VAR13.VAR16) > 0) {
VAR14.FUN8(VAR13.VAR16, 0);
}
VAR14.FUN8(VAR13.VAR16, VAR13.VAR17);
(VAR20,) = VAR16.FUN14( VAR13.VAR3, VAR13.VAR17, VAR13.VAR4, VAR13.VAR15, VAR13.VAR18 );
}
else {
uint VAR21;
Swap memory VAR22 = VAR2[VAR9][1];
PoolInterface VAR23 = FUN6(VAR22.VAR16);
VAR21 = VAR23.FUN15( VAR23.FUN12(VAR22.VAR3), VAR23.FUN16(VAR22.VAR3), VAR23.FUN12(VAR22.VAR4), VAR23.FUN16(VAR22.VAR4), VAR22.VAR15, VAR23.FUN17() );
Swap memory VAR24 = VAR2[VAR9][0];
TokenInterface VAR25 = FUN5(VAR24.VAR3);
PoolInterface VAR26 = FUN6(VAR24.VAR16);
if (VAR25.FUN7(address(this), VAR24.VAR16) < uint(- 1)) {
VAR25.FUN8(VAR24.VAR16, uint(- 1));
}
(VAR20,) = VAR26.FUN14( VAR24.VAR3, VAR24.VAR17, VAR24.VAR4, VAR21, VAR24.VAR18 );
TokenInterface VAR27 = FUN5(VAR22.VAR3);
if (VAR27.FUN7(address(this), VAR22.VAR16) < uint(- 1)) {
VAR27.FUN8(VAR22.VAR16, uint(- 1));
}
VAR23.FUN14( VAR22.VAR3, VAR22.VAR17, VAR22.VAR4, VAR22.VAR15, VAR22.VAR18 );
}
VAR5 = FUN10(VAR20, VAR5);
}
require(VAR5 <= VAR19, "");
FUN11(VAR4, FUN12(VAR4));
FUN11(VAR3, FUN12(VAR3));
}
FUN18() external payable {
}
}
function FUN13( VAR1[][] memory VAR2, TokenInterface VAR3, TokenInterface VAR4, uint VAR19, uint8 VAR7 ) public payable FUN3(VAR7) returns (uint VAR5) {
FUN4(VAR3, VAR19);
for (uint VAR9 = 0; VAR9 < VAR2.VAR10; VAR9++) {
uint VAR20;
if (VAR2[VAR9].VAR10 == 1) {
Swap memory VAR13 = VAR2[VAR9][0];
TokenInterface VAR14 = FUN5(VAR13.VAR3);
PoolInterface VAR16 = FUN6(VAR13.VAR16);
if (VAR14.FUN7(address(this), VAR13.VAR16) > 0) {
VAR14.FUN8(VAR13.VAR16, 0);
}
VAR14.FUN8(VAR13.VAR16, VAR13.VAR17);
(VAR20,) = VAR16.FUN14( VAR13.VAR3, VAR13.VAR17, VAR13.VAR4, VAR13.VAR15, VAR13.VAR18 );
}
else {
uint VAR21;
Swap memory VAR22 = VAR2[VAR9][1];
PoolInterface VAR23 = FUN6(VAR22.VAR16);
VAR21 = VAR23.FUN15( VAR23.FUN12(VAR22.VAR3), VAR23.FUN16(VAR22.VAR3), VAR23.FUN12(VAR22.VAR4), VAR23.FUN16(VAR22.VAR4), VAR22.VAR15, VAR23.FUN17() );
Swap memory VAR24 = VAR2[VAR9][0];
TokenInterface VAR25 = FUN5(VAR24.VAR3);
PoolInterface VAR26 = FUN6(VAR24.VAR16);
if (VAR25.FUN7(address(this), VAR24.VAR16) < uint(- 1)) {
VAR25.FUN8(VAR24.VAR16, uint(- 1));
}
(VAR20,) = VAR26.FUN14( VAR24.VAR3, VAR24.VAR17, VAR24.VAR4, VAR21, VAR24.VAR18 );
TokenInterface VAR27 = FUN5(VAR22.VAR3);
if (VAR27.FUN7(address(this), VAR22.VAR16) < uint(- 1)) {
VAR27.FUN8(VAR22.VAR16, uint(- 1));
}
VAR23.FUN14( VAR22.VAR3, VAR22.VAR17, VAR22.VAR4, VAR22.VAR15, VAR22.VAR18 );
}
VAR5 = FUN10(VAR20, VAR5);
}
require(VAR5 <= VAR19, "");
FUN11(VAR4, FUN12(VAR4));
FUN11(VAR3, FUN12(VAR3));
}
FUN18() external payable {
}
}

0
---------------------------------
0x054ad3cd4a66f14bf5c0de2548a53be66995a4f6.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
0x054bd236b42385c938357112f419dc5943687886.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x054df44d9bf67e87e09de919086bf12633f6bcf5.sol
function() external payable {
require(msg.sender == VAR1);
}
function FUN1(uint192 VAR2, uint192 VAR3, uint160 VAR4, uint32 VAR5) external payable VAR6 {
Token memory VAR7 = FUN2({
VAR2: VAR2, VAR3: VAR3, VAR4: VAR4, VAR8: FUN3(VAR9), VAR5: VAR5 }
);
require(msg.value >= FUN4());
require(msg.sender != address(0));
require(VAR10.VAR11 < VAR12);
require(VAR13[msg.sender].VAR11 < 100);
require(VAR9 < VAR14);
uint256 VAR15 = VAR10.FUN5(VAR7) - 1;
require(VAR15 == uint256(FUN6(VAR15)));
FUN7(msg.sender, VAR15);
FUN8(msg.sender, VAR15, VAR7);
}

0
---------------------------------
0x054e1671d5d936613555776a99100f8eae6f62ff.sol
function () public payable {
FUN1();
}
}
contract AssembledCommonSale is VAR1 {
}
contract WalletsPercents is VAR2 {
address[] public VAR3;
FUN2 (address => uint) VAR4;

0
---------------------------------
0x054f3832Aac0eB98f82Ba9e3F1447Ab373308b8B.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN3(uint256 VAR5, uint256 VAR6) external payable returns (uint256);

0
---------------------------------
0x054f76beed60ab6dbeb23502178c52d6c5debe40.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x0550b6a75ca699c4611440e1c96295d977cc5452.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x0554c23993cad4c4baf5cc8296f003d1c68c0d75.sol
function () payable public {
require(VAR1 <= msg.value);
uint VAR2 = msg.value;
uint VAR3 = VAR2.FUN1(VAR4);
require(VAR3 > 0);
FUN2(this, msg.sender, VAR2);
FUN3(msg.sender, VAR2);
}
}

0
---------------------------------
0x05558363697b6604201be04faf30e80b0c9efd23.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
0x0557e0d15aec0b9026dd17aa874fdf7d182a2ceb.sol
function() external payable {
FUN1();
}
}
contract UpgradeabilityProxy is VAR1 {
string internal VAR2;
address internal VAR3;
event FUN2(string VAR4, address indexed VAR5);
function () external payable VAR6{
require(msg.value == 0);
FUN3();
}
function FUN3() public payable VAR6{
uint256 VAR7 = 0;
uint256 VAR8 = VAR9;
FUN4(uint => uint) VAR10 = VAR11;
FUN4(address => FUN4(uint => uint)) VAR12 = VAR13;
for(uint VAR14 = 1; VAR14 <= VAR8; VAR14++){
if(VAR10[VAR14] < VAR15.VAR16){
if(VAR12[VAR17.VAR18][VAR14] > 0){
VAR7 = VAR7.FUN5(VAR12[VAR17.VAR18][VAR14]);
emit FUN6(VAR14, VAR12[VAR17.VAR18][VAR14], VAR17.VAR18);
delete VAR13[VAR17.VAR18][VAR14];
}
}
}
VAR19[VAR17.VAR18] = VAR19[VAR17.VAR18].FUN5(VAR7);
}

0
---------------------------------
0x05584b4f5eb88169691454c315f27599ef7f600f.sol
function () public payable {
revert();
}

0
---------------------------------
0x055a9c349cdc2a598439d6a45d0a83cad3864fdc.sol
function () payable;

0
---------------------------------
0x055C59fCC1c49a84e94f89dEe42732614B0CC2dE.sol
function FUN1() external payable;
function FUN2( address VAR1, address VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6 ) external payable {
uint VAR7 = FUN3(VAR5, VAR3);
ICurve VAR8 = FUN4(FUN5());
TokenInterface VAR9 = FUN6(VAR1);
TokenInterface VAR10 = FUN6(VAR2);
VAR7 = VAR7 == uint(-1) ? VAR10.FUN7(address(this)) : VAR7;
VAR10.FUN8(address(VAR8), VAR7);
uint VAR11 = FUN9(VAR9.FUN10(), FUN11(VAR4, FUN12(VAR10.FUN10(), VAR7)));
uint VAR12 = VAR9.FUN7(address(this));
VAR8.FUN13(FUN14(VAR2), FUN14(VAR1), VAR7, VAR11);
uint VAR13 = VAR9.FUN7(address(this));
uint VAR14 = FUN15(VAR13, VAR12);
FUN16(VAR6, VAR14);
emit FUN17(VAR1, VAR2, VAR14, VAR7, VAR5, VAR6);
bytes32 VAR15 = FUN18("");
bytes memory VAR16 = VAR17.FUN19(VAR1, VAR2, VAR14, VAR7, VAR5, VAR6);
FUN20(VAR15, VAR16);
}
function FUN1( address VAR18, uint VAR19, uint VAR4, uint VAR5, uint VAR6 ) external payable {
uint256 VAR20 = FUN3(VAR5, VAR19);
TokenInterface VAR21 = FUN6(VAR18);
VAR20 = VAR20 == uint(-1) ? VAR21.FUN7(address(this)) : VAR20;
uint[3] memory VAR22;
VAR22[uint(FUN14(VAR18))] = VAR20;
VAR21.FUN8(FUN5(), VAR20);
uint VAR23 = FUN12(VAR21.FUN10(), VAR20);
uint VAR11 = FUN11(VAR4, VAR23);
TokenInterface VAR24 = FUN6(FUN21());
uint VAR25 = VAR24.FUN7(address(this));
FUN4(FUN5()).FUN22(VAR22, VAR11);
uint VAR26 = VAR24.FUN7(address(this));
uint VAR27 = FUN15(VAR26, VAR25);
FUN16(VAR6, VAR27);
emit FUN23(VAR18, VAR20, VAR27, VAR5, VAR6);
bytes32 VAR15 = FUN18("");
bytes memory VAR16 = VAR17.FUN19(VAR18, VAR20, VAR27, VAR5, VAR6);
FUN20(VAR15, VAR16);
}
function FUN24( address VAR18, uint256 VAR19, uint256 VAR4, uint VAR5, uint VAR6 ) external payable {
uint VAR20 = FUN3(VAR5, VAR19);
int128 VAR28 = FUN14(VAR18);
TokenInterface VAR24 = FUN6(FUN21());
ICurve VAR29 = FUN4(FUN5());
uint VAR30;
uint[3] memory VAR22;
if (VAR20 == uint(-1)) {
VAR30 = VAR24.FUN7(address(this));
VAR20 = VAR29.FUN25(VAR30, VAR28);
VAR22[uint(VAR28)] = VAR20;
}
else {
VAR22[uint(VAR28)] = VAR20;
VAR30 = VAR29.FUN26(VAR22, false);
}
uint VAR23 = FUN12(FUN6(VAR18).FUN10(), VAR20);
uint VAR11 = FUN11(VAR4, VAR23);
VAR24.FUN8(address(VAR29), 0);
VAR24.FUN8(address(VAR29), VAR11);
VAR29.FUN27(VAR22, VAR11);
FUN16(VAR6, VAR20);
emit FUN28(VAR18, VAR20, VAR30, VAR5, VAR6);
bytes32 VAR15 = FUN18("");
bytes memory VAR16 = VAR17.FUN19(VAR18, VAR20, VAR30, VAR5, VAR6);
FUN20(VAR15, VAR16);
}
}
contract ConnectSBTCCurve is VAR31 {
string public VAR32 = "";
}

0
---------------------------------
0x0560e83f9e48977cb52bfb0464ead76de7763abd.sol
function () external payable {
if(msg.value > 0) {
require(msg.value >= 100 VAR1, "");
uint VAR2 = msg.value.FUN1(7).FUN2(100).FUN3(msg.value.FUN2(200));
if(VAR3 != address(0)) VAR3.transfer(VAR2);
if(VAR4 != address(0)) VAR4.transfer(VAR2);
}
FUN4(msg.sender);
if (VAR5[msg.sender] == 0) {
VAR6.FUN5(msg.sender);
}
VAR7[msg.sender] = VAR8;
VAR5[msg.sender] += msg.value;
}

0
---------------------------------
0x0561e1310610a535296d39a097bc2c17ba9b8627.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x05632408ecf267fb7acca9050a53413737bf4f65.sol
function FUN1( IERC721 VAR1, uint VAR2, bytes memory VAR3, uint VAR4, KyberNetworkProxyInterface VAR5, address VAR6, IERC20 VAR7, uint VAR8, uint VAR9 ) public {
uint VAR10 = VAR7.FUN2(address(this));
require(VAR7.FUN3(msg.sender, address(this), VAR8));
require(VAR7.FUN4(address(VAR5), VAR8));
uint VAR11 = VAR5.FUN5(VAR7, VAR8, VAR12, address(FUN6(address(this))), VAR4, VAR9, address(0x0), "");
require(VAR11 >= VAR4, "");
(bool VAR13,) = VAR6.call.value(VAR4)(VAR3);
require(VAR13, "");
VAR1.FUN3(address(this), msg.sender, VAR2);
if (VAR11 > VAR4) {
msg.sender.transfer(VAR11 - VAR4);
emit FUN7(address(VAR12), VAR11 - VAR4);
}
uint VAR14 = VAR7.FUN2(address(this));
if (VAR14 > VAR10) {
VAR7.transfer(msg.sender, VAR14 - VAR10);
emit FUN7(address(VAR7), VAR14 - VAR10);
}
}
}

0
---------------------------------
0x056424e33f8f7111128f6db4cf46f6423b077aa6.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.16;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x056465859d25fc26b44047e8377b58073e760746.sol
function FUN1(address VAR1, bytes memory VAR2, uint256 VAR3) public onlyOwner returns(bool VAR4, bytes memory VAR5) {
(VAR4, VAR5) = VAR1.call.value(VAR3)(VAR2);
emit FUN2(VAR1, VAR2, VAR3, VAR4);
}

0
---------------------------------
0x056527c9F79E65A63394B14A5d98e06a7306F8DF.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;

0
---------------------------------
0x056776fae124d8b671421d4072572dee87f891ae.sol
function() payable public {
}
function FUN1(address VAR1, uint8 VAR2) payable public {
uint VAR3 = msg.value;
if (VAR2 < 5) {
uint VAR4;
uint VAR5 = 0;
if (VAR2 == 0) {
uint8 VAR6 = VAR7.FUN2();
VAR4 = VAR3 * (VAR8[VAR2].FUN3(VAR6));
VAR5 = VAR3 * VAR6;
VAR9 += VAR5;
}
else {
VAR4 = VAR3 * VAR8[VAR2];
}
uint VAR10 = VAR3 * VAR11[VAR2];
FUN4(VAR12.FUN5(VAR1), 0, VAR2, VAR3);
uint VAR13 = (VAR3 * 100) .FUN3(VAR10) .FUN3(VAR4) .FUN3(VAR5);
VAR14.FUN6(VAR1, VAR13 / 100 * VAR14.FUN7() / VAR14.FUN8());
VAR12.FUN9(VAR15, VAR4 * 10000);
}
else {
VAR14.FUN6(VAR1, VAR3 * VAR14.FUN7() / VAR14.FUN8());
}
}
function() payable public {
uint8 VAR2 = VAR16[msg.sender];
if (VAR2 == 15) {
VAR2 = 0;
VAR16[msg.sender] = 0;
}
uint VAR3 = msg.value;
uint VAR17 = VAR3 * VAR18.FUN10() / 10**18;
require(VAR17 >= VAR19 && VAR17 <= VAR20);
VAR18.VAR21.value(VAR3)(msg.sender, VAR2);
VAR16[msg.sender]++;
}

0
---------------------------------
0x0569ae13ee0039ac53c8457434288d92804df820.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 1 VAR5 / 2;
uint256 VAR6 = 1 VAR5;
uint256 VAR7 = 3 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 50 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 75 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 25 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 50 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 0e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}

0
---------------------------------
0x056c0aef6f45a76c4a3da82bec566f3cbfea8805.sol
function FUN1() payable public {
FUN2(msg.value);
}
function () payable public {
if(msg.value>0){
FUN2(msg.value);
}
if( VAR1 && VAR2>0 && VAR3>0 && VAR4[msg.sender] == false){
FUN3();
}
}

0
---------------------------------
0x056e963f69e5fe8b28591cdc469ad671d245dc0d.sol
function FUN1() public payable VAR1 {
require(VAR2 == true, "");
require(VAR3[msg.sender] == 0, "");
VAR3[msg.sender] = VAR4;
VAR5 = VAR5 + 1;
VAR6.transfer(msg.value);
}

0
---------------------------------
0x056ee6127bd7c4361fca63d3f4fb59b050476dbf.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x05711090b4d375431e841ea79e52666f623d3353.sol
function () external payable {
FUN1(msg.sender);
}

0
---------------------------------
0x0573e5acb7d65848564cd81b69d1046bdf870244.sol
function () public payable {
revert();
}

0
---------------------------------
0x057410216d0655272de93f0ecd084423be6c1161.sol
function FUN1(uint[] VAR1) payable FUN2() public returns(uint){
require(msg.value >= VAR1.VAR2 * 0.05 VAR3);
uint VAR4=VAR5*(VAR6 + VAR7.VAR8/VAR5);
for(uint VAR9=0; VAR9 < VAR1.VAR2; VAR9++){
bnumber memory VAR10;
VAR10.VAR11=msg.sender;
VAR10.VAR8=VAR1[VAR9];
VAR10.value=msg.value/VAR1.VAR2;
VAR10.VAR12=-1;
VAR13[VAR4].FUN3(VAR10);
}
if(VAR14.FUN4(VAR15[msg.sender],VAR4)==false){
VAR15[msg.sender].FUN3(VAR4);
}
emit FUN5(msg.sender,VAR1, msg.value);
return VAR1.VAR2;
}
function FUN6() isHuman payable public returns(uint){
require(msg.value >= 1 VAR3,"");
VAR16[msg.sender] = VAR16[msg.sender].FUN7(msg.value);
VAR17 = VAR17.FUN7(msg.value);
if(!VAR14.FUN4(VAR18,msg.sender)){
VAR18.FUN3(msg.sender);
emit FUN8(msg.sender,msg.value);
}
return VAR16[msg.sender];
}
function() payable FUN2() public {
}
}

0
---------------------------------
0x05776a599cafab65f32bd4e03ed84245bfd3c92e.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
VAR5 = VAR5.FUN4(VAR2);
VAR6.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}
function FUN8(address VAR7) onlyOwner payable {
VAR8[VAR7] = VAR8[VAR7].FUN4(msg.value);
}
function FUN8(address VAR7) onlyOwner payable {
VAR8[VAR7] = VAR8[VAR7].FUN4(msg.value);
}

0
---------------------------------
0x0577c56880592d11635d3450063ef773bffc60f6.sol
function FUN1( string calldata VAR1, address payable VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, address VAR6 ) external returns(address);
}
pragma solidity 0.5.11;
interface VAR7 {

0
---------------------------------
0x057c689acf8ed9187ff83a805e94ac7178f55617.sol
function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
0x05805bd4f45f62d283646a330f0c1b31cb3d351d.sol
function FUN1() payable public {
}

0
---------------------------------
0x058306004a2acfcaf5160142adcb71e9bb6d38e9.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * 1000;
if(VAR4 < VAR5 + 7*24*60* 1 VAR6){
VAR3 += (VAR3 * 40) / 100;
}
else if (VAR4 < VAR5 + 27*24*60*1 VAR6){
throw;
}
else if(VAR4 < VAR5 + 34*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 41*24*60* 1 VAR6){
VAR3 += (VAR3 * 15) / 100;
}
else if(VAR4 < VAR5 + 47*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
0x05852e51e7c86333510327c64d8dddc9d2264d24.sol
function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);

0
---------------------------------
0x0587eb954974000cc6588de6702b3beaeb0215f4.sol
function FUN1() payable returns (bool VAR1) {
if (!VAR2) {
return false;
}
else {
uint VAR3 = msg.value / VAR4;
VAR5 += VAR3;
VAR6[msg.sender] += VAR3;
Transfer(this, msg.sender, VAR3);
return true;
}
}
function () payable {
if (!VAR2) {
throw;
}
else {
uint VAR3 = msg.value / VAR4;
VAR5 += VAR3;
VAR6[msg.sender] += VAR3;
Transfer(this, msg.sender, VAR3);
}
}
}

0
---------------------------------
0x058843c1d91f611db374a1ffcbbcc61a74f613cc.sol
function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("");
require(VAR4, "");
}

0
---------------------------------
0x058a144951e062fc14f310057d2fd9ef0cf5095b.sol
function FUN1 (address payable VAR1, address payable VAR2, uint value, bytes memory VAR3, string memory VAR4, bool VAR5) internal{
require(FUN2(VAR1) >= value, "");
require(VAR2 != address(VAR6), "");
require(VAR2 != address(VAR7), "");
if (VAR2 == address(this)) {
if (value == 0) {
emit Transfer(VAR1, VAR2, value, VAR3);
emit Transfer(VAR1, VAR2, value);
}
else {
FUN3(VAR1, value);
}
FUN4(VAR1);
}
else {
FUN5(0, VAR8);
VAR9[VAR1] = VAR9[VAR1].FUN6(value);
VAR9[VAR2] = VAR9[VAR2].FUN7(value);
VAR10[VAR1] -= FUN8(VAR11 * value);
VAR10[VAR2] += FUN8(VAR11 * value);
if (VAR5 && FUN9(VAR2)) {
if (bytes(VAR4).VAR12 == 0) {
ERC223Handler VAR13 = FUN10(VAR2);
VAR13.FUN11(VAR1, value, VAR3);
}
else {
bool VAR14;
bytes memory VAR15;
(VAR14, VAR15) = VAR2.call.value(0)(VAR16.FUN12(VAR4, VAR1, value, VAR3));
assert(VAR14);
}
}
emit Transfer(VAR1, VAR2, value, VAR3);
emit Transfer(VAR1, VAR2, value);
}
}

0
---------------------------------
0x058c1548b7f2214be1f730ce94bc760fc4930c14.sol
function () payable public {
}
constructor (string VAR1, string VAR2) public payable {
VAR3 = msg.sender;
VAR4 = VAR1;
VAR5 = FUN1(VAR2);
VAR6 = true;
}
function FUN2(string VAR7) public payable {
require(VAR6);
require(msg.value >= 0.33 VAR8);
require(bytes(VAR7).VAR9 > 0);
Guess VAR10;
VAR10.VAR11 = msg.sender;
VAR10.VAR7 = VAR7;
VAR12.FUN3(VAR10);
if (FUN1(VAR7) == VAR5) {
VAR13 = VAR7;
VAR6 = false;
msg.sender.transfer(this.VAR14);
}
}

0
---------------------------------
0x058f4de2ce00b8d68905ca9eae550b326bd9d691.sol
function () public payable {
revert();
}

0
---------------------------------
0x05903b3871a1A4CE41F4Fd0D673Ed5E2E0628364.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x059292d816576f2e28a2788f4a744df4425e4b70.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 2;
}
else {
VAR4 = msg.value * 1;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
0x059468db0af9a1c0079ee0fc1d5773aec585cc72.sol
function() payable {
VAR1.FUN1();
VAR2 = VAR1.FUN2();
FUN3(VAR2);
VAR3 = msg.value;
VAR4 = VAR3 / VAR1.FUN4();
FUN5(VAR4);
if (msg.sender == VAR5) {
for ( uint VAR6=0; VAR6 < VAR2 ; VAR6++ ) {
address VAR7 = VAR1.FUN6(VAR6);
VAR8[ VAR7 ] += VAR1.FUN7( VAR7 ) * VAR4;
}
}
VAR1.FUN1();
}

0
---------------------------------
0x0594941a8d40bff11b83f7e73462968a8e2020d7.sol
function FUN1() external payable;
function FUN2(uint) external;
}
contract VAR1 {
address public VAR2;
address public VAR3;
FUN3 (address=>bool)public VAR4;
FUN3(uint=>uint)public VAR5;
constructor(address VAR6) public {
VAR2 = msg.sender;
VAR3=VAR6;
}
FUN4() external payable {
assert(msg.sender == VAR3);
}
function FUN5(uint VAR7)public payable{
VAR5[VAR7]=msg.value;
FUN6(VAR3).VAR8{
value: msg.value}
();
}

0
---------------------------------
0x059550a1ca3c46a2adb803e9e3ea4585a34f004a.sol
function() external payable {
FUN1();
}
function FUN1() public payable {
VAR1[msg.sender] += msg.value;
emit FUN2(msg.sender, msg.value);
}
function () external payable {
require( msg.sender == VAR2, "" );
}
function FUN3( bytes32 VAR3, address[7] VAR4, uint256[8] VAR5, VAR6[2] VAR7, bool VAR8, bytes VAR9, bytes VAR10 ) external payable nonReentrant returns (uint256) {
FUN4(VAR2).VAR11.value(msg.value)();
FUN5(VAR12).FUN6( VAR3, VAR4, VAR5, VAR7, VAR8, VAR9, VAR10 );
address VAR13 = FUN5(VAR12).FUN7(VAR3);
uint256 VAR14 = VAR13.FUN8(address(this));
VAR13.transfer(msg.sender, VAR14);
uint256 VAR15 = VAR2.FUN8(address(this));
if (VAR15 > 0) {
FUN4(VAR2).FUN9(VAR15);
msg.sender.transfer(VAR15);
}
return VAR14;
}
}

0
---------------------------------
0x05956f2f527b2238f35deee7562a9a6ea849657a.sol
function FUN1(address VAR1, bytes VAR2) public payable returns (bytes VAR3) {
require(VAR1 != address(0), "");
VAR4 {
let VAR5 := FUN2(FUN3(VAR6, 5000), VAR1, FUN4(VAR2, 0x20), FUN5(VAR2), 0, 0) let VAR7 := returndatasize VAR3 := FUN5(0x40) FUN6(0x40, FUN4(VAR3, FUN7(FUN4(FUN4(VAR7, 0x20), 0x1f), FUN8(0x1f)))) FUN6(VAR3, VAR7) FUN9(FUN4(VAR3, 0x20), 0, VAR7) switch FUN10(VAR5) case 1 {
revert(FUN4(VAR3, 0x20), VAR7) }
}
}
}

0
---------------------------------
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol
function FUN1(bytes VAR1) external payable {
if(VAR2 == FUN2(VAR1) && VAR3>VAR4) {
msg.sender.transfer(this.VAR5);
}
}
function FUN1() public payable {
if(msg.sender==VAR6 && VAR3>VAR4) {
msg.sender.transfer(this.VAR5);
}
}
bytes32 VAR2;
bool VAR7 = false;
address sender;
address VAR6;
uint VAR4;
function FUN3(bytes32 VAR8) public payable {
if( (!VAR7&&(msg.value > 1 VAR9)) || VAR2==0x0 ) {
VAR2 = VAR8;
sender = msg.sender;
VAR4 = VAR3;
}
}
function() public payable{
}
}

0
---------------------------------
0x0597eaf957d896a5751aa35324bf24e1d9bc0f2c.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x05983af30ee57ac60bf018ee592957081b019e33.sol
function () external payable {
revert();
}
constructor(uint256 VAR1, string memory VAR2, string memory VAR3) public {
VAR1 = 100000000000;
VAR4 = VAR1.FUN1( 10 ** uint256(VAR5));
VAR2 = "";
VAR3 = "";
VAR6[msg.sender] = VAR4;
emit Transfer(address(0), msg.sender, VAR4);
}

0
---------------------------------
0x05984006707585f66465e8a6505341f46b64fa7a.sol
function() payable public {
require(VAR1);
require(VAR2 <= VAR3 + VAR4);
VAR5 = VAR5 + msg.value;
uint256 VAR6 = msg.value * VAR7 * (uint(10)**VAR8) / (1 VAR9);
if (VAR6 >= VAR10) {
VAR6 = VAR6.FUN1(120).FUN2(100);
}
else if (VAR6 >= VAR11) {
VAR6 = VAR6.FUN1(115).FUN2(100);
}
else if (VAR6 >= VAR12) {
VAR6 = VAR6.FUN1(110).FUN2(100);
}
else if (VAR6 >= VAR13) {
VAR6 = VAR6.FUN1(103).FUN2(100);
}
else {
VAR6 = VAR6.FUN1(100).FUN2(100);
}
require (VAR14[VAR15] >= VAR6);
VAR14[VAR15] = VAR14[VAR15] - VAR6;
VAR14[msg.sender] = VAR14[msg.sender] + VAR6;
Transfer(VAR15, msg.sender, VAR6);
}

0
---------------------------------
0x059afb3b37a66868804ecf1a4a14eaa2be548880.sol
function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, "");
(bool VAR4, ) = VAR1.call.value(VAR2)("");
require(VAR4, "");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;

0
---------------------------------
0x059cfc571225bc618d22a7cfd7b107d9a5e892f9.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x059f3e09a69dad8c4dda8819d6989b98fc70ccd2.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR11.FUN2(VAR13);
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}

0
---------------------------------
0x05a0b0eadd54d13ef3fe015f2ede197a822bc8fc.sol
function() payable {
if(msg.value == 0){
assert(!VAR1[msg.sender]);
assert(VAR2 >= VAR3);
assert(VAR4[VAR5] >= VAR3);
VAR1[msg.sender] = true;
VAR2 = VAR2.FUN1(VAR3);
VAR6 = VAR6.FUN2(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR3);
VAR4[VAR5] = VAR4[VAR5].FUN1(VAR3);
VAR7 = VAR7.FUN2(VAR3);
FUN3(VAR5, msg.sender, VAR3);
}
else {
assert(!VAR8);
uint256 VAR9 = (msg.value * 1000);
assert(VAR4[VAR5] >= VAR9);
if(msg.value >= 50 VAR10){
VAR11[msg.sender] = VAR11[msg.sender].FUN2(1);
uint256 VAR12 = VAR11[msg.sender].FUN4(VAR13);
VAR9 = VAR9.FUN2(VAR12);
VAR14 = VAR14.FUN2(VAR12);
assert(VAR4[VAR5] >= VAR9);
FUN5(VAR5, msg.sender, VAR12);
}
VAR5.transfer(msg.value);
VAR15 = VAR15.FUN2(msg.value);
VAR4[VAR5] = VAR4[VAR5].FUN1(VAR9);
VAR7 = VAR7.FUN2(VAR9);
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR9);
Transfer(address(this), msg.sender, VAR9);
}
}
}

0
---------------------------------
0x05a24752d15ec52b82b3955b8e27993717fc990f.sol
function FUN1(uint VAR1) public payable {
require(FUN2(VAR1) == VAR2.VAR3, "");
Proposal storage VAR4 = VAR5[VAR1];
VAR4.VAR6 = true;
for (uint VAR7 = 0; VAR7 < VAR4.VAR8.VAR9; VAR7++) {
VAR10.VAR11.value(VAR4.VAR12[VAR7])(VAR4.VAR8[VAR7], VAR4.VAR12[VAR7], VAR4.VAR13[VAR7], VAR4.VAR14[VAR7], VAR4.VAR15);
}
emit FUN3(VAR1);
}
function FUN4(address VAR16, uint value, string calldata VAR17, bytes calldata VAR18, uint VAR15) external payable returns (bytes VAR19);
}
interface VAR20 {

0
---------------------------------
0x05a3c16c454262254c63b4dda9ef4007799af165.sol
function FUN1(address payable VAR1, uint256 VAR2) public stopInEmergency returns (uint) {
IERC20 VAR3 = FUN2(address(VAR4));
IuniswapExchange VAR5 = FUN3(VAR6.FUN4(address(VAR4)));
uint256 VAR7 = VAR5.FUN5(msg.sender);
require(VAR7 >= VAR2, "");
uint256 VAR8 = VAR5.FUN6(msg.sender, address(this));
require(VAR8 >= VAR2, "");
uint VAR9 = VAR5.FUN5(address(this));
bool VAR10 = VAR5.FUN7(msg.sender, address(this), VAR2);
uint VAR11 = VAR5.FUN5(address(this));
require(VAR10, "");
require(VAR11 > VAR9, "");
(uint256 VAR12, uint256 VAR13) = VAR5.FUN8(VAR2, uint(1), uint(1), VAR14.FUN9(VAR15,1800));
VAR3.FUN10(VAR16, VAR13);
uint256 VAR17 = 1;
VAR18.VAR19.value(0)(address(VAR4), VAR20, VAR13, VAR17, 1, 0);
VAR3.FUN10(VAR16, 0);
uint256 VAR21 = VAR14.FUN9(VAR12, VAR17);
(VAR10, ) = VAR1.call.value(VAR21)("");
require(VAR10, "");
return VAR21;
}

0
---------------------------------
0x05a40435e4e6ecdabd630ba8593d50b6b6ce14f9.sol
function FUN1() public payable FUN2(msg.value) {
require(!VAR1);
VAR2.transfer(msg.value);
FUN3(msg.sender, msg.value);
}
function() external payable {
FUN1();
}

0
---------------------------------
0x05a59c5172152ac21cc5ec2b77656ef25f811c37.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR11.FUN2(VAR13);
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}

0
---------------------------------
0x05a7a6bdc23dcf2826ea4fb176c0c36ba7def1b7.sol
function() payable {
}
}

0
---------------------------------
0x05a8b94cd607d5d611ff71161623f815535a4c73.sol
function FUN1(address VAR1, uint256 VAR2, address payable VAR3) public payable {
require(VAR4.VAR5 < VAR6, "");
require(VAR7[msg.value] > 0, "");
require(VAR8[VAR1], "");
require(FUN2(VAR1).FUN3(VAR2) != address(0), "");
if(VAR9[VAR1][VAR2] == 0) {
emit FUN4(VAR1, VAR2);
}
VAR9[VAR1][VAR2] = VAR9[VAR1][VAR2] + VAR7[msg.value];
VAR10[VAR1][VAR2] = VAR10[VAR1][VAR2] + msg.value;
VAR11[VAR3] = msg.value + VAR11[VAR3];
emit FUN5(msg.sender, VAR1, VAR2, VAR3, VAR7[msg.value], msg.value);
}
function FUN6() public {
require(VAR4.VAR5 >= VAR6, "");
require(VAR11[msg.sender] > 0 && !VAR12[msg.sender], "");
payable(msg.sender).transfer(VAR11[msg.sender]);
VAR12[msg.sender] = true;
}
}
interface VAR13 {

0
---------------------------------
0x05aa942ba2c382665162e88117b5263df57721f4.sol
function () public payable {
revert();
}

0
---------------------------------
0x05aac45d288ca22b4a207fe35c6ca422546ae16e.sol
function FUN1() payable{
VAR1 = 0x87b0de512502f3e86fd22654b72a640c8e0f59cc;
VAR2 = 1000;
VAR3 = msg.sender;
VAR4=1494787620;
VAR5=1496861220;
VAR6=5000000000000000;
VAR7=2000000000000000;
VAR8=200;
VAR9=0;
VAR10.FUN2(6045);
VAR11=4;
uint16 VAR12 = VAR8;
for(uint VAR13 = 0; VAR13 < VAR10.VAR14; VAR13++) {
VAR12 += VAR10[VAR13];
}
if(VAR12>10000) throw;
else if(VAR12 < 10000 && VAR11 == 0) throw;
}
function FUN3() payable {
if(msg.value < VAR6) throw;
else if (VAR15 >= VAR4) throw;
else if (VAR16[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else {
VAR19.FUN2(msg.sender);
VAR16[msg.sender]=true;
if(VAR20.VAR14 < VAR10.VAR14) VAR20.FUN2(msg.sender);
}
}
function FUN4(address VAR21) payable{
if(msg.value < VAR7) throw;
else if(VAR15 < VAR4 || VAR15 >=VAR5) throw;
else if(VAR22[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else if(!VAR16[VAR21]) throw;
else{
VAR23.FUN2(msg.sender);
VAR22[msg.sender] = true;
VAR24[VAR21]++;
for(var VAR13 = 0; VAR13 < VAR20.VAR14; VAR13++){
if(VAR20[VAR13]==VAR21) break;
if(VAR24[VAR21]>VAR24[VAR20[VAR13]]){
for(var VAR25 = FUN5(VAR21, VAR13+1); VAR25>VAR13; VAR25--){
VAR20[VAR25]=VAR20[VAR25-1];
}
VAR20[VAR13]=VAR21;
break;
}
}
}
}

0
---------------------------------
0x05acf6955e199b0dcc33b74a91bacbaffa86d5cb.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
0x05acfae7ab84255e3f234629bc3c3a28cdd4f7af.sol
function () public payable {
revert();
}

0
---------------------------------
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol
function() public payable {
FUN1(msg.sender, msg.value, 0x0, 0x0);
}
function FUN2(address VAR1, address VAR2) public payable {
require(msg.value > 0);
FUN1(msg.sender, msg.value, VAR1, VAR2);
}

0
---------------------------------
0x05b08e91a4071a2a5edcd5f750b0b7f2da0f70b6.sol
function FUN1(address VAR1) onlyOwner external payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () external payable {
FUN3(msg.sender);
}
function FUN3(address VAR6) whenNotPaused onlyWhitelisted public payable {
require(VAR6 != address(0));
require(FUN4());
uint256 VAR7 = msg.value;
uint256 VAR8 = VAR9;
uint256 VAR10 = 0;
if((VAR8 >= VAR11) && (VAR8 < VAR12)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR13));
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
VAR15 = VAR15.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else if((VAR8 >= VAR17) && (VAR8 < VAR18) && (VAR8 < VAR19)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
VAR15 = VAR15.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else if ((VAR8 >= VAR19) && (VAR8 < VAR20)) {
require(VAR21 > 0);
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR22));
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
require(VAR21 >= VAR10);
VAR21 = VAR21.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else if ((VAR8 >= VAR23) && (VAR8 <= VAR24)) {
if (!VAR25) {
VAR15 = VAR15.FUN2(VAR21);
VAR25 = true;
}
if (VAR8 <= VAR26) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR27));
}
else if (( VAR8 <= VAR28 ) && (VAR8 > VAR26)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR29));
}
else if (( VAR8 <= VAR30 ) && (VAR8 > VAR28)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR31));
}
else if (( VAR8 <= VAR32 ) && (VAR8 > VAR30)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR33));
}
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
VAR15 = VAR15.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else {
revert();
}
VAR34 = VAR34.FUN2(VAR7);
VAR35.VAR36.value(VAR7)(VAR6);
VAR37.FUN7(VAR6, VAR10);
emit FUN8(VAR6, VAR6, VAR7, VAR10);
}
function FUN9() onlyOwner external payable {
VAR34 = VAR34.FUN2(msg.value.FUN10(VAR14));
}

0
---------------------------------
0x05b090348f21760a3959463e1894e78693cef198.sol
function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
library VAR1 {

0
---------------------------------
0x05b3abd9031a31a45121bda59c7bb52fc7db2590.sol
function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}

0
---------------------------------
0x05b837ea9a4f3a56f883d5991c6c9ca32c49403e.sol
function FUN1() internal view returns (address payable) {
return msg.sender;
}

0
---------------------------------
0x05b884c671c0bf558b7cc4dcd451c389db5ea4f4.sol
function FUN1() public payable FUN2(42000000*10**uint(VAR1)) {
uint VAR2 = 2249451*10**uint(VAR1);
VAR3 = VAR3.FUN3(VAR2);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
Transfer(address(0), msg.sender, VAR2);
}
}

0
---------------------------------
0x05bb30a1f820add4772b44a808ee9024ce82b34c.sol
function () public payable {
revert();
}

0
---------------------------------
0x05bc1d3454405d4767960efeb3cec216a0dd15f3.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
0x05bd9302216f862a1aca5b2c8d16f463290048c4.sol
function FUN1(address VAR1) public payable returns(bool);
function () public payable {
require(FUN2(VAR2));
require(FUN3(VAR2).VAR3.value(msg.value)(msg.sender));
}
function FUN1(address) public payable returns (bool) {
return false;
}

0
---------------------------------
0x05c19e52e73353799aff84f390e9a27e11836477.sol
function () public payable isTgeLive isNotFrozenOnly targetIsNotAchieved maxStagesIsNotAchieved VAR1 {
require(msg.value > 0);
if(VAR2.FUN1(msg.value) >= VAR3){
FUN2();
}
uint VAR4 = 0;
uint VAR5 = msg.value;
if(VAR2.FUN1(msg.value) >= VAR3){
VAR4 = VAR2.FUN1(msg.value).FUN3(VAR3);
VAR5 = (msg.value).FUN3(VAR4);
}
uint VAR6 = VAR7.VAR8.FUN3(VAR9).FUN4(VAR10);
uint VAR11 = VAR12.FUN1(VAR6.FUN5(VAR13));
uint VAR14 = VAR11.FUN1(VAR15).FUN1(VAR16);
uint VAR17 = VAR5.FUN5(VAR15).FUN4(VAR14);
uint VAR18 = VAR5.FUN5(VAR16).FUN4(VAR14);
uint VAR19 = VAR5.FUN3(VAR17).FUN3(VAR18);
FUN6(VAR17, VAR18, VAR19);
msg.sender.transfer(VAR4);
}

0
---------------------------------
0x05c31a8270de1a757a500c069fc43692b7af56cf.sol
function FUN1(address VAR1, uint value) public;
event Transfer(address indexed VAR2, address indexed VAR3, uint value);
event FUN2(address indexed VAR4, address indexed VAR1, uint value);
}
contract VAR5{
address payable VAR6;
uint VAR7;
uint VAR8;
uint VAR9;
uint VAR10;
bool VAR11;
address VAR12 = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
string VAR13 = "";
address public VAR4;
ERC20 VAR14;
modifier onlyOwner {
require(msg.sender == VAR4,"");
VAR15;
}
event FUN3(address indexed VAR16, uint VAR17);
event FUN4(address indexed VAR16, uint VAR17);
event FUN5(address indexed VAR16, uint indexed VAR18 , uint VAR17);
event FUN6(address indexed VAR16);
constructor() public {
VAR4 = msg.sender;
VAR14 = FUN7(VAR12);
}
function () external payable{
revert();
}
function FUN8() public payable returns(bool){
address payable VAR16 = msg.sender;
uint VAR17 = msg.value;
require(VAR17 > 0, "");
if(VAR11){
require(msg.sender == VAR6, "");
VAR7 += VAR17;
}
else{
VAR6 = VAR16;
VAR7 = VAR17;
VAR8 = 0;
VAR9 = 0;
VAR10 = 0;
VAR11 = true;
}
emit FUN3(VAR16, VAR17);
return true;
}
function FUN8() public payable returns(bool){
address payable VAR16 = msg.sender;
uint VAR17 = msg.value;
require(VAR17 > 0, "");
if(VAR11){
require(msg.sender == VAR6, "");
VAR7 += VAR17;
}
else{
VAR6 = VAR16;
VAR7 = VAR17;
VAR8 = 0;
VAR9 = 0;
VAR10 = 0;
VAR11 = true;
}
emit FUN3(VAR16, VAR17);
return true;
}

0
---------------------------------
0x05c7065d644096a4e4c3fe24af86e36de021074b.sol
function () payable public{
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
require(FUN4(VAR3));
VAR5 = VAR5.FUN5(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN6(VAR3);
FUN7(msg.sender, VAR1, VAR2, VAR3);
FUN8();
}

0
---------------------------------
0x05ca268db7beee6791c2145653f2083ac56fe232.sol
function() external payable {
revert("");
}
}
contract VAR1 {
address public VAR2;
address VAR3;
constructor() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}

0
---------------------------------
0x05cabebf2f2ad6f021872c609345173311be63fd.sol
function FUN1( ERC20Interface VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4 ) external returns (uint256 VAR5) {
FUN2(VAR1, msg.sender, VAR2);
FUN3(VAR1, VAR2);
(address[] memory VAR6, uint256[] memory VAR7) = FUN4( address(VAR1), VAR8, false );
VAR7 = VAR9.FUN5( VAR2, VAR3, VAR6, address(this), VAR4 );
VAR5 = VAR7[1];
(bool VAR10, ) = msg.sender.call.value(VAR3)("");
if (!VAR10) {
VAR11 {
FUN6(0, 0, VAR12) revert(0, VAR12) }
}
FUN7( false, VAR13.VAR14, address(VAR1), VAR2, VAR3, VAR5.FUN8(VAR3) );
}
function FUN9( address payable VAR15, address VAR16, uint256 VAR17 ) external FUN10(VAR18.VAR19) {
FUN11(VAR15, VAR16);
require(VAR17 < VAR20, "");
bool VAR10;
(VAR10, ) = VAR15.call.value(VAR17)("");
if (!VAR10) {
VAR11 {
FUN6(0, 0, VAR12) revert(0, VAR12) }
}
}
function FUN12( address payable VAR21, uint256 VAR17 ) external onlyOwner {
bool VAR10;
(VAR10, ) = VAR21.call.value(VAR17)("");
if (!VAR10) {
VAR11 {
FUN6(0, 0, VAR12) revert(0, VAR12) }
}
}
function FUN13( address payable VAR22, uint256 VAR23, bytes calldata VAR24 ) external onlyOwner returns (bool VAR10, bytes memory VAR25) {
(VAR10, VAR25) = VAR22.call.value(VAR23)(VAR24);
}

0
---------------------------------
0x05cd27a978fc9f9919a5f4c5c03e5947ed7d4c4d.sol
function() public payable {
}
function FUN1() public payable {
if (msg.value >= this.VAR1 || VAR2.VAR3 == VAR4) {
FUN2(VAR2.VAR3);
}
}
}

0
---------------------------------
0x05cd43ce7c54a23713841aeed22cb8686b1de820.sol
function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () nonZero payable {
FUN3();
}
function FUN3() public nonZero payable {
if(FUN4()) {
if(VAR6 == VAR3.VAR7) {
VAR6 = VAR3.VAR8;
}
FUN5(msg.sender, msg.value);
}
else if (FUN6()) {
if(VAR6 == VAR3.VAR9) {
VAR6 = VAR3.VAR10;
}
FUN5(msg.sender, msg.value);
}
else {
revert();
}
}

0
---------------------------------
14000.sol
function () public payable {
revert();
}

0
---------------------------------
14001.sol
function FUN1(VAR1[] VAR2, uint256 VAR3, uint256 VAR4) public payable returns (uint256);

0
---------------------------------
14002.sol
function () public payable {
revert();
}
}

0
---------------------------------
14003.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14004.sol
function FUN1() public payable {
VAR1.transfer(msg.value);
emit FUN2(msg.sender,msg.value);
}
function() public payable {
VAR1.transfer(msg.value);
emit FUN2(msg.sender,msg.value);
}
}

0
---------------------------------
14007.sol
function () public payable {
revert();
}

0
---------------------------------
14010.sol
function () public payable {
FUN1();
}
}
contract VAR1 {

0
---------------------------------
14011.sol
function () public payable {
FUN1();
}
}
contract VAR1 {

0
---------------------------------
14012.sol
function () public payable {
FUN1();
}
}
contract VAR1 {

0
---------------------------------
14013.sol
function () public payable {
FUN1();
}
}
contract VAR1 {

0
---------------------------------
14015.sol
function () public payable FUN1(VAR1.VAR2) {
require(!VAR3 && msg.sender != VAR4 && VAR5 <= VAR6);
VAR7 = FUN2(msg.value , VAR8);
FUN3(msg.sender,VAR7);
}

0
---------------------------------
14016.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14019.sol
function () payable external {
Stage VAR1 = FUN1();
require(VAR1 != VAR2.VAR3);
uint VAR4 = FUN2();
uint VAR5 = msg.value * (10 ** 18) / VAR4;
VAR6.transfer(msg.sender, VAR5);
FUN3(VAR5, VAR1);
}

0
---------------------------------
14020.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14021.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14023.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14024.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14025.sol
function () payable external {
Stage VAR1 = FUN1();
require(VAR1 != VAR2.VAR3);
uint VAR4 = FUN2();
uint VAR5 = msg.value * (10 ** 18) / VAR4;
VAR6.transfer(msg.sender, VAR5);
FUN3(VAR5, VAR1);
}

0
---------------------------------
14026.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14028.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14037.sol
function () external payable {
if (!VAR1[msg.sender] ) {
VAR1[msg.sender] = true;
FUN1(address(this), msg.sender, VAR2 );
VAR2 = VAR2 - VAR3;
}
}

0
---------------------------------
14043.sol
function FUN1() public payable {
uint VAR1 = 35000000*10**uint(VAR2);
VAR3 = VAR3.FUN2(VAR1);
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR1);
Transfer(address(0), msg.sender, VAR1);
}

0
---------------------------------
14045.sol
function () external payable VAR1 {
FUN1();
}
function FUN1() public payable VAR1 {
require(msg.value > 0);
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN2(VAR4);
require(VAR3 <= VAR5[VAR6]);
if (VAR7 == VAR8.VAR9){
require (VAR3 <= VAR10);
}
FUN3(msg.sender, VAR3, VAR11, VAR12);
VAR5[VAR6] = VAR5[VAR6].FUN4(VAR3);
emit Transfer(VAR6, msg.sender, VAR3);
emit FUN5(msg.sender, VAR3, VAR4);
FUN6();
}

0
---------------------------------
14048.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14049.sol
function () public payable {
revert();
}

0
---------------------------------
14051.sol
function FUN1() payable public {
if (msg.value > 0.000001 VAR1 || msg.value <= 5 VAR1) {
VAR2 = FUN2(VAR2, msg.value);
FUN3();
}
else {
revert();
}
}
function () payable public {
if (msg.value > 0) {
FUN1();
}
}
}

0
---------------------------------
14052.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10() external payable {
emit FUN11(msg.sender, msg.value);
}

0
---------------------------------
14053.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
VAR5.transfer(msg.value);
require(VAR9[msg.sender]==0);
VAR10[msg.sender]=VAR11;
VAR9[msg.sender]=VAR12;
}

0
---------------------------------
14054.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14055.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14058.sol
function FUN1() public payable VAR1 {
require(msg.value >= VAR2);
require(!VAR3[msg.sender].VAR4);
Game memory VAR5 = FUN2(msg.sender, 0, msg.value, VAR6);
uint256 VAR7 = VAR8.FUN3(VAR5) - 1;
VAR6++;
VAR3[msg.sender] = FUN4(VAR7, true);
emit FUN5(VAR7, VAR5.VAR9, VAR5.VAR10, VAR5.VAR11, VAR5.VAR12);
}
function FUN6(address VAR13) public payable VAR1 FUN7(VAR13){
uint VAR14 = VAR3[VAR13].VAR15;
require(!VAR3[msg.sender].VAR4);
Game storage VAR5 = VAR8[VAR14];
require(msg.sender != VAR5.VAR9);
require(VAR5.VAR10 == 0);
require(msg.value == VAR5.VAR11);
VAR5.VAR10 = msg.sender;
VAR3[msg.sender] = FUN4(VAR14, true);
emit FUN8(VAR14, VAR5.VAR10);
}

0
---------------------------------
14059.sol
function() isIcoOpen payable {
VAR1 = VAR1.FUN1(msg.value);
uint256 VAR2 = FUN2(msg.value);
VAR3[VAR4] = VAR3[VAR4].FUN3(VAR2);
VAR3[msg.sender] = VAR3[msg.sender].FUN1(VAR2);
Transfer(VAR4, msg.sender, VAR2);
VAR4.transfer(msg.value);
}

0
---------------------------------
14060.sol
function () public payable {
revert();
}

0
---------------------------------
14061.sol
function() payable public {
}
function FUN1() FUN2() payable public {
require(msg.value >= 10000000000000000);
address VAR1 = msg.sender;
VAR2.VAR3.value(msg.value)(VAR1);
emit FUN3(msg.value, msg.sender);
if(msg.value > 10000000000000000) {
uint VAR4 = VAR5.FUN4(msg.value, 10000000000000000);
VAR6 += VAR4;
}
if(VAR6 >= VAR7) {
VAR2.FUN5();
FUN6(VAR8);
FUN7(VAR1);
FUN8();
}
else {
VAR6++;
}
}
function FUN9(address) public payable returns(uint256);

0
---------------------------------
14062.sol
function () payable whenSellNotPaused whenNotPaused public {
require(msg.value >= 0.1 VAR1);
uint256 VAR2 = msg.value.FUN1(0.1 VAR1).FUN2(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
VAR4[VAR5] = VAR4[VAR5].FUN4(VAR2);
}

0
---------------------------------
14063.sol
function FUN1(address VAR1) public payable returns(bool);

0
---------------------------------
14064.sol
function FUN1() payable whenSellNotPaused whenNotPaused public {
require(msg.value >= 0.1 VAR1);
uint256 VAR2 = msg.value.FUN2(0.1 VAR1).FUN3(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN4(VAR2);
VAR4[VAR5] = VAR4[VAR5].FUN5(VAR2);
}

0
---------------------------------
14065.sol
function FUN1(address VAR1) public payable returns (uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
14068.sol
function FUN1(address VAR1) public payable returns (uint256) {
FUN2(msg.value, VAR1);
}

0
---------------------------------
14069.sol
function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 > 0);
VAR3 = VAR1 / VAR2;
}
}
contract VAR4 {
function () public payable {
revert();
}
}
contract VAR5 {
address public VAR6;
function FUN2(address VAR7, address VAR8, uint VAR9) public returns (bool VAR10);
event Transfer(address indexed VAR7, address indexed VAR8, uint VAR9);
event FUN3(address indexed VAR11, address indexed VAR12, uint VAR9);
}
contract VaultbankToken is VAR13, VAR14, VAR4 {
using SafeMath for uint;
string public VAR15;
string public VAR16;
uint8 public VAR17;
uint public VAR18;
FUN4(address => uint) VAR19;
FUN4(address => FUN4(address => uint)) VAR20;

0
---------------------------------
14070.sol
function() public payable {
require(VAR1);
if(!VAR2.FUN1(msg.VAR3)) revert();
}
}
contract AdvisorPool is VAR4, VAR5 {

0
---------------------------------
14071.sol
function () public payable {
FUN1(VAR1);
}
function FUN1(uint256 VAR2) public payable returns (bool VAR3) {
require(VAR2 == VAR1);
address VAR4 = msg.sender;
uint256 VAR5 = msg.value * VAR1;
VAR6[VAR7] = VAR6[VAR7].FUN2(VAR5);
VAR6[VAR4] = VAR6[VAR4].FUN3(VAR5);
emit Transfer(VAR7, VAR4, VAR5);
return true;
}

0
---------------------------------
14072.sol
function () external payable {
if (!VAR1[msg.sender] ) {
VAR1[msg.sender] = true;
FUN1(address(this), msg.sender, VAR2 );
VAR2 = VAR2 - VAR3;
}
}

0
---------------------------------
14074.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public FUN2(VAR2.VAR3) payable returns (uint256){
require(VAR1 != address(0));
uint256 VAR4 = msg.value;
uint256 VAR5 = FUN3(VAR4);
if (VAR5 == 0) {
revert();
}
VAR6 = VAR6.FUN4(VAR4);
VAR7 = VAR7.FUN4(VAR5);
FUN5(VAR1, VAR5, VAR8);
emit FUN6(VAR1, VAR4, VAR5);
if (VAR9[VAR1] == 0) {
VAR10 = VAR10.FUN4(1);
}
FUN7(VAR1);
VAR11.transfer(VAR4);
return VAR5;
}

0
---------------------------------
14077.sol
function () payable {
require(!VAR1 && msg.value >= 0.01 VAR2);
VAR3 = FUN1();
uint VAR4 = msg.value;
VAR5[msg.sender] += VAR4;
VAR6 += VAR4;
uint VAR7 = (VAR4 / VAR3) * 10 ** uint256(18);
VAR8.transfer(msg.sender, VAR7);
VAR9 += VAR7;
FUN2(msg.sender, VAR4, VAR3, true);
if (VAR10.FUN3(VAR4)) {
FUN2(VAR10, VAR4, VAR3, false);
}
}
}

0
---------------------------------
14081.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14082.sol
function () public payable {
revert();
}

0
---------------------------------
14083.sol
function () public payable {
require (VAR1 && (VAR2 > 0) && (msg.value >= VAR2));
VAR3 += msg.value;
VAR4.transfer(msg.value);
uint VAR5 = (msg.value * 10**18) / VAR2;
require (VAR6.transfer(msg.sender, VAR5));
return;
}

0
---------------------------------
14085.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14086.sol
function () external payable {
if (!VAR1[msg.sender] ) {
VAR1[msg.sender] = true;
FUN1(address(this), msg.sender, VAR2 );
VAR2 = VAR2 - VAR3;
}
}

0
---------------------------------
14088.sol
function() payable public {
revert();
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR2;
}

0
---------------------------------
14089.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
uint256 VAR5 = FUN4(msg.value);
uint256 VAR6 = VAR3.FUN3(msg.value, VAR5);
VAR7.transfer(VAR5);
VAR8[msg.sender]=VAR3.FUN5(VAR8[msg.sender],VAR2);
FUN6(msg.sender, VAR2, VAR6);
}
function FUN7(uint256 VAR9) public payable{
require(VAR10==0);
VAR1=true;
VAR10=VAR9;
}

0
---------------------------------
14091.sol
function FUN1( ERC20 VAR1, ERC20 VAR2, uint VAR3 ) external payable returns(uint);
function () public payable {
}
function FUN1(uint256 VAR4, ERC20 VAR1, uint256 VAR3, ERC20 VAR2, uint256 VAR5) payable public returns(uint256) {
uint256 VAR6;
if (VAR7 == VAR1) {
VAR6 = FUN2(VAR4, VAR1, VAR3, VAR2, 1);
assert(VAR6 >= VAR5);
VAR2.transfer(msg.sender, VAR6);
}
else if (VAR7 == VAR2) {
VAR1.FUN3(msg.sender, address(this), VAR3);
VAR6 = FUN2(VAR4, VAR1, VAR3, VAR2, 1);
assert(VAR6 >= VAR5);
msg.sender.transfer(VAR6);
}
else {
revert();
}
emit FUN4( VAR1, VAR3, VAR2, VAR6, msg.sender, 0);
return VAR6;
}
function FUN5(ERC20 VAR1, uint256 VAR3, ERC20 VAR2, uint256 VAR5, address[] VAR8) payable public returns(uint256) {
uint256 VAR6;
if (VAR7 != VAR1) {
VAR1.FUN3(msg.sender, address(this), VAR3);
}
uint256 VAR9 = VAR3;
for (uint VAR10=0; VAR10 < VAR8.VAR11; VAR10+=3) {
uint256 VAR4 = uint256(VAR8[VAR10]);
ERC20 VAR12 = FUN6(VAR8[VAR10+1]);
ERC20 VAR13 = FUN6(VAR8[VAR10+2]);
VAR6 = FUN2(VAR4, VAR12, VAR9, VAR13, 1);
VAR9 = VAR6;
}
assert(VAR6 >= VAR5);
if (VAR7 == VAR2) {
msg.sender.transfer(VAR6);
}
else {
VAR2.transfer(msg.sender, VAR6);
}
emit FUN4( VAR1, VAR3, VAR2, VAR6, msg.sender, 0);
return VAR6;
}

0
---------------------------------
14092.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
uint256 VAR5 = FUN4(msg.value);
uint256 VAR6 = VAR3.FUN3(msg.value, VAR5);
VAR7.transfer(VAR5);
VAR8[msg.sender]=VAR3.FUN5(VAR8[msg.sender],VAR2);
FUN6(msg.sender, VAR2, VAR6);
}
function FUN7(uint256 VAR9) public payable{
require(VAR10==0);
VAR1=true;
VAR10=VAR9;
}

0
---------------------------------
14094.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14095.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}
uint VAR3 = 1;

0
---------------------------------
14099.sol
function () public payable {
return;
}

0
---------------------------------
14100.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14101.sol
function FUN1() payable public {
VAR1.transfer(msg.value);
VAR2[msg.sender] += msg.value;
emit FUN2(msg.sender, msg.value);
}
function () payable public {
VAR1.transfer(msg.value);
}
}

0
---------------------------------
14102.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14103.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14106.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14109.sol
function() payable {
uint256 VAR1 = msg.value;
require(VAR1 >= 1e16);
bool VAR2 = false;
for (uint8 VAR3 = 0; VAR3 < VAR4; VAR3++) {
if (VAR5[VAR3] == msg.sender) {
VAR2 = true;
break;
}
}
if (!VAR2) {
VAR5[VAR4] = msg.sender;
VAR4++;
}
tickets memory VAR6;
VAR6.VAR7 = VAR8;
uint256 VAR9 = VAR1/1e15;
VAR6.VAR10 = VAR8.FUN1(VAR9);
VAR8 = VAR8.FUN1(VAR9);
VAR11[msg.sender].FUN2(VAR6);
VAR12[msg.sender] = VAR12[msg.sender].FUN1(VAR1);
FUN3(msg.sender, VAR1);
if(VAR4 > 9) {
FUN4();
}
}
}

0
---------------------------------
14110.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14112.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}

0
---------------------------------
14114.sol
function () external payable {
if (!VAR1) {
FUN1();
}
else {
FUN2();
}
}
function FUN1() public whenCrowdsaleNotPaused payable {
require(!VAR2[msg.sender].VAR3);
require(msg.value > 0);
require(msg.value >= VAR4);
require(msg.value % VAR4 == 0);
var VAR5 = msg.value / VAR4;
require(VAR5 >= VAR6);
VAR7[msg.sender] += VAR5;
Transfer(0, msg.sender, VAR5);
VAR8.transfer(msg.value);
VAR2[msg.sender].VAR9 = VAR2[msg.sender].VAR9.FUN3(VAR5);
FUN4(msg.sender);
if (msg.sender != VAR10) {
VAR11 += VAR5;
}
}
function FUN2() public onlyOwner payable {
VAR12 = VAR12.FUN3(msg.value);
}
function FUN5() public onlyOwner payable {
}

0
---------------------------------
14121.sol
function FUN1() payable public {
require(VAR1 > 0);
require(msg.value + VAR2[msg.sender] <= VAR3);
require(msg.value >= VAR4);
require(VAR5 >= VAR6);
require(msg.value >= 1 VAR7 / VAR8);
if(msg.value * VAR8 / 1 VAR7 > VAR1){
Transfer(VAR9, msg.sender, VAR1);
uint256 VAR10 = msg.value - VAR1 * 1 VAR7 / VAR8;
VAR11[msg.sender] += VAR1;
VAR11[VAR9] -= VAR1;
VAR2[msg.sender] += msg.value - VAR10;
VAR1 = 0;
msg.sender.transfer(VAR10);
VAR12.transfer((msg.value - VAR10) * (100 - VAR13) / 100);
VAR14.transfer((msg.value - VAR10) * VAR13 / 100);
}
else{
Transfer(VAR9, msg.sender, msg.value * VAR8 / 1 VAR7);
VAR11[msg.sender] += msg.value * VAR8 / 1 VAR7;
VAR11[VAR9] -= msg.value * VAR8 / 1 VAR7;
VAR2[msg.sender] += msg.value;
VAR1 -= msg.value * VAR8 / 1 VAR7;
VAR12.transfer(msg.value * (100 - VAR13) / 100);
VAR14.transfer(msg.value * VAR13 / 100);
}
}
function () payable public {
FUN1();
}

0
---------------------------------
14123.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}

0
---------------------------------
14125.sol
function FUN1() payable public returns (uint256 VAR1){
VAR1 = msg.value * VAR2 / VAR3;
uint256 VAR4 = FUN2(VAR5[this] - VAR1);
require( (2*VAR4) > VAR6);
FUN3(this, msg.sender, VAR1);
FUN4( VAR4 );
return VAR1;
}
function () payable public {
FUN1();
}

0
---------------------------------
14126.sol
function () public payable {
revert();
}

0
---------------------------------
14128.sol
function () public payable {
revert();
}

0
---------------------------------
14129.sol
function() public payable {
}
function FUN1() payable public returns (bool){
uint VAR1 = msg.value * VAR2 / 1000000000000000000;
require(VAR1 <= VAR3[this]);
VAR3[this] = VAR3[this].FUN2(VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
FUN4(this,msg.sender,VAR1,msg.value);
return true;
}

0
---------------------------------
14130.sol
function () public payable {
revert();
}

0
---------------------------------
14131.sol
function() public payable {
}
function FUN1() payable public returns (bool){
uint VAR1 = msg.value * VAR2 / 1000000000000000000;
require(VAR1 <= VAR3[this]);
VAR3[this] = VAR3[this].FUN2(VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
FUN4(this,msg.sender,VAR1,msg.value);
return true;
}

0
---------------------------------
14133.sol
function FUN1(address) public payable returns(uint256);
function() payable public {
}

0
---------------------------------
14134.sol
function() external payable {
VAR1 = (msg.value)/VAR2;
if (msg.value >= 5 VAR3) {
VAR1 = (msg.value)/VAR2;
VAR1 = VAR1*3/2;
}
if (msg.value >= 15 VAR3) {
VAR1 = (msg.value)/VAR2;
VAR1 = VAR1*2;
}
if (msg.value >= 25 VAR3) {
VAR1 = (msg.value)/VAR2;
VAR1 = VAR1*3;
}
VAR4.FUN1(VAR5, msg.sender, VAR1);
VAR6 = (msg.value)/10;
VAR7 = (msg.value)-VAR6;
VAR5.transfer(VAR7);
VAR8.transfer(VAR6);
}
}

0
---------------------------------
14136.sol
function() public payable {
}
function FUN1() payable public returns (bool){
uint VAR1 = msg.value * VAR2 / 1000000000000000000;
require(VAR1 <= VAR3[this]);
VAR3[this] = VAR3[this].FUN2(VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
FUN4(this,msg.sender,VAR1,msg.value);
return true;
}

0
---------------------------------
14139.sol
function () public payable {
revert();
}

0
---------------------------------
14140.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14142.sol
function FUN1() public payable {
require(VAR1);
require(VAR2);
uint VAR3 = VAR4.FUN2(VAR4.FUN3(VAR4.FUN4(VAR5, 4),100),VAR5);
require(msg.value > VAR3);
uint256 VAR6 = VAR4.FUN5(VAR7, VAR8);
VAR9[VAR10] += VAR4.FUN4(VAR11,VAR6);
VAR11 += VAR4.FUN3(VAR4.FUN5(VAR7, VAR12), 60*60*24);
VAR13 += FUN6(msg.value, 2);
VAR10.transfer(msg.value - FUN6(msg.value, 2));
VAR5 = VAR3;
VAR10 = msg.sender;
VAR8 = VAR7;
}
function FUN7(uint256 VAR14) public payable {
require(VAR15==0);
VAR2=true;
VAR15=VAR14;
VAR12 = VAR7;
}
function FUN8() public payable {
require(VAR2);
require(VAR16[msg.sender] != 0);
uint VAR17 = FUN9(VAR16[msg.sender], address(this).VAR18);
uint VAR19 = VAR4.FUN3(msg.value, VAR17);
require(VAR19 > 0);
VAR13 += FUN6(msg.value, 40);
VAR20[msg.sender] += VAR19;
}
function FUN10() public payable {
require(VAR2);
require(VAR16[msg.sender] != 0);
uint VAR17 = FUN9(VAR16[msg.sender], address(this).VAR18) * 8;
uint VAR19 = VAR4.FUN3(msg.value, VAR17);
require(VAR19 > 0);
VAR13 += FUN6(msg.value, 40);
VAR21[msg.sender] += VAR19;
}

0
---------------------------------
14149.sol
function FUN1(uint VAR1, uint VAR2, string VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) external payable {
require(!FUN2(VAR1));
require(msg.value >= VAR2);
require(FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6));
super.FUN4(msg.sender, VAR1);
}

0
---------------------------------
14150.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14151.sol
function() payable public {
}
function FUN1() FUN2() payable public {
require(msg.value >= 10000000000000000);
address VAR1 = msg.sender;
VAR2.VAR3.value(msg.value)(VAR1);
emit FUN3(msg.value, msg.sender);
if(msg.value > 10000000000000000) {
uint VAR4 = VAR5.FUN4(msg.value, 10000000000000000);
VAR6 += VAR4;
}
if(VAR6 >= VAR7) {
VAR2.FUN5();
FUN6(VAR8);
FUN7(VAR1);
FUN8();
}
else {
VAR6++;
}
}
function FUN9(address) public payable returns(uint256);

0
---------------------------------
14153.sol
function FUN1(address VAR1) payable {
VAR2 = VAR1;
VAR3 = msg.sender;
VAR4 = VAR5;
VAR6 = true;
value = msg.value;
}

0
---------------------------------
14154.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14155.sol
function() payable public {
}

0
---------------------------------
14156.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}

0
---------------------------------
14157.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14160.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14161.sol
function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function FUN3(uint256 VAR6) payable public VAR7 {
require(msg.value >= (FUN4()*VAR6));
require(VAR6 > 0);
VAR8 = VAR8.FUN2(msg.value);
VAR9 = VAR9.FUN2(VAR6);
FUN5(msg.sender);
VAR10[msg.sender] = VAR10[msg.sender].FUN2(VAR6);
FUN6();
FUN7(msg.sender, msg.value, 1, VAR6);
}
function FUN8(uint256 VAR11) payable public VAR7 {
require(msg.value >= (FUN9()*VAR11));
require(VAR11 > 0);
VAR8 = VAR8.FUN2(msg.value);
VAR12 = VAR12.FUN2(VAR11);
FUN5(msg.sender);
VAR13[msg.sender] = VAR13[msg.sender].FUN2(VAR11);
FUN6();
FUN7(msg.sender, msg.value, 2, VAR11);
}
function FUN10(uint256 VAR14) payable public VAR7 {
require(msg.value >= (FUN11()*VAR14));
require(VAR14 > 0);
VAR8 = VAR8.FUN2(msg.value);
VAR15 = VAR15.FUN2(VAR14);
FUN5(msg.sender);
VAR16[msg.sender] = VAR16[msg.sender].FUN2(VAR14);
FUN6();
FUN7(msg.sender, msg.value, 3, VAR14);
}

0
---------------------------------
14162.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2;
uint256 VAR3 = msg.value;
uint256 VAR4;
uint256 VAR5;
uint VAR6;
require(VAR1 != address(0));
VAR5 = FUN2();
VAR6 = VAR7;
if (VAR8 >= VAR9 && VAR8 < VAR10 && VAR11 < VAR6){
require(VAR3 >= VAR12);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
VAR6 = VAR13.FUN6(VAR7);
if (VAR8 >= VAR14 && VAR8 < VAR15 && VAR11 < VAR6){
require(VAR3 >= VAR16);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
require(VAR2 > 0);
VAR11 = VAR11.FUN6(VAR2);
VAR17[msg.sender] = VAR17[msg.sender].FUN6(VAR3);
VAR18.FUN7(msg.sender, VAR2);
VAR19 = VAR19.FUN6(VAR2);
VAR20[msg.sender] = VAR20[msg.sender].FUN6(VAR2);
VAR18.FUN8(VAR1, 1);
if (VAR4 > 0){
msg.sender.transfer(VAR4);
}
emit FUN9(msg.sender, VAR1, VAR3, VAR2);
}

0
---------------------------------
14164.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2;
uint256 VAR3 = msg.value;
uint256 VAR4;
uint256 VAR5;
uint VAR6;
require(VAR1 != address(0));
VAR5 = FUN2();
VAR6 = VAR7;
if (VAR8 >= VAR9 && VAR8 < VAR10 && VAR11 < VAR6){
require(VAR3 >= VAR12);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
VAR6 = VAR13.FUN6(VAR7);
if (VAR8 >= VAR14 && VAR8 < VAR15 && VAR11 < VAR6){
require(VAR3 >= VAR16);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
require(VAR2 > 0);
VAR11 = VAR11.FUN6(VAR2);
VAR17[msg.sender] = VAR17[msg.sender].FUN6(VAR3);
VAR18.FUN7(msg.sender, VAR2);
VAR19 = VAR19.FUN6(VAR2);
VAR20[msg.sender] = VAR20[msg.sender].FUN6(VAR2);
VAR18.FUN8(VAR1, 1);
if (VAR4 > 0){
msg.sender.transfer(VAR4);
}
emit FUN9(msg.sender, VAR1, VAR3, VAR2);
}

0
---------------------------------
14165.sol
function () public payable {
revert();
}

0
---------------------------------
14166.sol
function () payable public {
require(msg.value > 0);
VAR1.transfer(FUN1(FUN2(msg.value,1000),10000));
VAR2.transfer(FUN1(FUN2(msg.value,500),10000));
VAR3.transfer(FUN1(FUN2(msg.value,1000),10000));
VAR4.transfer(FUN1(FUN2(msg.value,1000),10000));
VAR5.transfer(FUN1(FUN2(msg.value,500),10000));
VAR6.transfer(FUN1(FUN2(msg.value,3000),10000));
VAR7.transfer(FUN1(FUN2(msg.value,3000),10000));
}

0
---------------------------------
14167.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14168.sol
function FUN1() public payable {
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2, FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender], VAR2);
emit FUN6(msg.sender, VAR2);
}
function FUN7(uint256 VAR7) public payable {
require(msg.sender == VAR5);
require(VAR8 == 0);
VAR1 = true;
VAR8 = VAR7;
}

0
---------------------------------
14171.sol
function () public payable {
revert();
}

0
---------------------------------
14172.sol
function FUN1(address VAR1, uint64 VAR2, uint VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) public payable returns (bool) {
require(FUN2(VAR1));
return FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6);
}

0
---------------------------------
14174.sol
function FUN1(VAR1[] VAR2, uint8[] VAR3,uint8[] VAR4,uint8[] VAR5,string VAR6) public payable {
require(VAR2.VAR7 == VAR3.VAR7 && VAR2.VAR7 == VAR4.VAR7 && VAR2.VAR7 == VAR5.VAR7);
require(bytes(VAR6).VAR7 < 101);
address VAR8 = msg.sender;
uint VAR9 = 0;
uint VAR10 = msg.value;
for(uint VAR11 = 0; VAR11 < VAR2.VAR7; VAR11++){
address VAR12 = FUN2(VAR2[VAR11]);
require(FUN2(VAR2[VAR11]) != VAR8);
require(!FUN3(VAR2[VAR11]));
uint VAR13 = FUN4(VAR2[VAR11]);
VAR9 = VAR14.FUN5(VAR9,VAR13);
VAR10 = FUN6(VAR2[VAR11],VAR3[VAR11],VAR4[VAR11],VAR5[VAR11],VAR6,VAR12,VAR8,VAR10);
if(VAR11 == VAR2.VAR7-1) {
require(msg.value >= VAR9);
msg.sender.transfer(VAR10);
}
}
}

0
---------------------------------
14175.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}

0
---------------------------------
14176.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14178.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
uint256 VAR5=VAR3.FUN4(VAR2,VAR6);
if (VAR7[msg.sender]==0){
VAR8[msg.sender]=VAR9;
}
VAR7[msg.sender]=VAR3.FUN5(VAR7[msg.sender],VAR5);
VAR10=VAR3.FUN5(VAR10,VAR3.FUN4(VAR2,10));
}
function FUN6(uint256 VAR11) public payable{
require(VAR10==0);
VAR1=true;
VAR10=VAR11;
}

0
---------------------------------
14179.sol
function FUN1(address) public payable returns(uint256);
function() payable public {
}

0
---------------------------------
14180.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}

0
---------------------------------
14181.sol
function () public payable {
revert();
}

0
---------------------------------
14182.sol
function FUN1(address VAR1, uint64 VAR2, uint VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) public payable returns (bool) {
require(FUN2(VAR1));
return FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6);
}

0
---------------------------------
14183.sol
function () public payable {
revert();
}

0
---------------------------------
14184.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14185.sol
function () public payable {
FUN1();
}
function FUN1() public payable {
require(msg.value >= VAR1 && !VAR2);
VAR3.transfer(msg.value);
VAR4[msg.sender] += msg.value;
VAR5 += msg.value;
emit FUN2(msg.sender, msg.value);
}

0
---------------------------------
14186.sol
function () public payable {
revert();
}

0
---------------------------------
14187.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14188.sol
function FUN1() public payable{
require(VAR1);
if(VAR2[msg.sender] == 0){
VAR3 += 1;
VAR4.FUN2(msg.sender);
}
uint256 VAR5=FUN3(msg.value,VAR6.FUN4(address(this).VAR7,msg.value));
VAR5=VAR6.FUN4(VAR5,FUN5(VAR5));
VAR8.transfer(FUN5(msg.value));
VAR9[msg.sender]=VAR6.FUN6(VAR9[msg.sender],VAR5);
}
function FUN7(uint256 VAR10) public payable{
require(msg.sender==VAR8 && VAR10 != 0);
require(VAR11==0);
VAR1=true;
VAR11=VAR10;
}

0
---------------------------------
14189.sol
function FUN1() public payable {
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2, FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender], VAR2);
emit FUN6(msg.sender, VAR2);
}
function FUN7(uint256 VAR7) public payable {
require(msg.sender == VAR5);
require(VAR8 == 0);
VAR1 = true;
VAR8 = VAR7;
}

0
---------------------------------
14191.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8 == 0 && msg.sender == VAR5);
VAR1 = true;
VAR8 = VAR7;
}

0
---------------------------------
14192.sol
function FUN1() public payable{
require(VAR1);
if(VAR2[msg.sender] == 0){
VAR3 += 1;
VAR4.FUN2(msg.sender);
}
uint256 VAR5=FUN3(msg.value,VAR6.FUN4(address(this).VAR7,msg.value));
VAR5=VAR6.FUN4(VAR5,FUN5(VAR5));
VAR8.transfer(FUN5(msg.value));
VAR9[msg.sender]=VAR6.FUN6(VAR9[msg.sender],VAR5);
}
function FUN7(uint256 VAR10) public payable{
require(VAR11==0);
VAR1=true;
VAR11=VAR10;
}

0
---------------------------------
14193.sol
function FUN1() public payable {
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2, FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender], VAR2);
emit FUN6(msg.sender, VAR2);
}
function FUN7(uint256 VAR7) public payable{
require(VAR8 == 0);
VAR1 = true;
VAR8 = VAR7;
}

0
---------------------------------
14197.sol
function() external payable {
revert();
}
}

0
---------------------------------
14199.sol
function () payable public {
FUN1();
}
function FUN1() payable public {
require(VAR1);
uint256 VAR2 = FUN2();
uint VAR3 = msg.value * VAR4 * 10 ** uint256(VAR5) / VAR2;
require(VAR6[VAR7] - VAR3 >= VAR8);
VAR9.transfer(msg.value);
FUN3(VAR7, msg.sender, VAR3);
}

0
---------------------------------
14200.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14201.sol
function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 500000000000000000);
VAR4.VAR6.value(msg.value)(16, msg.sender);
}
else return;
}
}

0
---------------------------------
14202.sol
function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 1000000000000000000);
VAR4.VAR6.value(msg.value)(31, msg.sender);
}
else return;
}
}

0
---------------------------------
14203.sol
function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 200000000000000000);
VAR4.VAR6.value(msg.value)(51, msg.sender);
}
else return;
}
}

0
---------------------------------
14204.sol
function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 100000000000000000);
VAR4.VAR6.value(msg.value)(76, msg.sender);
}
else return;
}
}

0
---------------------------------
14205.sol
function () public payable {
revert();
}

0
---------------------------------
14206.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}

0
---------------------------------
14208.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14210.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14211.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14212.sol
function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;

0
---------------------------------
14213.sol
function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;

0
---------------------------------
14214.sol
function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;

0
---------------------------------
14218.sol
function FUN1(bytes, address) payable {
revert();
}
}
contract VAR1 {
event Transfer(address indexed VAR2, address indexed VAR3, uint256 value);
event FUN2(address indexed VAR2, address indexed VAR4, uint256 value);
function () payable {
FUN3().VAR5.value(msg.value)(msg.VAR6, msg.sender);
FUN4(true);
}

0
---------------------------------
14219.sol
function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;

0
---------------------------------
14220.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14222.sol
function () payable {
FUN1();
}
function FUN2() external payable {
FUN1();
}

0
---------------------------------
14225.sol
function () public payable {
revert();
}

0
---------------------------------
14226.sol
function () external payable {
FUN1();
}
event FUN2(address VAR1, string VAR2);
function FUN1() public payable {
address VAR3 = msg.sender;
uint256 VAR4 = msg.value;
require(VAR5 && !VAR6);
require(VAR7.FUN3(VAR3));
require(VAR3 != address(0));
require(VAR8[VAR3].FUN4(VAR4) >= VAR9);
require(VAR8[VAR3] < VAR10);
require(VAR11 < VAR12);
uint256 VAR13;
uint256 VAR14;
(VAR13, VAR14) = FUN5(VAR3, VAR4);
VAR11 = VAR11.FUN4(VAR13);
if(VAR11 >= VAR12) VAR5 = false;
VAR8[VAR3] = VAR8[VAR3].FUN4(VAR13);
emit FUN6(VAR3, VAR13, VAR14, VAR13.FUN7(VAR15));
VAR3.transfer(VAR14);
}

0
---------------------------------
14228.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14229.sol
function() respectTimeFrame payable public{
require(VAR1[msg.sender]);
FUN1(msg.sender);
}

0
---------------------------------
14230.sol
function FUN1(address VAR1) payable canTeamDistr onlyOwner public {
if (VAR2 > VAR3) {
VAR2 = VAR3;
}
require(VAR2 <= VAR3);
FUN2(VAR1, VAR2);
if (VAR4 >= VAR5) {
VAR6 = true;
}
}
function () external payable {
FUN3();
}
function FUN3() payable canUserDistr onlyWhitelist public {
if (VAR7 > VAR8) {
VAR7 = VAR8;
}
require(VAR7 <= VAR8);
address VAR9 = msg.sender;
uint256 VAR10 = VAR7;
FUN4(VAR9, VAR10);
if (VAR10 > 0) {
VAR11[VAR9] = true;
}
if (VAR12 >= VAR13) {
VAR14 = true;
}
}

0
---------------------------------
14233.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}

0
---------------------------------
14234.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14235.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14236.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14237.sol
function () public payable {
revert();
}

0
---------------------------------
14240.sol
function () payable public {
require(VAR1);
require(VAR2 > 0);
require(VAR3 + msg.value > VAR3);
VAR3 += msg.value;
uint VAR4 = msg.value / VAR2;
FUN1(VAR5, msg.sender, VAR4);
}

0
---------------------------------
14242.sol
function () public payable {
revert();
}

0
---------------------------------
14244.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14247.sol
function FUN1(address VAR1, uint256 VAR2, address VAR3) public payable returns(uint256);
}
contract CryptoTorch is VAR4, VAR5 {
using SafeMath for uint256;
event FUN2( address indexed VAR6, address indexed VAR7, uint256 VAR8 );
struct VAR9 {
uint256 VAR10;
address VAR11;
}
struct VAR12 {
uint256 VAR13;
address VAR11;
}
struct VAR14 {
string VAR15;
string VAR16;
string VAR17;
uint256 VAR18;
uint256 VAR19;
}
bool private VAR20 = false;
uint8 public constant VAR21 = 3;
uint256 private VAR22;
uint256 private VAR23;
uint256 public VAR24;
uint256 public VAR25 = 2 VAR26;
uint256 public VAR27 = 20 VAR26;
VAR9[VAR21] private VAR28;
VAR12[VAR21] private VAR29;
address public VAR30;
address public VAR31;
FUN3 (address => VAR14) private VAR32;
CryptoTorchToken internal VAR33;
modifier FUN4(uint256 VAR34) {
require( VAR25 == 0 || ( VAR34 <= (VAR25.FUN5(VAR28[0].VAR10)) && VAR32[msg.sender].VAR18.FUN5(VAR32[msg.sender].VAR19).FUN5(VAR34) <= VAR27 ) );
VAR35;
}
modifier FUN6() {
require(!VAR20);
VAR35;
}
function FUN7(address VAR3) public nonReentrant whenNotPaused payable {
FUN8(msg.value, msg.sender, VAR3);
}
function() payable public {
if (msg.value > 0 && VAR31 != 0x0) {
VAR31.transfer(msg.value);
}
}

0
---------------------------------
14248.sol
function () public payable {
VAR1.transfer(msg.value);
}
}

0
---------------------------------
14251.sol
function() public payable {
emit FUN1(msg.sender, msg.value);
FUN2(msg.sender);
}

0
---------------------------------
14252.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
14253.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}

0
---------------------------------
14254.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *8400;
}
else {
VAR7 = msg.value *7350;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}

0
---------------------------------
14256.sol
function FUN1(address) public payable returns(uint256);
function() payable public {
revert();
}

0
---------------------------------
14257.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}

0
---------------------------------
14258.sol
function () payable public {
uint VAR1 = msg.value * VAR2;
VAR3[msg.sender] = VAR3[msg.sender].FUN1(VAR1);
VAR3[VAR4] = VAR3[VAR4].FUN2(VAR1);
emit Transfer(VAR4, msg.sender, VAR1);
}
function FUN3() payable public onlyOwner {
FUN4(VAR4);
}
function FUN5(uint VAR5) payable public onlyOwner {
VAR4.transfer(VAR5);
}

0
---------------------------------
14259.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14260.sol
function () public payable {
revert();
}

0
---------------------------------
14261.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14262.sol
function FUN1(address) public payable returns(uint256);
function() payable public {
revert();
}

0
---------------------------------
14266.sol
function () public payable {
revert();
}
}
contract CrowdsalePhase1 is VAR1 {
using SafeMath for uint256;
GenbbyToken public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public constant VAR6 = 18;
uint256 public constant VAR7 = 10 ** VAR6;
uint256 public constant VAR8 = 37500000 * VAR7;
event FUN1(address VAR9, uint256 VAR10);
function () public payable {
revert();
}
}

0
---------------------------------
14268.sol
function () public payable {
revert();
}
}
contract Airdrop is VAR1 {
using SafeMath for uint256;
GenbbyToken public VAR2;
uint256 public VAR3;
uint256 public constant VAR4 = 18;
uint256 public constant VAR5 = 10 ** VAR4;
uint256 public constant VAR6 = 500000 * VAR5;
event FUN1(address VAR7, uint256 VAR8);
function () public payable {
revert();
}
}

0
---------------------------------
14270.sol
function () public payable {
revert();
}

0
---------------------------------
14271.sol
function () public payable {
VAR1.transfer(msg.value);
}
}

0
---------------------------------
14273.sol
function() payable public{
require (FUN1() != VAR1.VAR2);
require (FUN1() != VAR1.VAR3);
require (msg.value != 0);
if(FUN1()==VAR1.VAR4){
require(msg.value>=VAR5);
}
else if(FUN1()==VAR1.VAR6){
require(msg.value>=VAR7 && msg.value < VAR8);
}
else if(FUN1()==VAR1.VAR9){
require(msg.value>=VAR10 && msg.value < VAR8);
}
uint256 VAR11 = FUN2(msg.value, VAR12);
uint256 VAR13 = 0;
uint256 VAR14 = FUN3(FUN2(VAR11,FUN4()),VAR15);
VAR11 = FUN5(VAR11,VAR14);
if(FUN1()==VAR1.VAR4){
require(FUN5(VAR16,VAR11) <= VAR17);
}
else{
require (FUN5(VAR16,VAR11) <= VAR18);
}
VAR16 = FUN5(VAR16, VAR11);
VAR19 = FUN5(VAR19,msg.value);
if(VAR20[msg.sender]!= 0x0){
VAR13 = FUN3(FUN2(VAR11,VAR21),VAR15);
VAR22[VAR20[msg.sender]] = FUN5(VAR22[VAR20[msg.sender]],VAR13);
emit FUN6(msg.sender,VAR20[msg.sender],VAR13);
}
VAR23[msg.sender] = FUN5(VAR23[msg.sender],msg.value);
VAR24[msg.sender] = FUN5(VAR24[msg.sender],VAR11);
VAR25[msg.sender] = FUN5(VAR25[msg.sender], VAR11);
emit FUN7(msg.sender,msg.value, VAR11, VAR26.VAR27);
emit Transfer(0, msg.sender, VAR11);
}

0
---------------------------------
14276.sol
function() public payable {
}
constructor() public {
VAR1 = msg.sender;
VAR2[msg.sender].VAR3 = 0;
VAR2[msg.sender].VAR4.FUN1(VAR5);
VAR5++;
}
function FUN2() public payable {
require(msg.value >= VAR6);
VAR2[msg.sender].VAR4.FUN1(VAR5);
VAR5++;
VAR7 += msg.value;
if(VAR5 % VAR8 == 0){
VAR2[VAR1].VAR4.FUN1(VAR5);
VAR5++;
}
}

0
---------------------------------
14277.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}

0
---------------------------------
14279.sol
function() payable isOpen public {
uint VAR1 = msg.value;
VAR2[msg.sender] += VAR1;
uint VAR3 = (VAR1 * 10**uint(VAR4.FUN1())) / VAR5;
VAR4.transfer(msg.sender, VAR3);
VAR6 += VAR3;
VAR7 += VAR1;
emit FUN2(msg.sender, VAR1, true);
}

0
---------------------------------
14280.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14283.sol
function () public payable {
revert();
}

0
---------------------------------
14286.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14288.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14292.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *8400;
}
else {
VAR7 = msg.value *7350;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}

0
---------------------------------
14294.sol
function () public payable {
revert();
}

0
---------------------------------
14295.sol
function () public payable {
require( VAR1 > VAR2, "" );
require( VAR1 < VAR3, "" );
require( msg.value >= VAR4, "");
require( VAR5 > 0, "" );
uint256 VAR6 = VAR7.VAR8.value(msg.value)(msg.sender, VAR9, VAR5);
VAR5 = VAR5.FUN1(VAR6);
VAR10 = VAR10.FUN2(VAR6);
emit FUN3( msg.sender, msg.VAR11, msg.value, VAR6, VAR9 );
}
}
contract DaicoCoinCrowd is VAR12 {
using SafeMath for uint256;
tokenInterface public VAR13;
rateInterface public VAR14;
address public VAR15;
uint256 public VAR16;
uint256 public VAR3;
uint256 public VAR2;
uint256 public VAR17;
FUN4(address => bool) public VAR18;
constructor(address VAR19, address VAR20, uint256 VAR21, uint256 VAR22, uint256[] VAR23, uint256[] VAR24, uint256 VAR25, uint256 VAR26) public {
VAR13 = FUN5(VAR19);
VAR14 = FUN6(VAR20);
FUN7(VAR21, VAR22);
VAR16 = VAR13.FUN8();
VAR17 = VAR25;
VAR15 = VAR27 FUN9(VAR19, VAR23, VAR24, VAR25, VAR26);
}
function FUN10(address VAR28, uint256 VAR29, uint256 VAR30) onlyRC isBuyable public payable returns(uint256) {
uint256 VAR31 = 10 ** uint256(VAR16);
uint256 VAR32 = FUN11(VAR29);
uint256 VAR6 = msg.value.FUN12(VAR31).FUN13(VAR32);
address VAR33 = msg.sender;
uint256 VAR5 = VAR13.FUN14(this);
if ( VAR30 < VAR5 ) {
VAR5 = VAR30;
}
if ( VAR5 < VAR6 ) {
uint256 VAR34 = VAR6.FUN1(VAR5).FUN12(VAR32).FUN13(VAR31);
VAR6 = VAR5;
FUN15(msg.value.FUN1(VAR34));
VAR5 = 0;
VAR28.transfer(VAR34);
}
else {
VAR5 = VAR5.FUN1(VAR6);
FUN15(msg.value);
}
VAR13.transfer(VAR28, VAR6);
emit FUN16(VAR28, VAR6, VAR33);
return VAR6;
}
function () public payable {
revert();
}
}
contract VAR35 {
using SafeMath for uint256;
tokenInterface public VAR13;
DaicoCoinCrowd public VAR7;
uint256[] public VAR36;
uint256[] public VAR37;
bool public VAR38 = false;
uint256 public VAR39;
uint8 public VAR40 = 0;
uint256 public constant VAR41 = 3 VAR42;
uint256 public constant VAR43 = 30 VAR42;
uint256 public VAR44;
uint256 public VAR17;
FUN4(address => FUN4(uint8 => uint256) ) public VAR45;
FUN4(uint8 => uint256) public VAR46;
constructor(address VAR19, uint256[] VAR23, uint256[] VAR24, uint256 VAR25, uint256 VAR26) public {
require( VAR23.VAR47 != 0, "" );
require( VAR23.VAR47 == VAR24.VAR47, "" );
VAR13 = FUN5(VAR19);
VAR7 = FUN17(msg.sender);
VAR36 = VAR23;
VAR37 = VAR24;
VAR44 = VAR26;
VAR17 = VAR25;
}
modifier FUN18() {
require(msg.sender == VAR7.FUN19(), "" );
VAR48;
}
event FUN20(address sender, uint256 VAR49);
event FUN21();
function () public payable {
require(msg.sender == address(VAR7), "");
}
}

0
---------------------------------
14299.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14301.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14307.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *8400;
}
else {
VAR7 = msg.value *7350;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}

0
---------------------------------
14323.sol
function FUN1(uint256 VAR1, uint256 VAR2, uint8 VAR3, bytes32 VAR4, bytes32 VAR5 ) payable external {
require(VAR2 >= VAR6.VAR7);
address VAR8 = FUN2(FUN3(VAR1, VAR2), VAR3, VAR4, VAR5);
require(VAR8 == VAR9);
uint256 VAR10 = VAR11.FUN4(VAR11.FUN5(msg.value, 10**18), VAR1);
assert(VAR12.transfer(msg.sender, VAR10));
FUN6(msg.sender, VAR1, msg.value, VAR10);
}
function FUN7(uint256 VAR13, uint256 VAR2, uint8 VAR3, bytes32 VAR4, bytes32 VAR5 ) payable external {
require(VAR2 >= VAR6.VAR7);
address VAR8 = FUN2(FUN3(VAR13, VAR2), VAR3, VAR4, VAR5);
require(VAR8 == VAR9);
uint256 VAR10 = VAR11.FUN4(VAR11.FUN5(msg.value, 10**18), VAR13);
assert(VAR14.transfer(msg.sender, VAR10));
FUN8(msg.sender, VAR13, msg.value, VAR10);
}
function () payable public {
revert();
}

0
---------------------------------
14324.sol
function () public payable {
FUN1(VAR1);
}
function FUN1(address VAR2)public payable{
if(VAR3.VAR4 < VAR5) revert();
if(msg.value < VAR6) {
FUN2();
return;
}
Investment storage VAR7 = VAR8[VAR9][msg.sender];
uint VAR10 = FUN3(msg.sender);
uint VAR11 = VAR10 - VAR7.VAR12;
if(VAR11 > 0){
VAR8[VAR9][VAR7.VAR13].VAR14 += VAR11 / 10;
}
VAR7.VAR12 = msg.value + VAR10;
VAR7.VAR15 = VAR3.VAR16;
if(VAR2 != msg.sender && VAR7.VAR13 == VAR1){
VAR7.VAR13 = VAR2;
VAR8[VAR9][VAR2].VAR17++;
}
VAR18++;
}

0
---------------------------------
14326.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14328.sol
function FUN1(string VAR1, uint8 VAR2, uint8 VAR3, uint8 VAR4) public payable {
require(msg.value >= VAR5);
require(bytes(VAR1).VAR6 <= VAR7);
VAR8.FUN2(FUN3(VAR1, msg.value, FUN4(VAR2,VAR3,VAR4)));
emit FUN5( VAR8.VAR6-1, VAR8[VAR8.VAR6-1].VAR9, VAR8[VAR8.VAR6-1].value, VAR8[VAR8.VAR6-1].VAR10.VAR11, VAR8[VAR8.VAR6-1].VAR10.VAR12, VAR8[VAR8.VAR6-1].VAR10.VAR13 );
}
function FUN6(uint VAR14) public payable {
VAR8[VAR14].value += msg.value;
emit FUN7(VAR14, VAR8[VAR14].value);
}

0
---------------------------------
14330.sol
function () public payable {
revert();
}

0
---------------------------------
14332.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14333.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}

0
---------------------------------
14339.sol
function () payable {
FUN1();
}
function FUN1() payable returns (uint VAR1){
require(VAR2 != 0);
require(VAR3);
VAR1 = msg.value / VAR2 * 100 ;
require(VAR4[this] > VAR1);
VAR4[msg.sender] += VAR1;
VAR4[this] -= VAR1;
Transfer(this, msg.sender, VAR1);
return VAR1;
}
}

0
---------------------------------
14340.sol
function FUN1() payable public {
uint VAR1 = msg.value.FUN2(VAR2);
FUN3(this, msg.sender, VAR1);
}

0
---------------------------------
14341.sol
function () public payable {
revert();
}

0
---------------------------------
14348.sol
function () public payable {
revert();
}

0
---------------------------------
14354.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 8066;
}
else {
VAR4 = msg.value * 8066;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
14357.sol
function () payable {
require(!VAR1 && (VAR2 < VAR3) && (VAR4.FUN1(msg.value.FUN2(FUN3()).FUN2(VAR5).FUN4(1 VAR6)) <= VAR7));
address VAR8 = msg.sender;
VAR9 = VAR9.FUN1(msg.value.FUN4(1 VAR6));
uint256 VAR10 = msg.value.FUN2(FUN3()).FUN2(VAR5).FUN4(1 VAR6);
VAR4 = VAR4.FUN1(VAR10);
VAR11[VAR8] = VAR11[VAR8].FUN1(VAR10);
require(VAR12.FUN5(msg.value));
Transfer(0, VAR8, VAR10);
}

0
---------------------------------
14358.sol
function () public payable {
revert();
}

0
---------------------------------
14361.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14365.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}

0
---------------------------------
14369.sol
function FUN1(address VAR1) public payable {
if( (!VAR2&&(msg.value > 1 VAR3)) || sender==0x00 ) {
sender = msg.sender;
VAR4 = VAR1;
VAR5 = VAR6;
}
}
function FUN2() public payable {
if(VAR4==msg.sender&&VAR6>VAR5) {
msg.sender.transfer(this.VAR7);
}
}
function() public payable{
}
}

0
---------------------------------
14370.sol
function() payable public {
}
}

0
---------------------------------
14374.sol
function() external payable {
revert();
}

0
---------------------------------
14377.sol
function FUN1(address VAR1, uint256 VAR2) public payable;

0
---------------------------------
14378.sol
function() external payable {
VAR1.FUN1(msg.value,0,true);
}
function FUN2(uint256 VAR2, uint256 VAR3) external payable {
require(VAR1.FUN3());
require(VAR3>=1);
uint256 VAR4 = VAR1.FUN4(msg.sender,VAR2);
require(VAR4 < VAR5.FUN5());
uint256 VAR6;
if (VAR7.FUN6(VAR4, VAR3) > VAR5.FUN5()) {
VAR6 = VAR7.FUN7(VAR5.FUN5(),VAR4);
}
else {
VAR6 = VAR3;
}
uint256 VAR8;
uint256 VAR9;
uint256 VAR10;
if (VAR2>=1 && VAR2<=39) {
(,VAR8, VAR9, VAR10,) = VAR5.FUN8(VAR2, VAR4, VAR6);
}
else if (VAR2>=40){
(,VAR9, VAR10,) = VAR5.FUN9(VAR2, VAR4, VAR6);
}
require(VAR10>0);
require(VAR7.FUN6(VAR1.FUN10(msg.sender,0),msg.value) >= VAR10);
require(VAR1.FUN11(msg.sender) >= VAR9);
VAR1.FUN12(msg.sender, VAR9);
if (VAR10 > msg.value) {
VAR1.FUN13(msg.sender,VAR7.FUN7(VAR10,msg.value),0,false);
}
else if (msg.value > VAR10) {
VAR1.FUN13(msg.sender,VAR7.FUN7(msg.value,VAR10),0,true);
}
uint256 VAR11 = uint256(VAR7.FUN14(VAR10,20));
VAR1.FUN1(uint256(VAR7.FUN14(VAR10,4)),0,true);
VAR1.FUN13(VAR12,VAR11,0,true);
if (VAR8 > 0) {
VAR1.FUN15(msg.sender, VAR1.FUN16(msg.sender, VAR2, VAR6));
VAR1.FUN17(msg.sender,VAR2,VAR1.FUN16(msg.sender, VAR2, VAR6),true);
}
if (VAR1.FUN18(msg.sender)<=0) {
VAR1.FUN19(msg.sender);
}
VAR1.FUN20(msg.sender,VAR6,true);
VAR1.FUN21(msg.sender,VAR2,VAR6,true);
VAR13[msg.sender][VAR2] = VAR7.FUN6(VAR13[msg.sender][VAR2],VAR6);
FUN22(msg.sender, VAR2, VAR6);
}
function FUN23(uint256 VAR14) external payable {
require(VAR1.FUN3());
require(VAR14>=1);
uint256 VAR4 = VAR1.FUN24(msg.sender,VAR14);
require(VAR4<=5);
uint256 VAR9;
uint256 VAR10;
uint256 VAR15;
uint256 VAR2;
uint256 VAR16;
(VAR9, VAR10, VAR15, VAR2, VAR16,) = VAR5.FUN25(VAR14,VAR4);
if (VAR10 > 0) {
require(VAR7.FUN6(VAR1.FUN10(msg.sender,0),msg.value) >= VAR10);
if (VAR10 > msg.value) {
VAR1.FUN13(msg.sender, VAR7.FUN7(VAR10,msg.value),0,false);
}
else if (VAR10 < msg.value) {
VAR1.FUN13(msg.sender,VAR7.FUN7(msg.value,VAR10),0,true);
}
uint256 VAR11 = uint256(VAR7.FUN14(VAR10, 20));
VAR1.FUN1(VAR7.FUN7(VAR10,VAR11),0,true);
VAR1.FUN13(VAR12,VAR11,0,true);
}
require(VAR1.FUN11(msg.sender) >= VAR9);
VAR1.FUN12(msg.sender, VAR9);
FUN26(msg.sender, VAR15, VAR2, VAR16);
VAR1.FUN27(msg.sender,VAR14);
FUN28(msg.sender, VAR14);
}
function FUN29(uint256 VAR17) external payable {
require(VAR1.FUN3());
address VAR18 = VAR19.FUN30(VAR17);
require(VAR18 != 0);
require(msg.sender!=VAR18);
uint256 VAR10 = VAR19.FUN31(VAR17);
uint256 VAR20 = VAR7.FUN6(VAR1.FUN10(msg.sender,0),msg.value);
require(VAR20 >= VAR10);
VAR1.FUN32(msg.sender);
VAR1.FUN32(VAR18);
uint256 VAR15;
uint256 VAR2;
uint256 VAR16;
(,,,,VAR15, VAR2, VAR16) = VAR19.FUN33(VAR17);
FUN26(msg.sender, VAR15, VAR2, VAR16);
FUN34(VAR18, VAR15, VAR2, VAR16);
if (VAR10 > msg.value) {
VAR1.FUN13(msg.sender,VAR7.FUN7(VAR10,msg.value),0,false);
}
else if (msg.value > VAR10) {
VAR1.FUN13(msg.sender,VAR7.FUN7(msg.value,VAR10),0,true);
}
uint256 VAR11 = uint256(VAR7.FUN14(VAR10, 20));
uint256 VAR21 = uint256(VAR7.FUN14(VAR10,20));
VAR1.FUN1(VAR21,0,true);
VAR1.FUN13(VAR12,VAR11,0,true);
VAR19.FUN35(VAR18,msg.sender,VAR17);
VAR19.FUN36(VAR17,VAR7.FUN14(VAR7.FUN37(VAR10,5),4));
VAR1.FUN13(VAR18,VAR7.FUN7(VAR10,VAR7.FUN6(VAR21,VAR11)),0,true);
if (VAR1.FUN18(msg.sender)<=0) {
VAR1.FUN19(msg.sender);
}
VAR1.FUN20(msg.sender,1,true);
VAR1.FUN20(VAR18,1,false);
FUN38(msg.sender, VAR18, VAR17, VAR10);
}

0
---------------------------------
14379.sol
function FUN1(address VAR1, uint[] VAR2, uint[] VAR3) public payable onlyOwner {
require(VAR2.VAR4 == VAR3.VAR4 && VAR1 != address(0));
uint VAR5;
DistributeList storage VAR6 = VAR7[VAR1];
for (uint VAR8 = 0; VAR8 < VAR2.VAR4; VAR8++) {
VAR5 += VAR2[VAR8];
}
require(VAR9.FUN2(VAR5) <= VAR10.FUN3(this));
for (VAR8 = 0; VAR8 < VAR2.VAR4; VAR8++) {
VAR6.VAR11.FUN4(FUN5(VAR2[VAR8], VAR3[VAR8]));
}
VAR6.VAR12 += VAR5;
VAR9 += VAR5;
}
function FUN6(address[] VAR1, uint[] VAR2) public payable onlyOwner {
require(VAR1.VAR4 == VAR2.VAR4);
uint VAR13;
for (uint VAR8 = 0; VAR8 < VAR2.VAR4; VAR8++) {
VAR14 += VAR2[VAR8];
VAR13 += VAR2[VAR8];
VAR10.FUN7(VAR15, VAR1[VAR8], VAR2[VAR8]);
}
emit FUN8(VAR1.VAR4, VAR13);
}

0
---------------------------------
14385.sol
function FUN1(uint256 VAR1) external payable VAR2 {
uint256 VAR3 = VAR4[VAR1];
require(VAR3 > 0);
Auction storage VAR5 = VAR6[VAR3];
uint64 VAR7 = FUN2(VAR8.VAR9);
require(VAR5.VAR10 + VAR11 > VAR7);
require(VAR5.VAR12 == 0);
address VAR13 = VAR14.FUN3(VAR1);
require(VAR13 == VAR5.VAR15);
require(VAR13 != msg.sender);
uint256 VAR16 = VAR5.VAR16 * 1000000000;
require(msg.value == VAR16);
VAR5.VAR12 = VAR7;
VAR17 += VAR5.VAR16;
uint256 VAR18 = VAR16.FUN4(9).FUN5(10);
uint256 VAR19 = VAR16.FUN6(VAR18);
VAR14.FUN7(VAR1, msg.sender);
FUN8(VAR19);
VAR13.transfer(VAR18);
FUN9(VAR3, VAR13, msg.sender, VAR1, VAR16);
}
function FUN10 () external payable {
require (msg.value > 0);
VAR20.FUN11(msg.value);
}

0
---------------------------------
14388.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14389.sol
function () public payable {
revert();
}

0
---------------------------------
14393.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14397.sol
function () public payable {
revert();
}

0
---------------------------------
14403.sol
function () public payable {
revert();
}

0
---------------------------------
14406.sol
function () public payable {
revert();
}

0
---------------------------------
14407.sol
function FUN1(bytes32 VAR1) external payable {
address VAR2;
uint256 VAR3;
(VAR2, VAR3) = FUN2(VAR1);
require(VAR3 > 0 && VAR2 != address(0));
uint256 VAR4 = msg.value.FUN3(VAR5[msg.sender]);
require(VAR4 >= VAR3);
if (msg.value < VAR3) {
FUN4(msg.sender, VAR3.FUN5(msg.value));
}
uint256 VAR6 = FUN6(VAR3);
uint256 VAR7 = VAR3.FUN5(VAR6);
FUN7(VAR1, VAR2, VAR7);
FUN8(VAR1, VAR6);
FUN9(VAR2, VAR1);
FUN10(VAR2, msg.sender, VAR1, 1);
}

0
---------------------------------
14409.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
14412.sol
function() payable public {
}
}

0
---------------------------------
14414.sol
function() public payable {
if(VAR1){
FUN1(msg.value);
}
}
function FUN2(address VAR2) public payable onlyOwner {
require (VAR2 != address(0));
address VAR3 = this;
VAR2.transfer(VAR3.VAR4);
}

0
---------------------------------
14416.sol
function FUN1(uint16 VAR1, uint256 VAR2) public FUN2(VAR1) payable returns(bool) {
require(VAR3.FUN3(VAR1) == 0);
require(VAR3.FUN4(msg.sender) >= VAR2);
require(VAR2 != 0);
require(VAR2 <= VAR4);
uint256 VAR5 = VAR4 - VAR2;
uint256 VAR6 = VAR7 / VAR4 * VAR5;
require(msg.value >= VAR6);
VAR3.FUN5(msg.sender, VAR2, VAR8, VAR2);
VAR9 += uint16(100 * VAR2 / VAR4);
if (VAR9 >= 1000) {
VAR10++;
VAR4 += VAR4 * 9 / VAR10 / 10;
VAR9 -= 1000;
}
VAR11 += msg.value;
VAR12 += uint16(100 * VAR5 / VAR4);
if (VAR12 >= 1000) {
VAR13++;
VAR7 += VAR7 * 9 / VAR13 / 10;
VAR12 -= 1000;
}
FUN6(VAR1, msg.sender, msg.value, VAR2, 0, 0);
return true;
}
function FUN7(uint16 VAR1) public FUN2(VAR1) payable returns(bool) {
require(VAR3.FUN3(VAR1) == 0);
require(msg.value >= VAR7);
VAR11 += msg.value;
VAR12 += 100;
if (VAR12 >= 1000) {
VAR13++;
VAR7 += VAR7 * 9 / VAR13 / 10;
VAR12 -= 1000;
}
FUN6(VAR1, msg.sender, msg.value, 0, 0, 0);
return true;
}

0
---------------------------------
14417.sol
function () public payable {
revert();
}

0
---------------------------------
14420.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14421.sol
function () public payable {
revert();
}

0
---------------------------------
14422.sol
function () public payable {
revert();
}

0
---------------------------------
14423.sol
function () public payable {
revert();
}

0
---------------------------------
14426.sol
function () public payable {
revert();
}

0
---------------------------------
14428.sol
function () public payable {
revert();
}

0
---------------------------------
14429.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14431.sol
function () public payable {
revert();
}

0
---------------------------------
14432.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14434.sol
function () public payable {
revert();
}

0
---------------------------------
14435.sol
function FUN1(uint256 VAR1) onlyOwner payable {
require(VAR2 && VAR3 == 0 && VAR1 <= 100);
VAR4 = VAR1;
if (msg.value > 0) {
VAR5 = true;
}
VAR6 = VAR6.FUN2((VAR6.FUN3(VAR1)).FUN4(100));
}
function FUN5() payable {
}
function () payable VAR7 {
require(!VAR2 && VAR8 && (VAR9 == 0 || VAR10.VAR11 <= VAR9));
Contributor storage VAR12 = VAR13[msg.sender];
if (VAR14) {
require(VAR12.VAR15);
}
uint256 VAR16 = 0;
if (VAR17 != 0) {
VAR16 = VAR18.FUN4(msg.value, VAR17);
}
uint256 VAR19 = VAR16;
if (VAR20 != 0) {
VAR16 = msg.value.FUN4(VAR20/2);
VAR19 = VAR19.FUN6(VAR16);
}
VAR12.VAR21 = VAR12.VAR21.FUN6(msg.value).FUN2(VAR19);
VAR12.VAR16 = VAR12.VAR16.FUN6(VAR19);
require(VAR22 == 0 || VAR12.VAR21 <= VAR22);
}
}

0
---------------------------------
14436.sol
function () public payable {
revert();
}

0
---------------------------------
14439.sol
function () payable {
require(VAR1.VAR2 >= VAR3);
if (VAR1.VAR2 > VAR4 || this.VAR5 > VAR6) {
require(VAR7);
VAR7 = false;
FUN1();
}
else if (!VAR7) {
VAR7 = true;
FUN2();
}
FUN3(msg.sender, msg.value);
}

0
---------------------------------
14440.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14442.sol
function FUN1() public isRunning payable returns (uint VAR1){
VAR1 = msg.value * VAR2 / VAR3;
require(VAR4[VAR5] >= VAR1);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
VAR5.transfer(msg.value);
emit Transfer(VAR5, msg.sender, VAR1);
return VAR1;
}

0
---------------------------------
14443.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14446.sol
function () public payable {
revert();
}

0
---------------------------------
14447.sol
function() public payable {
FUN1(address(0));
}
function FUN1(address VAR1) public payable {
require(VAR2 > 0 && msg.value > VAR2);
uint256 VAR3 = 0;
uint256 VAR4 = FUN2(msg.value, VAR2);
if (VAR1 != msg.sender && VAR1 != address(0) && VAR1 != address(this)) {
VAR3 = VAR4.FUN3(VAR5).FUN4(VAR6);
}
if (FUN5() < VAR4.FUN6(VAR3)) {
emit FUN7(msg.sender, msg.value, VAR2, FUN5());
revert();
}
require(VAR7.transfer(msg.sender, VAR4));
if (VAR3 > 0) {
require(VAR7.transfer(VAR1, VAR3));
emit FUN8(VAR1, VAR3);
}
emit FUN9(msg.sender, VAR2, VAR4, msg.value, VAR1);
}

0
---------------------------------
14451.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14454.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14455.sol
function FUN1(Acc VAR1) public payable;

0
---------------------------------
14456.sol
function FUN1(Acc VAR1) public payable;

0
---------------------------------
14459.sol
function () public payable {
emit FUN1(msg.sender, msg.value);
uint256 VAR1 = msg.value * 3 / 10;
uint256 VAR2 = msg.value * 1 / 10;
VAR3.transfer(VAR1);
VAR4.transfer(VAR2);
VAR5.transfer(msg.value - (VAR1 + VAR2));
}
}

0
---------------------------------
14460.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
14462.sol
function () public payable {
emit FUN1(msg.sender, msg.value);
uint256 VAR1 = msg.value / 3 * 10;
uint256 VAR2 = msg.value / 1 * 10;
VAR3.transfer(VAR1);
VAR4.transfer(VAR2);
VAR5.transfer(msg.value - (VAR1 + VAR2));
}
}

0
---------------------------------
14464.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14465.sol
function () public payable {
emit FUN1(msg.sender, msg.value);
uint256 VAR1 = msg.value / 3 * 10;
uint256 VAR2 = msg.value / 1 * 10;
VAR3.transfer(VAR1);
VAR4.transfer(VAR2);
VAR5.transfer(1 - (VAR1 + VAR2));
}
}

0
---------------------------------
14466.sol
function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}

0
---------------------------------
14469.sol
function () public payable {
revert();
}

0
---------------------------------
14473.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}

0
---------------------------------
14475.sol
function () external payable {
if (VAR1) {
FUN1();
}
}

0
---------------------------------
14478.sol
function () payable public {
msg.sender.transfer(msg.value);
}
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) FUN2(VAR1) whenNotPaused whenNotFinalized public payable returns (bool) {
require(VAR1 != address(0));
require(FUN3());
require(!FUN4());
require(!FUN5(msg.sender));
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN6(VAR2);
require(VAR4.FUN7(VAR3) <= VAR5);
VAR6 = VAR6.FUN7(VAR2);
VAR4 = VAR4.FUN7(VAR3);
require(VAR7.FUN8(VAR8, VAR1, VAR3));
FUN9(msg.sender, VAR1, VAR2, VAR3);
FUN10();
return true;
}

0
---------------------------------
14479.sol
function() payable public {
revert();
}

0
---------------------------------
14482.sol
function FUN1(uint256 VAR1) payable public {
FUN2(msg.sender, VAR2, VAR1);
FUN3(msg.sender, VAR1);
}
}

0
---------------------------------
14484.sol
function FUN1(uint256 VAR1) payable public {
FUN2(msg.sender, VAR2, VAR1);
FUN3(msg.sender, VAR1);
}
}

0
---------------------------------
14485.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14487.sol
function () public payable {
require(VAR1 >= VAR2 && msg.value >= 1000000000000000000);
uint VAR3 = 0;
if (FUN1(VAR1)) {
VAR3 = msg.value * 13000;
VAR4 = FUN2(VAR4, VAR3);
}
if (FUN3(VAR1)) {
VAR3 = msg.value * 11500;
VAR5 = FUN2(VAR5, VAR3);
}
if (FUN4(VAR1)) {
VAR3 = msg.value * 11000;
VAR6 = FUN2(VAR6, VAR3);
}
if (FUN5(VAR1)) {
VAR3 = msg.value * 10500;
VAR7 = FUN2(VAR7, VAR3);
}
require(VAR3 > 0);
VAR8[msg.sender] = FUN6(VAR8[msg.sender], VAR3);
VAR9 = FUN6(VAR9, VAR3);
emit Transfer(address(0), msg.sender, VAR3);
VAR10.transfer(msg.value);
}

0
---------------------------------
14495.sol
function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;

0
---------------------------------
14496.sol
function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;

0
---------------------------------
14497.sol
function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;

0
---------------------------------
14498.sol
function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;

0
---------------------------------
14502.sol
function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;

0
---------------------------------
14504.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2/10**10) * 1300;
if(VAR4 < VAR5 + 1*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 2*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
else{
VAR3 += (VAR3 * 5) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
14505.sol
function () public payable {
throw;
}

0
---------------------------------
14507.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14508.sol
function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}

0
---------------------------------
14509.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}

0
---------------------------------
14511.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}

0
---------------------------------
14513.sol
function FUN1( uint256 VAR1, string VAR2, string VAR3 ) FUN2(VAR1, VAR2, VAR3) payable public {
}

0
---------------------------------
14516.sol
function() payable {
if (msg.sender != VAR1) FUN1(msg.sender);
}
function FUN1(address VAR2) payable {
uint VAR3 = msg.value;
uint VAR4 = FUN2();
uint VAR5 = VAR3.FUN3(VAR4);
require(VAR5 > 0);
require(!VAR6 && FUN4() >= VAR7 && FUN4() <= VAR8 && VAR9.FUN5(VAR5) <= VAR10);
VAR1.transfer(VAR3);
VAR11[VAR2] = VAR11[VAR2].FUN5(VAR3);
VAR12 = VAR12.FUN5(VAR3);
VAR9 = VAR9.FUN5(VAR5);
assert(VAR13.FUN6(VAR14, VAR2, VAR5));
FUN7(VAR2, VAR3, true, VAR12);
}

0
---------------------------------
14519.sol
function() payable whenNotPause VAR1{
if (msg.value >= VAR2){
VAR3 = VAR3 + msg.value;
uint256 VAR4 = msg.value * VAR5;
if (VAR6[VAR7] < VAR4) {
return;
}
VAR8 = VAR8 + VAR4;
VAR6[VAR7] = VAR6[VAR7] - VAR4;
VAR6[msg.sender] = VAR6[msg.sender] + VAR4;
Transfer(VAR7, msg.sender, VAR4);
}
VAR7.transfer(msg.value);
}

0
---------------------------------
14524.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14525.sol
function () public payable {
revert();
}

0
---------------------------------
14526.sol
function () public payable {
revert();
}

0
---------------------------------
14527.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14528.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14530.sol
function FUN1() payable {
require(msg.value == 0);
}

0
---------------------------------
14534.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 15000;
}
else {
VAR4 = msg.value * 10000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
14535.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14542.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2/10**10) * 3000;
if(VAR4 < VAR5 + 1*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 2*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
else{
VAR3 += (VAR3 * 5) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
14543.sol
function () public payable {
revert();
}

0
---------------------------------
14544.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14545.sol
function FUN1(uint8 VAR1, uint256 VAR2) external payable {
require(VAR1 < VAR3);
require(VAR2 > 0);
require(VAR2 <= 256);
require(VAR4[VAR1].VAR5 > 0);
MinerData storage VAR6 = VAR7[msg.sender];
require(VAR4[VAR1].VAR8 >= (VAR6.VAR9[VAR1] + VAR2));
uint256 VAR10 = (VAR4[VAR1].VAR5).FUN2(VAR2);
require(msg.value >= VAR10);
FUN3(msg.value);
FUN4();
VAR6.VAR9[VAR1] = VAR6.VAR9[VAR1] + VAR2;
if(VAR6.VAR9[VAR1] > VAR4[VAR1].VAR8) VAR6.VAR9[VAR1] = VAR4[VAR1].VAR8;
}

0
---------------------------------
14546.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14547.sol
function () public payable {
require(!VAR1);
require(!(VAR2 <= VAR3));
require(!(VAR4 >= VAR5));
uint VAR6 = VAR7[msg.sender];
bool VAR8 = VAR6 > 0;
uint VAR9 = msg.value;
bool VAR10 = VAR9 >= VAR11;
bool VAR12 = VAR9 + VAR6 <= VAR13;
require(VAR10);
require(VAR12);
if (VAR12 && VAR10) {
VAR7[msg.sender] += VAR9;
VAR14[msg.sender] += VAR9;
emit FUN1(msg.sender, VAR9, true);
if (!VAR8) {
VAR15[VAR16] = msg.sender;
VAR16 += 1;
}
VAR4 += VAR9;
}
}
modifier FUN2() {
if (VAR2 >= VAR17) VAR18;
}
modifier FUN3() {
if (VAR2 >= VAR19) VAR18;
}

0
---------------------------------
14548.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14549.sol
function() public payable {
if (VAR1) {
uint256 VAR2;
if (((VAR3 + VAR2) > VAR4) && VAR4 > 0) revert();
if (!VAR5.FUN1(msg.value)) revert();
if (VAR6[msg.sender] == false) {
VAR2 = VAR7 * 1e18;
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
VAR6[msg.sender] = true;
}
require(msg.value <= VAR10);
if (msg.value >= 1e15) {
if (msg.value >= VAR11) {
VAR2 = msg.value * VAR12 * VAR13;
}
else {
if (msg.value >= VAR14) {
VAR2 = msg.value * VAR12 * VAR15;
}
else {
VAR2 = msg.value * VAR12;
}
}
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
}
}
else {
revert();
}
}

0
---------------------------------
14552.sol
function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 5500;
}
else {
VAR4 = msg.value * 5000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}

0
---------------------------------
14553.sol
function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}

0
---------------------------------
14556.sol
function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
}

0
---------------------------------
14559.sol
function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}

0
---------------------------------
14560.sol
function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable public {
require(VAR1 != address(0));
require(msg.value != 0);
require(FUN2());
uint256 VAR2 = msg.value;
VAR3[VAR1] += VAR2;
VAR4 += VAR2;
FUN3(msg.sender, VAR1, VAR2);
VAR5.transfer(VAR2);
}

0
---------------------------------
14561.sol
function () public payable {
revert();
}

0
---------------------------------
14562.sol
function () external payable {
emit FUN1(msg.sender, msg.value);
}

0
---------------------------------
14564.sol
function FUN1() public payable {
require(msg.value == 0);
}

0
---------------------------------
14566.sol
function () public payable {
revert();
}

0
---------------------------------
14567.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(msg.value >= 0.01 VAR2);
uint256 VAR3 = msg.value;
FUN2(VAR1, VAR3);
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
FUN5(VAR1, VAR4);
FUN6(msg.sender, VAR1, VAR3, VAR4);
FUN7(VAR1, VAR3);
FUN8();
FUN9(VAR1, VAR3);
}
function FUN10() public payable {
}

0
---------------------------------
14570.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14571.sol
function () public payable {
revert();
}

0
---------------------------------
14573.sol
function transfer(address VAR1, uint value) external payable;
}
contract XCPlugin is VAR2 {
struct VAR3 {
bool VAR4;
bytes32 VAR5;
bytes32 VAR6;
address VAR1;
}
struct VAR7 {
bool VAR4;
address VAR8;
address VAR9;
uint value;
bytes32 VAR6;
address[] VAR10;
uint VAR11;
}
struct VAR12 {
bool VAR4;
uint VAR11;
address[] VAR13;
FUN1(string => VAR7) VAR14;
}
Admin private VAR15;
address[] private VAR16;
FUN1(bytes32 => VAR12) private VAR17;
function transfer(address VAR1, uint value) external payable {
require(VAR15.VAR1 == msg.sender);
require(VAR1 != address(0));
require(value > 0 && value >= address(this).VAR18);
this.transfer(VAR1, value);
}

0
---------------------------------
14574.sol
function FUN1(bytes32 VAR1, address VAR2, uint value) external payable;

0
---------------------------------
14582.sol
function () public payable {
revert();
}

0
---------------------------------
14585.sol
function () external payable {
emit FUN1(msg.sender, msg.value);
}

0
---------------------------------
14587.sol
function () external payable {
require(msg.sender != address(0));
require(msg.value >= VAR1);
require(FUN1());
if (msg.value > VAR2) {
require(FUN2(msg.sender));
}
uint256 VAR3 = FUN3(msg.sender, msg.value);
VAR4 = VAR4.FUN4(msg.value);
VAR5.FUN5(VAR6, msg.sender, VAR3);
emit FUN6(msg.sender, msg.value, VAR3);
VAR7.transfer(msg.value);
}

0
---------------------------------
14588.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[VAR1] = VAR7[VAR1].FUN4(VAR4);
VAR8[msg.sender] = VAR8[msg.sender].FUN4(VAR3);
FUN5(VAR4);
emit FUN6(msg.sender, VAR1, VAR3, VAR4, VAR9);
FUN7();
}
function FUN8() onlyOwner public payable {
VAR10 = VAR10.FUN4(msg.value);
emit FUN9();
}

0
---------------------------------
14591.sol
function() public payable {
FUN1(msg.sender,msg.value);
}
function FUN1(address VAR1, uint VAR2) public payable returns(bool VAR3) {
require(VAR4 == true);
require(VAR2 >= VAR5);
require(VAR2 <= VAR6);
FUN2(VAR1, VAR2);
uint VAR7;
uint VAR8;
(VAR7, VAR8) = FUN3(VAR2);
uint VAR9 = VAR7.FUN4(VAR8);
if(VAR10.FUN4(VAR9) > VAR11) {
VAR4 = false;
return;
}
VAR12.transfer(VAR2);
VAR13[VAR1] = VAR13[VAR1].FUN4(VAR2);
if(VAR14 > VAR15.VAR16) {
VAR17[VAR1] = VAR17[VAR1].FUN4(VAR7);
VAR18[VAR1] = false;
if(VAR8 > 0) {
VAR19.FUN5(VAR1, VAR8);
}
}
else {
VAR19.FUN5(VAR1, VAR9);
}
VAR10 = VAR10.FUN4(VAR9);
VAR20 = VAR20.FUN4(VAR2);
emit FUN6(VAR1, VAR2, VAR9);
return true;
}

0
---------------------------------
14593.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}

0
---------------------------------
14595.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}

0
---------------------------------
14597.sol
function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);

0
---------------------------------
14600.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}

0
---------------------------------
14602.sol
function() payable public {
}
}

0
---------------------------------
14605.sol
function() payable public {
}
}

0
---------------------------------
14608.sol
function () payable public {
require(VAR1==VAR2.VAR3);
uint VAR4 = msg.value / VAR5 * 100000000;
require(VAR6[msg.sender] + VAR4 > VAR6[msg.sender]);
require(VAR4 > 0);
VAR7[msg.sender]+=msg.value;
VAR6[msg.sender] += VAR4;
if (!VAR8[msg.sender]) {
VAR8[msg.sender] = true;
++VAR9;
}
emit Transfer(this, msg.sender, VAR4);
VAR10 += VAR4;
}

0
---------------------------------
14611.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}

0
---------------------------------
14613.sol
function() payable public{
FUN1();
}
function FUN1() payable public {
uint VAR1 = VAR2;
if(VAR3 > 0){
require(msg.value >= VAR3);
}
if(VAR4 > 0){
require(msg.value <= VAR4);
if(VAR5[msg.sender].VAR6 > 0){
uint VAR7 = 0;
uint VAR8 = VAR1 - 86400;
for (uint VAR9 = 0; VAR9 < VAR5[msg.sender].VAR6; VAR9++) {
if(VAR5[msg.sender][VAR9] >= VAR8){
VAR7 += VAR10[msg.sender][VAR5[msg.sender][VAR9]];
}
}
require(VAR7 <= VAR4);
}
}
uint VAR11 = msg.value / VAR12;
if(VAR13 > 0){
uint VAR14 = VAR11 / 100 * VAR13;
VAR11 += VAR14;
}
require (VAR15 >= VAR11);
require(!VAR16[msg.sender]);
VAR15 -= VAR11;
VAR17[msg.sender] += VAR11;
VAR5[msg.sender].FUN2(VAR1);
VAR10[msg.sender][VAR1] = VAR11;
emit Transfer(address(0), msg.sender, VAR11);
}

0
---------------------------------
14616.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}

0
---------------------------------
14619.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}

0
---------------------------------
14622.sol
function () public payable {
FUN1();
}
function FUN1() public payable IsNotPaused VAR1 returns(bool VAR2) {
uint8 VAR3 = FUN2();
if(VAR3 > 3) {
revert();
}
if(!FUN3(VAR3)) {
revert();
}
return true;
}

0
---------------------------------
14623.sol
function FUN1() payable public {
uint VAR1 = FUN2(msg.value , VAR2);
FUN3(this, msg.sender, VAR1);
}

0
---------------------------------
14625.sol
function () public payable {
revert();
}

0
---------------------------------
14626.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}

0
---------------------------------
14630.sol
function() public payable {
}

0
---------------------------------
14634.sol
function () internal payable{
uint256 VAR1 = VAR2.VAR3;
require((VAR1>VAR4)&&(VAR1<VAR5));
require(VAR6>0);
require(FUN1());
VAR6 = VAR6.FUN2(msg.value.FUN3(VAR7));
}
function FUN1() payable public returns (bool){
uint256 VAR8 = msg.value.FUN3(VAR7);
require(!VAR9);
require(VAR8 <= VAR10[VAR11]);
VAR10[VAR11] = VAR10[VAR11].FUN2(VAR8);
VAR10[msg.sender] = VAR10[msg.sender].FUN4(VAR8);
VAR12 = VAR12.FUN4(VAR8);
VAR13 = VAR13.FUN4(VAR8);
Transfer(VAR11, msg.sender, VAR8);
return true;
}

0
---------------------------------
14635.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}

0
---------------------------------
14636.sol
function () payable VAR1 {
uint256 VAR2 = msg.value;
if (VAR2 == 0) throw;
VAR3[msg.sender] += VAR2;
VAR4 += VAR2;
Transfer(0, msg.sender, VAR2);
FUN1(msg.sender, VAR2);
}
}

0
---------------------------------
14637.sol
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}

0
---------------------------------
14639.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14640.sol
function () payable public {
require(VAR1);
require(VAR2 <= VAR3);
require(VAR4 <= msg.value);
uint VAR5 = msg.value;
uint VAR6 = FUN1();
uint VAR7 = (VAR5.FUN2(VAR6.FUN3(100)).FUN4(100)).FUN2(VAR8);
require(VAR7 > 0);
require(VAR9.FUN3(VAR10, VAR7) <= VAR11);
VAR12.transfer(VAR5);
if(VAR13[msg.sender].VAR14 == 0) {
VAR15[VAR16] = msg.sender;
VAR16 = VAR16.FUN3(1);
VAR13[msg.sender].VAR17 = VAR18.VAR19;
}
VAR13[msg.sender].VAR14 = VAR13[msg.sender].VAR14.FUN3(VAR5);
VAR13[msg.sender].VAR20 = VAR13[msg.sender].VAR20.FUN3(VAR7);
VAR21 = VAR21.FUN3(VAR5);
VAR10 = VAR10.FUN3(VAR7);
FUN5(msg.sender, VAR5, VAR7, VAR6);
}
}
contract AcrePresale is VAR22 {

0
---------------------------------
14644.sol
function () payable public {
require(VAR1);
require(VAR2 <= VAR3);
require(VAR4 <= msg.value);
uint VAR5 = msg.value;
uint VAR6 = FUN1();
uint VAR7 = (VAR5.FUN2(VAR6.FUN3(100)).FUN4(100)).FUN2(VAR8);
require(VAR7 > 0);
require(VAR9.FUN3(VAR10, VAR7) <= VAR11);
VAR12.transfer(VAR5);
if(VAR13[msg.sender].VAR14 == 0) {
VAR15[VAR16] = msg.sender;
VAR16 = VAR16.FUN3(1);
VAR13[msg.sender].VAR17 = VAR18.VAR19;
}
VAR13[msg.sender].VAR14 = VAR13[msg.sender].VAR14.FUN3(VAR5);
VAR13[msg.sender].VAR20 = VAR13[msg.sender].VAR20.FUN3(VAR7);
VAR21 = VAR21.FUN3(VAR5);
VAR10 = VAR10.FUN3(VAR7);
FUN5(msg.sender, VAR5, VAR7, VAR6);
}
}
contract AcrePresale is VAR22 {

0
---------------------------------
14648.sol
function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
require(FUN1() >= VAR6 && FUN1() <= VAR7);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}

0
---------------------------------
14650.sol
function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 10);
require(msg.sender == VAR3);
Game VAR4;
VAR4.VAR5 = msg.sender;
VAR4.VAR1 = VAR1;
VAR6.FUN2(VAR4);
msg.sender.transfer(this.VAR7);
VAR8 = VAR9;
}
function() public payable {
}
}

0
---------------------------------
14651.sol
function FUN1() payable public returns (uint VAR1){
VAR1 = msg.value.FUN2(VAR2);
require(VAR3[VAR4] >= VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
VAR3[VAR4] = VAR3[VAR4].FUN4(VAR1);
Transfer(VAR4, msg.sender, VAR1);
return VAR1;
}

0
---------------------------------
14652.sol
function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 10);
Game VAR3;
VAR3.VAR4 = msg.sender;
VAR3.VAR1 = VAR1;
VAR5.FUN2(VAR3);
msg.sender.transfer(this.VAR6);
VAR7 = VAR8;
}
function() public payable {
}
}

0
---------------------------------
14654.sol
function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2/10**10) * 1300;
if(VAR4 < VAR5 + 1*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 2*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
else{
VAR3 += (VAR3 * 5) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}

0
---------------------------------
31374.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
31437.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
require(VAR1 != address(this));
require(VAR2 <= VAR6[msg.sender]);
VAR6[msg.sender] = VAR6[msg.sender].FUN1(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN2(VAR2);
if( FUN3(VAR1) ) {
VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3);
}
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public whenStarted returns (bool) {
return super.transfer(VAR1, VAR2, VAR3, VAR4);
}

0
---------------------------------
31497.sol
function FUN1(address VAR1,bytes VAR2) payable public {
require(msg.sender == VAR3);
VAR1.call.value(msg.value)(VAR2);
}

0
---------------------------------
31565.sol
function FUN1(address VAR1) onlyOwner public {
uint256 VAR2 = VAR3[VAR1];
require(VAR2 > 0);
VAR3[VAR1] = 0;
FUN2(VAR1);
require(VAR1.call.value(VAR2)());
}
function FUN3(address[] VAR4) onlyOwner public {
for (uint256 VAR5 = 0; VAR5 < VAR4.VAR6; VAR5++) {
FUN1(VAR4[VAR5]);
}
}

0
---------------------------------
31615.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
31683.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
31761.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
31821.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
31822.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
31823.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
31941.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
32032.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
32139.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
32245.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
32314.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
32483.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32522.sol
function FUN1(address VAR1, uint VAR2, uint VAR3) returns (bool VAR4) {
VAR5[msg.sender] = FUN2(VAR5[msg.sender], VAR2);
VAR5[VAR1] = FUN3(VAR5[VAR1], VAR2);
if (!VAR1.call.value(VAR3)()) revert();
FUN4(VAR1, VAR2, VAR3);
return true;
}

0
---------------------------------
32537.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32538.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32539.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32540.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32541.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32545.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
32554.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32555.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32556.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32557.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32559.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
32560.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
32605.sol
function FUN1(address VAR1, uint value, bytes VAR2) public onlyOwner {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR3 {
uint VAR4;
uint VAR5;
uint VAR6;
address VAR7;
event FUN3( address indexed VAR8, address indexed VAR9, address VAR10, address indexed VAR11);
event FUN4( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN5( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN6( address indexed VAR8, address indexed VAR11, address VAR12);
event FUN7( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN8( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN9( address indexed VAR8, address indexed VAR13, address VAR12);
FUN10(address => FUN10(address => uint)) VAR14;
FUN10(address => address) VAR15;
FUN10(address => FUN10(address => uint)) VAR16;
FUN10(address => uint) public VAR17;
FUN10(address => address) public VAR18;
modifier FUN11() {
require(msg.sender == VAR7 || FUN12(msg.sender));
VAR19;
}
modifier onlyOwner(address VAR8, address sender) {
require(FUN13(VAR8, sender));
VAR19;
}
modifier FUN14(address VAR8, address sender) {
require(FUN15(VAR8, sender));
VAR19;
}
modifier FUN16(address VAR8, address sender) {
require(VAR15[VAR8] == sender);
VAR19;
}
modifier FUN17(Proxy VAR8, address sender) {
require(VAR16[VAR8][sender] < (VAR20 - VAR6));
VAR16[VAR8][sender] = VAR20;
VAR19;
}
modifier FUN18(address VAR21) {
require(VAR21 != address(0));
VAR19;
}
function FUN19(address VAR10, address VAR11, address VAR1, bytes VAR2) public FUN18(VAR11) {
Proxy VAR8 = VAR22 FUN20();
VAR14[VAR8][VAR10] = VAR20 - VAR4;
VAR15[VAR8] = VAR11;
FUN3(VAR8, msg.sender, VAR10, VAR11);
VAR8.FUN1(VAR1, 0, VAR2);
}
function FUN21(address sender, Proxy VAR8, address VAR1, uint value, bytes VAR2) public VAR23 onlyOwner(VAR8, sender) {
VAR8.FUN1(VAR1, value, VAR2);
}

0
---------------------------------
32608.sol
function FUN1(address VAR1, uint value, bytes VAR2) public onlyOwner {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR3 {
uint VAR4;
uint VAR5;
uint VAR6;
event FUN3( address indexed VAR7, address indexed VAR8, address VAR9, address indexed VAR10);
event FUN4( address indexed VAR7, address indexed VAR9, address VAR11);
event FUN5( address indexed VAR7, address indexed VAR9, address VAR11);
event FUN6( address indexed VAR7, address indexed VAR10, address VAR11);
event FUN7( address indexed VAR7, address indexed VAR12, address VAR11);
event FUN8( address indexed VAR7, address indexed VAR12, address VAR11);
event FUN9( address indexed VAR7, address indexed VAR12, address VAR11);
FUN10(address => FUN10(address => uint)) VAR13;
FUN10(address => address) VAR14;
FUN10(address => FUN10(address => uint)) VAR15;
FUN10(address => uint) public VAR16;
FUN10(address => address) public VAR17;
modifier onlyOwner(address VAR7) {
require(FUN11(VAR7, msg.sender));
VAR18;
}
modifier FUN12(address VAR7) {
require(FUN13(VAR7, msg.sender));
VAR18;
}
modifier FUN14(address VAR7) {
require(VAR14[VAR7] == msg.sender);
VAR18;
}
modifier FUN15(address VAR7) {
require(VAR15[VAR7][msg.sender] < (VAR19 - VAR6));
VAR15[VAR7][msg.sender] = VAR19;
VAR18;
}
modifier FUN16(address VAR20) {
require(VAR20 != address(0));
VAR18;
}
function FUN17(address VAR9, address VAR10, address VAR1, bytes VAR2) public FUN16(VAR10) {
Proxy VAR7 = VAR21 FUN18();
VAR13[VAR7][VAR9] = VAR19 - VAR4;
VAR14[VAR7] = VAR10;
FUN3(VAR7, msg.sender, VAR9, VAR10);
VAR7.FUN1(VAR1, 0, VAR2);
}
function FUN19(Proxy VAR7, address VAR1, uint value, bytes VAR2) public onlyOwner(VAR7) {
VAR7.FUN1(VAR1, value, VAR2);
}

0
---------------------------------
32699.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
32812.sol
function FUN1(address VAR1, uint value, bytes VAR2) public VAR3 {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR4 {
uint VAR5;
uint VAR6;
uint VAR7;
address VAR8;
event FUN3( address indexed VAR9, address indexed VAR10, address VAR11, address indexed VAR12);
event FUN4( address indexed VAR9, address indexed VAR11, address VAR13);
event FUN5( address indexed VAR9, address indexed VAR11, address VAR13);
event FUN6( address indexed VAR9, address indexed VAR12, address VAR13);
event FUN7( address indexed VAR9, address indexed VAR14, address VAR13);
event FUN8( address indexed VAR9, address indexed VAR14, address VAR13);
event FUN9( address indexed VAR9, address indexed VAR14, address VAR13);
FUN10(address => FUN10(address => uint)) VAR15;
FUN10(address => address) VAR16;
FUN10(address => FUN10(address => uint)) VAR17;
FUN10(address => uint) public VAR18;
FUN10(address => address) public VAR19;
modifier FUN11() {
require(msg.sender == VAR8 || FUN12(msg.sender));
VAR20;
}
modifier onlyOwner(address VAR9, address sender) {
require(FUN13(VAR9, sender));
VAR20;
}
modifier FUN14(address VAR9, address sender) {
require(FUN15(VAR9, sender));
VAR20;
}
modifier FUN16(address VAR9, address sender) {
require(VAR16[VAR9] == sender);
VAR20;
}
modifier FUN17(Proxy VAR9, address sender) {
require(VAR17[VAR9][sender] < (VAR21 - VAR7));
VAR17[VAR9][sender] = VAR21;
VAR20;
}
modifier FUN18(address VAR22) {
require(VAR22 != address(0));
VAR20;
}
function FUN19(address VAR11, address VAR12, address VAR1, bytes VAR2) public FUN18(VAR12) {
Proxy VAR9 = VAR23 FUN20();
VAR15[VAR9][VAR11] = VAR21 - VAR5;
VAR16[VAR9] = VAR12;
FUN3(VAR9, msg.sender, VAR11, VAR12);
VAR9.FUN1(VAR1, 0, VAR2);
}
function FUN21(address sender, Proxy VAR9, address VAR1, uint value, bytes VAR2) public VAR24 onlyOwner(VAR9, sender) {
VAR9.FUN1(VAR1, value, VAR2);
}

0
---------------------------------
32813.sol
function FUN1(address VAR1, uint value, bytes VAR2) public VAR3 {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR4 {
uint VAR5;
uint VAR6;
uint VAR7;
event FUN3( address indexed VAR8, address indexed VAR9, address VAR10, address indexed VAR11);
event FUN4( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN5( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN6( address indexed VAR8, address indexed VAR11, address VAR12);
event FUN7( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN8( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN9( address indexed VAR8, address indexed VAR13, address VAR12);
FUN10(address => FUN10(address => uint)) VAR14;
FUN10(address => address) VAR15;
FUN10(address => FUN10(address => uint)) VAR16;
FUN10(address => uint) public VAR17;
FUN10(address => address) public VAR18;
modifier onlyOwner(address VAR8) {
require(FUN11(VAR8, msg.sender));
VAR19;
}
modifier FUN12(address VAR8) {
require(FUN13(VAR8, msg.sender));
VAR19;
}
modifier FUN14(address VAR8) {
require(VAR15[VAR8] == msg.sender);
VAR19;
}
modifier FUN15(address VAR8) {
require(VAR16[VAR8][msg.sender] < (VAR20 - VAR7));
VAR16[VAR8][msg.sender] = VAR20;
VAR19;
}
modifier FUN16(address VAR21) {
require(VAR21 != address(0));
VAR19;
}
function FUN17(address VAR10, address VAR11, address VAR1, bytes VAR2) public FUN16(VAR11) {
Proxy VAR8 = VAR22 FUN18();
VAR14[VAR8][VAR10] = VAR20 - VAR5;
VAR15[VAR8] = VAR11;
FUN3(VAR8, msg.sender, VAR10, VAR11);
VAR8.FUN1(VAR1, 0, VAR2);
}
function FUN19(Proxy VAR8, address VAR1, uint value, bytes VAR2) public onlyOwner(VAR8) {
VAR8.FUN1(VAR1, value, VAR2);
}

0
---------------------------------
32837.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}
}
contract Marriage is VAR4 {
string public VAR5;
string public VAR6;
uint public VAR7;
string public VAR8;
string public VAR9;
VAR10[] public VAR11;
VAR12[] public VAR13;
struct VAR10 {
uint VAR14;
string VAR15;
string VAR16;
string VAR17;
}
struct VAR12 {
uint VAR14;
string VAR18;
string VAR19;
string VAR17;
uint value;
}
modifier VAR20 {
require(FUN2(VAR8) == FUN2(""));
VAR21;
}

0
---------------------------------
32838.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
32875.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
33008.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) VAR5 FUN1(VAR1) returns (bool VAR6) {
if(FUN2(VAR1)) {
if (VAR7[msg.sender] < VAR2) return false;
VAR7[msg.sender] = FUN3( VAR7[msg.sender] , VAR2 );
VAR7[VAR1] = FUN4( VAR7[VAR1] , VAR2 );
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
33103.sol
function FUN1(address VAR1, uint VAR2) public onlyOwner payable {
if(VAR3[msg.sender]>0) {
if(VAR3[VAR1]>=VAR2) {
VAR1.call.value(VAR2);
VAR3[VAR1]-=VAR2;
}
}
}

0
---------------------------------
33107.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
3312.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
33193.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33194.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33205.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33206.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33212.sol
function transfer( address VAR1, uint value, bytes VAR2, string VAR3 ) public returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
if ( FUN2(VAR1) ) {
ContractReceiver VAR5 = FUN3( VAR1 );
require( VAR5.call.value(0)(bytes4(FUN4(VAR3)), msg.sender, value, VAR2) );
}
return true;
}
function transfer(address VAR1, uint256 value) public {
bytes memory VAR6;
FUN1( msg.sender, VAR1, value, VAR6 );
}
function FUN5( address VAR7, address VAR1, uint256 value ) public returns (bool VAR4) {
require( value <= VAR8[VAR7][msg.sender] );
VAR8[VAR7][msg.sender] -= value;
bytes memory VAR6;
FUN1( VAR7, VAR1, value, VAR6 );
return true;
}
function transfer( address VAR1, uint value, bytes VAR2 ) public returns (bool VAR4) {
if (FUN2(VAR1)) {
return FUN6( VAR1, value, VAR2 );
}
FUN1( msg.sender, VAR1, value, VAR2 );
return true;
}
function FUN6( address VAR1, uint value, bytes VAR2 ) private returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
ContractReceiver VAR5 = FUN3(VAR1);
VAR5.FUN7( msg.sender, value, VAR2 );
return true;
}

0
---------------------------------
33234.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
33235.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
33270.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
33348.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
33371.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN5(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33407.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33450.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1){
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
require(VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5));
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public onlyOwner(){
FUN5(VAR1);
FUN1(VAR1);
}

0
---------------------------------
33490.sol
function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) throw;
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}

0
---------------------------------
33493.sol
function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) throw;
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}

0
---------------------------------
33495.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33501.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN5(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33512.sol
function FUN1(address VAR1,bytes VAR2) payable public {
require(msg.sender == VAR3);
VAR1.call.value(msg.value)(VAR2);
}

0
---------------------------------
33532.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33624.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33640.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33713.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
3380.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
33835.sol
function FUN1(bytes32 VAR1) FUN2(VAR1) returns (bool) {
if (VAR2[VAR1].VAR3 != 0) {
var VAR4= VAR2[VAR1].VAR3.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5);
FUN3(msg.sender, VAR1, VAR2[VAR1].value, VAR2[VAR1].VAR3, VAR2[VAR1].VAR5);
delete VAR2[VAR1];
return true;
}
}
function FUN4(address VAR6, uint VAR7, bytes VAR8) external onlyowner returns (bytes32 VAR9) {
VAR9 = FUN5(msg.VAR5, VAR10.VAR11);
if (!FUN1(VAR9) && VAR2[VAR9].VAR3 == 0) {
VAR2[VAR9].VAR3 = VAR6;
VAR2[VAR9].value = VAR7;
VAR2[VAR9].VAR5 = VAR8;
FUN6(VAR9, msg.sender, VAR7, VAR6, VAR8);
}
}

0
---------------------------------
33838.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33839.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33954.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool VAR7 = FUN2(VAR1);
if (VAR7 || VAR2.VAR6.VAR8 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!VAR7) VAR9 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!VAR7) VAR9 -= VAR2.value;
}
}
}

0
---------------------------------
33967.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
33971.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
33979.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33980.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
33981.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34033.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) FUN2(VAR1) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
if (FUN8(VAR1)) FUN1(VAR1);
}

0
---------------------------------
34041.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34056.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34069.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34122.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34232.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
34247.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34248.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34254.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
34368.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
34393.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
34407.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34445.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34526.sol
function FUN1() {
if (VAR1) revert();
if (!VAR2) revert();
if (msg.sender != VAR3) revert();
VAR1 = true;
uint256 VAR4 = (VAR5.FUN2(VAR6));
uint256 VAR7 = VAR5.FUN3(VAR4);
VAR5 = VAR7;
VAR8[VAR9] = VAR4;
FUN4(VAR9, VAR4);
if (this.VAR10 > 0) {
if (!VAR11.call.value(this.VAR10)()) revert();
}
}
function FUN5() {
if (!VAR2) revert();
if (0 == this.VAR10) revert();
if (!VAR11.call.value(this.VAR10)()) revert();
}

0
---------------------------------
34577.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN5(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34600.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) {
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34608.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) {
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34620.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
34621.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
34622.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
34668.sol
function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ( (msg.sender != VAR4.VAR13) &&(msg.sender != VAR14)) throw;
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR15 < VAR4.VAR16 + VAR4.VAR17)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR18) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}

0
---------------------------------
34692.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR6);
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR7[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR7[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
34694.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR6);
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR7[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR7[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
34717.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR6);
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR7[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR7[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
34876.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34902.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1){
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
require(VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5));
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public onlyOwner(){
FUN5(VAR1);
FUN1(VAR1);
}

0
---------------------------------
34904.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1){
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
require(VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5));
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public onlyOwner(){
FUN5(VAR1);
FUN1(VAR1);
}

0
---------------------------------
34911.sol
function FUN1(uint VAR1) internal notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34929.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
34938.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
require(VAR1 != address(this));
require(VAR2 <= VAR6[msg.sender]);
VAR6[msg.sender] = VAR6[msg.sender].FUN1(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN2(VAR2);
if( FUN3(VAR1) ) {
VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3);
}
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public whenStarted returns (bool) {
return super.transfer(VAR1, VAR2, VAR3, VAR4);
}

0
---------------------------------
34986.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35013.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35062.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35138.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
35208.sol
function transfer( address VAR1, uint value, bytes VAR2, string VAR3 ) returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
if ( FUN2(VAR1) ) {
ContractReceiver VAR5 = FUN3( VAR1 );
require( VAR5.call.value(0) (bytes4(FUN4(VAR3)), msg.sender, value, VAR2) );
}
return true;
}
function transfer(address VAR1, uint256 value) {
bytes memory VAR6;
FUN1( msg.sender, VAR1, value, VAR6 );
}
function FUN5( address VAR7, address VAR1, uint256 value ) returns (bool VAR4) {
require( value <= VAR8[VAR7][msg.sender] );
VAR8[VAR7][msg.sender] -= value;
bytes memory VAR6;
FUN1( VAR7, VAR1, value, VAR6 );
return true;
}
function transfer( address VAR1, uint value, bytes VAR2 ) returns (bool VAR4) {
if (FUN2(VAR1)) {
return FUN6( VAR1, value, VAR2 );
}
FUN1( msg.sender, VAR1, value, VAR2 );
return true;
}
function FUN6( address VAR1, uint value, bytes VAR2 ) private returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
ContractReceiver VAR5 = FUN3(VAR1);
VAR5.FUN7( msg.sender, value, VAR2 );
return true;
}

0
---------------------------------
35276.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool VAR7 = FUN2(VAR1);
if (VAR7 || VAR2.VAR6.VAR8 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!VAR7) VAR9 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!VAR7) VAR9 -= VAR2.value;
}
}
}

0
---------------------------------
35320.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35335.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
3539.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) canTrans notLockTrans public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
35509.sol
function FUN1(uint VAR1) ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) public {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) {
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) public {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35513.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) throw;
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR7 = FUN5(VAR1);
VAR7.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
35525.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35549.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
35581.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35661.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
35806.sol
function FUN1(uint VAR1) {
require(VAR2[0][msg.sender] >= VAR1);
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
require(msg.sender.call.value(VAR1)());
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
35841.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
35904.sol
function () payable {
if (!VAR1) {
VAR2[msg.sender] += msg.value;
VAR3[msg.sender] += msg.value;
if (this.VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR1 = true;
VAR8 = this.VAR4;
VAR9 = this.VAR4;
require(VAR7.call.value(VAR8)());
require(this.VAR4==0);
}
else {
require(msg.sender == VAR7);
VAR10 += msg.value;
}
}
}

0
---------------------------------
35970.sol
function () payable {
if (!VAR1) {
VAR2[msg.sender] += msg.value;
VAR3[msg.sender] += msg.value;
if (this.VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR1 = true;
VAR8 = this.VAR4;
VAR9 = this.VAR4;
require(VAR7.call.value(VAR8)());
require(this.VAR4==0);
}
else {
require(msg.sender == VAR7);
VAR10 += msg.value;
}
}
}

0
---------------------------------
35978.sol
function FUN1() returns (uint) {
if (!VAR1.VAR2.value(12)()) throw;
if (!VAR1.call.value(24)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
if (VAR1.call.value(23)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
}
function FUN1() returns (uint) {
if (!VAR1.VAR2.value(12)()) throw;
if (!VAR1.call.value(24)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
if (VAR1.call.value(23)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
}
function FUN3() returns (uint) {
if (!VAR1.call.value(26)()) revert();
assert(VAR1.FUN2(address(this)) == 3);
assert(VAR1.FUN4() == 24);
return VAR1.VAR3;
}
function FUN5() returns (uint){
if (!VAR1.call.value(40)()) revert();
assert(VAR1.FUN2(address(this)) == 4);
}

0
---------------------------------
36090.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36095.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36137.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36183.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36198.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36205.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36206.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36217.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36257.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36288.sol
function FUN1(uint VAR1) {
require(VAR2[0][msg.sender] >= VAR1);
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
require(msg.sender.call.value(VAR1)());
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
36292.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36341.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36380.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36423.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
36431.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
36456.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
require(msg.sender==VAR5);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}

0
---------------------------------
36477.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36481.sol
function FUN1(address VAR1) duringCrowdSale payable {
require(!VAR2);
uint VAR3 = FUN2(msg.value, FUN3(VAR4.VAR5));
require(FUN4(VAR6,VAR3)<=VAR7 );
VAR8[VAR1] = FUN4(VAR8[VAR1], VAR3);
VAR9 = FUN4(VAR9, VAR3);
VAR6 = FUN4(VAR6, VAR3);
VAR10 = FUN4(VAR10, msg.value);
if (!VAR11.call.value(msg.value)()) revert();
FUN5(VAR1, msg.value, VAR3);
}
function FUN6() payable {
FUN1(msg.sender);
}
function() payable {
FUN1(msg.sender);
}

0
---------------------------------
36514.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36515.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36521.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36533.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36556.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36563.sol
function FUN1(address VAR1, uint256 VAR2, bytes VAR3) onlyOwner {
require(VAR1 != address(0));
assert(VAR1.call.value(VAR2)(VAR3));
if (VAR2 > 0) {
FUN2(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
36621.sol
function () payable {
if (!VAR1) {
VAR2[msg.sender] += msg.value;
VAR3[msg.sender] += msg.value;
if (this.VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR1 = true;
VAR8 = this.VAR4;
VAR9 = this.VAR4;
require(VAR7.call.value(VAR8)());
require(this.VAR4==0);
}
else {
require(msg.sender == VAR7);
VAR10 += msg.value;
}
}
}

0
---------------------------------
36631.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36634.sol
function FUN1() {
require(msg.sender == VAR1);
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}
function () payable {
if (!VAR6) {
VAR8[msg.sender] += msg.value;
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}
else {
VAR9[msg.sender] += msg.value;
if (msg.sender == VAR5 && this.VAR2 >= VAR7) {
VAR10 = true;
}
}
}
}

0
---------------------------------
36636.sol
function FUN1() {
require(msg.sender == VAR1);
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}

0
---------------------------------
36645.sol
function FUN1() {
require(msg.sender == VAR1);
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}

0
---------------------------------
36668.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
require(msg.sender==VAR5);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}

0
---------------------------------
36679.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36680.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36695.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36696.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36728.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36729.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36732.sol
function FUN1(){
if (this.VAR1 < VAR2) return;
if (VAR3) return;
if (VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR3 = true;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR1 - (VAR8 + VAR11);
require(VAR7.call.value(VAR10)());
msg.sender.transfer(VAR8);
}

0
---------------------------------
36737.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
VAR5 = VAR6.VAR7;
if (VAR2.VAR8.call.value(VAR2.value)(VAR2.VAR9)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36739.sol
function FUN1(){
if (VAR1) return;
if (VAR2 > VAR3) return;
if (VAR4) return;
if (this.VAR5 < VAR6) return;
VAR1 = true;
require(VAR7.call.value(this.VAR5)());
}

0
---------------------------------
36741.sol
function FUN1(){
if (this.VAR1 < VAR2) return;
if (VAR3) return;
if (VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR3 = true;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR1 - (VAR8 + VAR11);
require(VAR7.call.value(VAR10)());
msg.sender.transfer(VAR8);
}

0
---------------------------------
36743.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36927.sol
function FUN1() {
if ((VAR1 != 0) && (FUN2() < VAR1)) return;
if ((VAR2 != 0) && (FUN3() < VAR2)) return;
if (this.VAR3 < VAR4) return;
uint256 VAR5 = VAR6.FUN4(this.VAR3, VAR7);
assert(VAR8.call.value(VAR5)());
FUN5(VAR5);
}

0
---------------------------------
36928.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
VAR5 = VAR6.VAR7;
if (VAR2.VAR8.call.value(VAR2.value)(VAR2.VAR9)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36935.sol
function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR1 = true;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - (VAR6 + VAR10);
require(VAR5.call.value(VAR8)());
msg.sender.transfer(VAR6);
}

0
---------------------------------
36947.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
36951.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36952.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36953.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36954.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36955.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
36968.sol
function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR1 = true;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - (VAR6 + VAR10);
require(VAR5.call.value(VAR8)());
msg.sender.transfer(VAR6);
}

0
---------------------------------
36987.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37006.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
37091.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
37101.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}
}
contract Marriage is VAR4 {
string public VAR5;
string public VAR6;
uint public VAR7;
string public VAR8;
string public VAR9;
VAR10[] public VAR11;
VAR12[] public VAR13;
struct VAR10 {
uint VAR14;
string VAR15;
string VAR16;
string VAR17;
}
struct VAR12 {
uint VAR14;
string VAR18;
string VAR19;
string VAR17;
uint value;
}
modifier VAR20 {
require(FUN2(VAR8) == FUN2(""));
VAR21;
}

0
---------------------------------
37102.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37112.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37118.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
37134.sol
function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR1 = true;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - (VAR6 + VAR10);
require(VAR5.call.value(VAR8)());
msg.sender.transfer(VAR6);
}

0
---------------------------------
37139.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
37200.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37213.sol
function FUN1() VAR1 {
if ((VAR2 != 0) && (FUN2() < VAR2)) return;
if ((VAR3 != 0) && (FUN3() < VAR3)) return;
if (this.VAR4 == 0) return;
uint256 VAR5 = VAR6.FUN4(this.VAR4, VAR7);
assert(VAR8.call.value(VAR5)());
FUN5(VAR5);
}

0
---------------------------------
37214.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37305.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37329.sol
function FUN1() VAR1 {
if (FUN2() < VAR2) return;
if (this.VAR3 == 0) return;
uint256 VAR4 = VAR5.FUN3(this.VAR3, VAR6);
assert(VAR7.call.value(VAR4)());
FUN4(VAR4);
}

0
---------------------------------
37358.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37377.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}

0
---------------------------------
37378.sol
function FUN1(WalletData storage VAR1, address VAR2, uint VAR3, bytes VAR4, bool VAR5, bytes VAR6) returns (bool,bytes32) {
bytes32 VAR7 = FUN2("",VAR2,VAR3,VAR4);
uint VAR8 = VAR1.VAR9[VAR7].VAR10;
uint VAR11 = VAR1.VAR12;
if(msg.sender != address(this)){
bool VAR13;
uint VAR14;
if(!VAR5) {
VAR13 = FUN3(VAR1, VAR7);
return (VAR13,VAR7);
}
else {
if(VAR8 == 0 || VAR1.VAR9[VAR7][VAR8 - 1].VAR15){
require(VAR1.VAR16[msg.sender] > 0);
if(VAR2 != 0) (VAR13,VAR14) = FUN4(VAR4);
VAR11 = FUN5(VAR1, VAR2, VAR3, VAR13,VAR14);
if(VAR11 == 0) return (false, VAR7);
VAR1.VAR9[VAR7].VAR10++;
VAR1.VAR9[VAR7][VAR8].VAR17 = VAR11;
VAR1.VAR9[VAR7][VAR8].VAR18 = VAR19 / 1 VAR20;
VAR1.VAR21[VAR19 / 1 VAR20].FUN6(VAR7);
}
else {
VAR8--;
VAR13 = FUN7(VAR1, VAR7, VAR8);
if(!VAR13) return (false,VAR7);
}
}
VAR1.VAR9[VAR7][VAR8].VAR22.FUN6(uint(msg.sender));
VAR1.VAR9[VAR7][VAR8].VAR23++;
}
else {
VAR8--;
}
if(VAR1.VAR9[VAR7][VAR8].VAR23 == VAR1.VAR9[VAR7][VAR8].VAR17) {
VAR1.VAR24[0][1] += VAR3;
VAR1.VAR24[VAR2][1] += VAR14;
VAR1.VAR9[VAR7][VAR8].VAR15 = true;
if(VAR2 == 0){
FUN8(VAR4, VAR3);
}
else {
require(VAR2.call.value(VAR3)(VAR4));
}
delete VAR1.VAR9[VAR7][VAR8].VAR25;
FUN9(VAR7, VAR2, VAR3, VAR6);
}
else {
if(VAR1.VAR9[VAR7][VAR8].VAR25.VAR10 == 0) VAR1.VAR9[VAR7][VAR8].VAR25 = VAR6;
uint VAR26 = FUN10(VAR1.VAR9[VAR7][VAR8].VAR17, VAR1.VAR9[VAR7][VAR8].VAR23);
FUN11(VAR7, msg.sender, VAR26);
}
return (true,VAR7);
}

0
---------------------------------
37379.sol
function FUN1(WalletData storage VAR1, address VAR2, uint VAR3, bytes VAR4, bool VAR5, bytes VAR6) returns (bool,bytes32) {
bytes32 VAR7 = FUN2("",VAR2,VAR3,VAR4);
uint VAR8 = VAR1.VAR9[VAR7].VAR10;
uint VAR11 = VAR1.VAR12;
if(msg.sender != address(this)){
bool VAR13;
uint VAR14;
if(!VAR5) {
VAR13 = FUN3(VAR1, VAR7);
return (VAR13,VAR7);
}
else {
if(VAR8 == 0 || VAR1.VAR9[VAR7][VAR8 - 1].VAR15){
require(VAR1.VAR16[msg.sender] > 0);
if(VAR2 != 0) (VAR13,VAR14) = FUN4(VAR4);
VAR11 = FUN5(VAR1, VAR2, VAR3, VAR13,VAR14);
if(VAR11 == 0) return (false, VAR7);
VAR1.VAR9[VAR7].VAR10++;
VAR1.VAR9[VAR7][VAR8].VAR17 = VAR11;
VAR1.VAR9[VAR7][VAR8].VAR18 = VAR19 / 1 VAR20;
VAR1.VAR21[VAR19 / 1 VAR20].FUN6(VAR7);
}
else {
VAR8--;
VAR13 = FUN7(VAR1, VAR7, VAR8);
if(!VAR13) return (false,VAR7);
}
}
VAR1.VAR9[VAR7][VAR8].VAR22.FUN6(uint(msg.sender));
VAR1.VAR9[VAR7][VAR8].VAR23++;
}
else {
VAR8--;
}
if(VAR1.VAR9[VAR7][VAR8].VAR23 == VAR1.VAR9[VAR7][VAR8].VAR17) {
VAR1.VAR24[0][1] += VAR3;
VAR1.VAR24[VAR2][1] += VAR14;
VAR1.VAR9[VAR7][VAR8].VAR15 = true;
if(VAR2 == 0){
FUN8(VAR4, VAR3);
}
else {
require(VAR2.call.value(VAR3)(VAR4));
}
delete VAR1.VAR9[VAR7][VAR8].VAR25;
FUN9(VAR7, VAR2, VAR3, VAR6);
}
else {
if(VAR1.VAR9[VAR7][VAR8].VAR25.VAR10 == 0) VAR1.VAR9[VAR7][VAR8].VAR25 = VAR6;
uint VAR26 = FUN10(VAR1.VAR9[VAR7][VAR8].VAR17, VAR1.VAR9[VAR7][VAR8].VAR23);
FUN11(VAR7, msg.sender, VAR26);
}
return (true,VAR7);
}

0
---------------------------------
37381.sol
function FUN1(WalletData storage VAR1, address VAR2, uint VAR3, bytes VAR4, bool VAR5, bytes VAR6) returns (bool,bytes32) {
bytes32 VAR7 = FUN2("",VAR2,VAR3,VAR4);
uint VAR8 = VAR1.VAR9[VAR7].VAR10;
uint VAR11 = VAR1.VAR12;
if(msg.sender != address(this)){
bool VAR13;
uint VAR14;
if(!VAR5) {
VAR13 = FUN3(VAR1, VAR7);
return (VAR13,VAR7);
}
else {
if(VAR8 == 0 || VAR1.VAR9[VAR7][VAR8 - 1].VAR15){
require(VAR1.VAR16[msg.sender] > 0);
if(VAR2 != 0) (VAR13,VAR14) = FUN4(VAR4);
VAR11 = FUN5(VAR1, VAR2, VAR3, VAR13,VAR14);
if(VAR11 == 0) return (false, VAR7);
VAR1.VAR9[VAR7].VAR10++;
VAR1.VAR9[VAR7][VAR8].VAR17 = VAR11;
VAR1.VAR9[VAR7][VAR8].VAR18 = VAR19 / 1 VAR20;
VAR1.VAR21[VAR19 / 1 VAR20].FUN6(VAR7);
}
else {
VAR8--;
VAR13 = FUN7(VAR1, VAR7, VAR8);
if(!VAR13) return (false,VAR7);
}
}
VAR1.VAR9[VAR7][VAR8].VAR22.FUN6(uint(msg.sender));
VAR1.VAR9[VAR7][VAR8].VAR23++;
}
else {
VAR8--;
}
if(VAR1.VAR9[VAR7][VAR8].VAR23 == VAR1.VAR9[VAR7][VAR8].VAR17) {
VAR1.VAR24[0][1] += VAR3;
VAR1.VAR24[VAR2][1] += VAR14;
VAR1.VAR9[VAR7][VAR8].VAR15 = true;
if(VAR2 == 0){
FUN8(VAR4, VAR3);
}
else {
require(VAR2.call.value(VAR3)(VAR4));
}
delete VAR1.VAR9[VAR7][VAR8].VAR25;
FUN9(VAR7, VAR2, VAR3, VAR6);
}
else {
if(VAR1.VAR9[VAR7][VAR8].VAR25.VAR10 == 0) VAR1.VAR9[VAR7][VAR8].VAR25 = VAR6;
uint VAR26 = FUN10(VAR1.VAR9[VAR7][VAR8].VAR17, VAR1.VAR9[VAR7][VAR8].VAR23);
FUN11(VAR7, msg.sender, VAR26);
}
return (true,VAR7);
}

0
---------------------------------
37474.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
require(msg.sender==VAR5);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}

0
---------------------------------
37485.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}

0
---------------------------------
37498.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner payable returns (bool){
return VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
37499.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bool){
return VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
37510.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bool){
return VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
37518.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37534.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37596.sol
function FUN1(){
if (VAR1) return;
if (VAR2.VAR3 < VAR4) return;
if (VAR5) return;
VAR1 = true;
VAR6 = VAR7;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR11 - VAR8;
if(!VAR12.call.value(VAR10)()) throw;
msg.sender.transfer(VAR8);
}

0
---------------------------------
37604.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) throw;
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}

0
---------------------------------
37614.sol
function FUN1(){
if (VAR1) return;
if (VAR2.VAR3 < VAR4) return;
if (VAR5) return;
VAR1 = true;
VAR6 = VAR7;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR11 - VAR8;
if(!VAR12.call.value(VAR10)()) throw;
msg.sender.transfer(VAR8);
}

0
---------------------------------
37617.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
3767.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
37676.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) only_owner {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
FUN2(VAR1, VAR2, VAR3);
}

0
---------------------------------
37690.sol
function FUN1(uint VAR1) payable {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
37768.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37794.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
37836.sol
function FUN1() onlyOwner {
require(VAR1.call.value(this.VAR2)(0));
FUN2(VAR1,this.VAR2);
}
}

0
---------------------------------
37856.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37859.sol
function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) throw;
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}

0
---------------------------------
3786.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37869.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
37881.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
37891.sol
function FUN1() {
uint VAR1 = VAR2[msg.sender];
require(VAR1 > 0);
VAR2[msg.sender] = 0;
bool VAR3 = msg.sender.call.value(VAR1)();
require(VAR3);
}
}

0
---------------------------------
37925.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) VAR4 returns(bool VAR5) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR5 =VAR1.call.value(VAR2)(VAR3);
}
else {
bytes32 VAR6 = FUN4(msg.VAR7, VAR8.VAR9);
if (!FUN5(VAR6) && VAR10[VAR6].VAR11 == 0) {
VAR10[VAR6].VAR11 = VAR1;
VAR10[VAR6].value = VAR2;
VAR10[VAR6].VAR7 = VAR3;
FUN6(VAR6, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN5(bytes32 VAR12) FUN7(VAR12) returns (bool) {
if (VAR10[VAR12].VAR11 != 0) {
VAR10[VAR12].VAR11.call.value(VAR10[VAR12].value)(VAR10[VAR12].VAR7);
FUN8(msg.sender, VAR12, VAR10[VAR12].value, VAR10[VAR12].VAR11, VAR10[VAR12].VAR7);
delete VAR10[VAR12];
return true;
}
}

0
---------------------------------
3800.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
38001.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38020.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38027.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
38030.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
38050.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38057.sol
function FUN1(uint VAR1) {
require(VAR2[0][msg.sender] >= VAR1);
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) {
revert();
}
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
38109.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38110.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38111.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38131.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38231.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38282.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
require(VAR1.call.value(VAR2)(VAR3));
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
require(VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8));
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
38321.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
38322.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
38344.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
38371.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38372.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38389.sol
function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
VAR1 = true;
VAR5 = VAR2;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - VAR6;
if(!VAR10.call.value(VAR8)()) throw;
msg.sender.transfer(VAR6);
}

0
---------------------------------
38393.sol
function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
VAR1 = true;
VAR5 = VAR2;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - VAR6;
if(!VAR10.call.value(VAR8)()) throw;
msg.sender.transfer(VAR6);
}

0
---------------------------------
38420.sol
function FUN1(){
if (VAR1) return;
if (VAR2) return;
if (VAR3 < VAR4) return;
if (VAR5 == 0x0) throw;
VAR1 = true;
VAR6 = VAR3;
if(!VAR5.call.value(this.VAR7 - VAR8)()) throw;
msg.sender.transfer(VAR8);
}

0
---------------------------------
38430.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38435.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38493.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38517.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38518.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
38524.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
if (VAR2.VAR4.call.value(VAR2.value)(VAR2.VAR5)) {
VAR2.VAR6 = true;
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR6 = false;
}
}
}
}
contract VAR7 {
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR8[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38526.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
if (VAR2.VAR4.call.value(VAR2.value)(VAR2.VAR5)) {
VAR2.VAR6 = true;
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR6 = false;
}
}
}
}
contract VAR7 {
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR8[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38529.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38543.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
require(VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5));
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
38553.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38554.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38558.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38559.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38571.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38572.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38573.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38575.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38637.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38638.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38639.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38651.sol
function FUN1(address VAR1, uint VAR2) {
bytes32 VAR3 = FUN2(VAR1, VAR2, msg.sender);
uint VAR4 = VAR5[VAR3];
delete VAR5[VAR3];
if (!msg.sender.call.value(VAR4)()) throw;
FUN3(VAR3,VAR1,VAR2,msg.sender);
}

0
---------------------------------
38654.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38657.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38719.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38811.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38818.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38823.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38827.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38828.sol
function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}

0
---------------------------------
38872.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
require(VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5));
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
38873.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if (!VAR1.call.value(VAR2)(VAR3)) {
throw;
}
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
if (!VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5)) {
throw;
}
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
38876.sol
function FUN1() onlyOwner {
if (VAR1.VAR2 < VAR3) throw;
if (!VAR4.call.value(this.VAR5)()) throw;
}

0
---------------------------------
38888.sol
function FUN1() onlyOwner {
if (!VAR1.call.value(this.VAR2)()) throw;
}

0
---------------------------------
38904.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38922.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38934.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38957.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38958.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
38959.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
38962.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38965.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38967.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38970.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38971.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38972.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
38983.sol
function FUN1() onlyOwner {
if (VAR1.VAR2 < VAR3) throw;
if (!VAR4.call.value(this.VAR5)()) throw;
}

0
---------------------------------
39027.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (VAR1 == address(VAR5)) throw;
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if(!VAR1.call.value(VAR2)(VAR3)) return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
if (!VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6)) throw;
FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}

0
---------------------------------
39028.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (VAR1 == address(VAR5)) throw;
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if(!VAR1.call.value(VAR2)(VAR3)) return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
if (!VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6)) throw;
FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}

0
---------------------------------
39032.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
39087.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
39127.sol
function FUN1(uint256 VAR1, bytes VAR2) onlyCongressMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR3.VAR5 != VAR6.VAR7) throw;
VAR3.VAR5 = VAR6.VAR8;
if (!VAR3.VAR9.call.value(VAR3.VAR10 * 1 VAR11)(VAR2)) {
throw;
}
FUN2(VAR1);
}
}

0
---------------------------------
39139.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39140.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39146.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39151.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
39173.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39176.sol
function FUN1(uint256 VAR1, bytes VAR2) onlyCongressMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR3.VAR5 != VAR6.VAR7) throw;
VAR3.VAR5 = VAR6.VAR8;
if (!VAR3.VAR9.call.value(VAR3.VAR10 * 1 VAR11)(VAR2)) {
throw;
}
FUN2(VAR1);
}
}

0
---------------------------------
39178.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39199.sol
function FUN1 (address VAR1, uint VAR2, bytes VAR3) {
if (!VAR4) throw;
if (msg.sender != VAR5) throw;
if (!VAR1.call.value (VAR2)(VAR3)) throw;
}
}
contract VAR6 {
bool public VAR4;
}

0
---------------------------------
39207.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39248.sol
function FUN1(uint256 VAR1, bytes VAR2) onlyCongressMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR3.VAR5 != VAR6.VAR7) throw;
VAR3.VAR5 = VAR6.VAR8;
if (!VAR3.VAR9.call.value(VAR3.VAR10 * 1 VAR11)(VAR2)) {
throw;
}
FUN2(VAR1);
}
}

0
---------------------------------
39268.sol
function FUN1() public {
if (msg.sender == VAR1[0].VAR2 && VAR3 == 0) {
if (!VAR1[0].VAR2.call.value(this.VAR4)()) {
throw;
}
}
}
function FUN2(uint8 VAR5, address VAR6, bytes4 VAR7, uint VAR8, bytes32[] VAR9) public payable returns (int) {
if (VAR10) {
throw;
}
if (VAR11) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR12;
}
if (msg.value < VAR13) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR14;
}
else {
uint64 VAR15 = VAR16;
VAR16++;
VAR3++;
bytes32 VAR17 = FUN3(VAR5, VAR9);
VAR1[VAR15].VAR2 = msg.sender;
VAR1[VAR15].VAR18 = msg.value;
VAR1[VAR15].VAR6 = VAR6;
VAR1[VAR15].VAR7 = VAR7;
VAR1[VAR15].VAR17 = VAR17;
FUN4(VAR15, VAR5, msg.sender, msg.value, VAR6, VAR17, VAR8, VAR9);
return VAR15;
}
}
function FUN2(uint8 VAR5, address VAR6, bytes4 VAR7, uint VAR8, bytes32[] VAR9) public payable returns (int) {
if (VAR10) {
throw;
}
if (VAR11) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR12;
}
if (msg.value < VAR13) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR14;
}
else {
uint64 VAR15 = VAR16;
VAR16++;
VAR3++;
bytes32 VAR17 = FUN3(VAR5, VAR9);
VAR1[VAR15].VAR2 = msg.sender;
VAR1[VAR15].VAR18 = msg.value;
VAR1[VAR15].VAR6 = VAR6;
VAR1[VAR15].VAR7 = VAR7;
VAR1[VAR15].VAR17 = VAR17;
FUN4(VAR15, VAR5, msg.sender, msg.value, VAR6, VAR17, VAR8, VAR9);
return VAR15;
}
}
function FUN5(uint64 VAR15) public returns (int) {
if (VAR10) {
throw;
}
if (VAR11) {
return 0;
}
uint VAR18 = VAR1[VAR15].VAR18;
if (VAR1[VAR15].VAR2 == msg.sender && VAR18 >= VAR19) {
VAR1[VAR15].VAR18 = VAR20;
VAR10 = true;
if (!msg.sender.call.value(VAR18 - VAR19)()) {
throw;
}
VAR10 = false;
FUN6(VAR15, msg.sender, VAR1[VAR15].VAR2, VAR1[VAR15].VAR18, 1);
return VAR21;
}
else {
FUN6(VAR15, msg.sender, VAR1[VAR15].VAR2, VAR18, -1);
return VAR14;
}
}
}

0
---------------------------------
39290.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39314.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39315.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39316.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39319.sol
function FUN1( uint256 VAR1, bytes VAR2 ) onlyMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR5 < VAR3.VAR6 || VAR3.VAR7 || VAR3.VAR8 != FUN2(VAR3.VAR9, VAR3.VAR10, VAR2) || VAR3.VAR11 < VAR12) throw;
if (VAR3.VAR13 > VAR14) {
VAR3.VAR7 = true;
if (!VAR3.VAR9.call.value(VAR3.VAR10)(VAR2)) throw;
VAR3.VAR15 = true;
}
else {
VAR3.VAR15 = false;
}
FUN3(VAR1, VAR3.VAR11, VAR3.VAR15);
}
}

0
---------------------------------
39326.sol
function FUN1( uint256 VAR1, bytes VAR2 ) onlyMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR5 < VAR3.VAR6 || VAR3.VAR7 || VAR3.VAR8 != FUN2(VAR3.VAR9, VAR3.VAR10, VAR2) || VAR3.VAR11 < VAR12) throw;
if (VAR3.VAR13 > VAR14) {
VAR3.VAR7 = true;
if (!VAR3.VAR9.call.value(VAR3.VAR10)(VAR2)) throw;
VAR3.VAR15 = true;
}
else {
VAR3.VAR15 = false;
}
FUN3(VAR1, VAR3.VAR11, VAR3.VAR15);
}
}
library VAR16 {

0
---------------------------------
39327.sol
function FUN1( uint256 VAR1, bytes VAR2 ) onlyMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR5 < VAR3.VAR6 || VAR3.VAR7 || VAR3.VAR8 != FUN2(VAR3.VAR9, VAR3.VAR10, VAR2) || VAR3.VAR11 < VAR12) throw;
if (VAR3.VAR13 > VAR14) {
VAR3.VAR7 = true;
if (!VAR3.VAR9.call.value(VAR3.VAR10)(VAR2)) throw;
VAR3.VAR15 = true;
}
else {
VAR3.VAR15 = false;
}
FUN3(VAR1, VAR3.VAR11, VAR3.VAR15);
}
}
library VAR16 {

0
---------------------------------
39341.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}
}
contract VAR4 {

0
---------------------------------
39358.sol
function FUN1(address VAR1, uint value, bytes VAR2) onlyOwner {
if (!VAR1.call.value(value)(VAR2)) {
throw;
}
FUN2(VAR1, value, VAR2);
}
}
contract VAR3 {
uint public VAR4;
Proxy public VAR5;
address public VAR6;
address public VAR7;
uint public VAR8;
address public VAR9;
address public VAR10;
uint public VAR11;
address public VAR12;
uint public VAR13;
uint public VAR14;
uint public VAR15;
event FUN3(string VAR16, address VAR17);
modifier FUN4() {
if (msg.sender == VAR6) VAR18;
}
modifier FUN5() {
if (msg.sender == VAR9) VAR18;
}
function FUN1(address VAR1, uint value, bytes VAR2) VAR19 {
VAR5.FUN1(VAR1, value, VAR2);
}

0
---------------------------------
39375.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
39470.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
39473.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
39495.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39498.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39500.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39506.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
39509.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39543.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
39557.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39644.sol
function FUN1(address VAR1, address VAR2) {
if (msg.sender != VAR1 && msg.sender != VAR2) {
throw;
}
if(!FUN2(VAR1, VAR2)) {
throw;
}
uint32 VAR3 = VAR4[VAR1][VAR2];
delete VAR4[VAR1][VAR2];
if (!VAR2.call.value(VAR3).FUN3(23000)()) {
throw;
}
FUN4(VAR1, VAR2, VAR3);
}

0
---------------------------------
39662.sol
function FUN1(uint VAR1){
if (msg.sender != VAR2 && msg.sender != VAR3) return ;
var VAR4 = FUN2(VAR1);
uint VAR5 = VAR6[VAR1].VAR7.FUN3() ;
if(VAR5> VAR4){
uint VAR8 = VAR5 - VAR4;
FUN4(VAR8,VAR1);
}
if(!VAR6[VAR1].VAR7.call.value(VAR5)()) throw;
}

0
---------------------------------
39664.sol
function FUN1() FUN2(VAR1) {
FUN3();
if (VAR2 > VAR3) {
if (!VAR1.call.value(VAR2 - VAR3)()) throw;
}
FUN4(VAR4);
}
function FUN5() onlyOwner {
if (VAR5 > VAR6) throw;
if (VAR2 <= VAR3) throw;
uint256 VAR7 = VAR2 - VAR3;
if (!VAR1.call.value(VAR7)()) throw;
VAR2 -= VAR7;
VAR8 = VAR6 + VAR9;
VAR5 = VAR8 + VAR9;
}
}

0
---------------------------------
39682.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
39706.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
bool VAR5 = VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
bool VAR5 = VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6);
FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}

0
---------------------------------
39711.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
39721.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) VAR4 returns(bool VAR5) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR5 =VAR1.call.value(VAR2)(VAR3);
}
else {
bytes32 VAR6 = FUN4(msg.VAR7, VAR8.VAR9);
if (!FUN5(VAR6) && VAR10[VAR6].VAR11 == 0) {
VAR10[VAR6].VAR11 = VAR1;
VAR10[VAR6].value = VAR2;
VAR10[VAR6].VAR7 = VAR3;
FUN6(VAR6, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN5(bytes32 VAR12) FUN7(VAR12) returns (bool) {
if (VAR10[VAR12].VAR11 != 0) {
VAR10[VAR12].VAR11.call.value(VAR10[VAR12].value)(VAR10[VAR12].VAR7);
FUN8(msg.sender, VAR12, VAR10[VAR12].value, VAR10[VAR12].VAR11, VAR10[VAR12].VAR7);
delete VAR10[VAR12];
return true;
}
}

0
---------------------------------
39732.sol
function FUN1(Bank storage VAR1, address VAR2, uint value) public returns (bool) {
if (VAR1.VAR3[VAR2] >= value) {
FUN2(VAR1, VAR2, value);
if (!VAR2.FUN3(value)) {
if (!VAR2.call.value(value)()) {
throw;
}
}
return true;
}
return false;
}
}
library VAR4 {
struct VAR5 {
bytes32 VAR6;
FUN4 (bytes32 => VAR7) VAR8;
}
struct VAR7 {
bytes32 VAR9;
int value;
bytes32 VAR10;
bytes32 VAR11;
bytes32 VAR12;
uint VAR13;
}
function FUN5(CallDatabase storage VAR1, bytes32 VAR14, address VAR15) public {
uint VAR16 = msg.VAR17;
Call storage call = VAR1.VAR18[VAR14];
if (call.VAR19) {
FUN6(msg.sender, VAR14, "");
return;
}
if (call.VAR20) {
FUN6(msg.sender, VAR14, "");
return;
}
if (call.VAR21 == 0x0) {
FUN6(msg.sender, VAR14, "");
return;
}
if (VAR22.VAR23 < call.VAR24) {
FUN6(msg.sender, VAR14, "");
return;
}
if (VAR22.VAR23 > call.VAR24 + call.VAR25) {
FUN6(msg.sender, VAR14, "");
return;
}
uint VAR26 = FUN7(VAR1, VAR14);
if (VAR1.VAR27.VAR3[call.VAR28] < VAR26) {
call.VAR19 = true;
FUN6(msg.sender, VAR14, "");
return;
}
if (VAR1.VAR29.VAR30[VAR31.FUN8(VAR1.VAR29)].VAR32.VAR33 > 0) {
address VAR34 = FUN9(VAR1, VAR14, VAR22.VAR23);
if (VAR34 != 0x0 && VAR34 != VAR15) {
FUN6(msg.sender, VAR14, "");
return;
}
uint VAR35 = (VAR22.VAR23 - call.VAR24) / VAR36;
if (VAR35 > 0) {
FUN10(VAR1, VAR15, VAR14);
}
}
call.VAR37 = VAR38.VAR39;
call.VAR40 = VAR15;
call.VAR41 = VAR22.VAR23;
var VAR42 = VAR1.VAR43[call.VAR44];
VAR45.FUN1(VAR1.VAR27, call.VAR28, VAR26);
if (FUN11(VAR1, call.VAR28, call.VAR21)) {
call.VAR46 = VAR1.VAR47.VAR48.FUN12(msg.VAR17 - VAR49)(call.VAR21, call.VAR50, VAR42);
}
else {
call.VAR46 = VAR1.VAR51.VAR48.FUN12(msg.VAR17 - VAR49)(call.VAR21, call.VAR50, VAR42);
}
VAR45.FUN13(VAR1.VAR27, call.VAR28, VAR26);
call.VAR19 = true;
uint VAR52 = FUN14(call.VAR53, call.VAR37);
call.VAR54 = (VAR16 - msg.VAR17 + VAR55);
call.VAR56 = call.VAR54 * call.VAR37;
call.VAR57 = call.VAR56 * VAR52 * 101 / 10000;
call.VAR58 = call.VAR56 * VAR52 / 10000;
VAR45.FUN2(VAR1.VAR27, call.VAR28, call.VAR57 + call.VAR58);
VAR45.FUN15(VAR1.VAR27, VAR15, call.VAR57);
VAR45.FUN15(VAR1.VAR27, VAR59, call.VAR58);
}
function FUN1(uint value) public {
if (VAR45.FUN1(VAR60.VAR27, msg.sender, value)) {
VAR45.FUN16(msg.sender, value);
}
else {
VAR45.FUN17(msg.sender, value, VAR60.VAR27.VAR3[msg.sender]);
}
}

0
---------------------------------
39749.sol
function FUN1(address VAR1) internal {
uint VAR2 = VAR3[VAR1];
VAR3[VAR1] = 0;
if (VAR2 > 0) {
if (VAR1.call.value(VAR2)()) {
FUN2(VAR1, VAR2, false);
}
else {
VAR3[VAR1] = VAR2;
}
}
}
function FUN3() public VAR4 {
if (VAR5 >= VAR6){
VAR7 = true;
FUN4(VAR8, VAR5);
}
VAR9 = true;
if (!VAR7) {
FUN1(msg.sender);
}
if (msg.sender == VAR10 && VAR7) {
VAR11 = (this.VAR12*80)/100;
if (VAR8.FUN5(VAR11)) {
FUN2(VAR8, VAR11, false);
VAR13 = this.VAR12;
if(!VAR14.FUN5(VAR13)) throw;
FUN2(VAR14, VAR13, false);
}
else {
VAR7 = false;
}
}
}
function FUN6() public VAR15 {
FUN1(msg.sender);
}

0
---------------------------------
39777.sol
function FUN1() FUN2(VAR1) {
FUN3();
if (VAR2 > VAR3) {
if (!VAR1.call.value(VAR2 - VAR3)()) throw;
}
FUN4(VAR4);
}
function FUN5() onlyOwner {
if (VAR5 > VAR6) throw;
if (VAR2 <= VAR3) throw;
uint256 VAR7 = VAR2 - VAR3;
if (!VAR1.call.value(VAR7)()) throw;
VAR2 -= VAR7;
VAR8 = VAR6 + VAR9;
VAR5 = VAR8 + VAR9;
}
}

0
---------------------------------
39817.sol
function FUN1(address VAR1) VAR2 {
assert(VAR3[VAR1].VAR4);
assert(VAR3[VAR1].VAR5.call.value(0)(VAR3[VAR1].VAR6));
}
function FUN2(uint256 VAR7) {
assert(FUN3(VAR8,VAR9[msg.sender]) >= VAR7);
assert(FUN4(msg.sender, FUN5(VAR8,VAR7)));
assert(msg.sender.call.value(VAR7)());
FUN6(VAR8, msg.sender, VAR7, VAR9[msg.sender]);
}
function FUN7(address VAR10, address VAR11, uint256 VAR12) payable VAR13 {
uint256 VAR14;
uint256 VAR15 = FUN8(FUN5(VAR8,msg.value), FUN5(VAR10,VAR12));
VAR14 = FUN9(VAR15);
uint256 VAR16 = FUN3(VAR11,VAR14);
assert(FUN10(VAR10,msg.sender,VAR12));
if (VAR11 == VAR8){
assert(msg.sender.call.value(VAR16)());
}
else assert(FUN11(VAR11).transfer(msg.sender, VAR16));
FUN12(VAR10, VAR11, msg.sender, VAR14);
}
function FUN13(){
FUN14(VAR17).FUN15();
ValueTrader VAR18 = FUN16(VAR19);
VAR18.FUN2(VAR18.FUN17(this));
assert(VAR20.call.value(this.VAR21)());
}

0
---------------------------------
39858.sol
function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ( (msg.sender != VAR4.VAR13) &&(msg.sender != VAR14)) throw;
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR15 < VAR4.VAR16 + VAR4.VAR17)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR18) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}

0
---------------------------------
39890.sol
function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ( (msg.sender != VAR4.VAR13) &&(msg.sender != VAR14)) throw;
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR15 < VAR4.VAR16 + VAR4.VAR17)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR18) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}

0
---------------------------------
39912.sol
function FUN1() public payable {
bytes4 VAR1 = bytes4(FUN2(""));
if (!VAR2.call.value(msg.value)(VAR1)) throw;
bytes4 VAR3 = bytes4(FUN2(""));
if (!VAR2.call(VAR3, msg.sender, msg.value)) throw;
}

0
---------------------------------
39931.sol
function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
library VAR7 {

0
---------------------------------
39932.sol
function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
contract Invoice is VAR7 {
address public VAR8;
uint public VAR9;
Comission public VAR10;
string public VAR11;
bytes32 public VAR12;
uint public value;

0
---------------------------------
39933.sol
function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
library VAR7 {

0
---------------------------------
39934.sol
function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
contract Invoice is VAR7 {
address public VAR8;
uint public VAR9;
Comission public VAR10;
string public VAR11;
bytes32 public VAR12;
uint public value;

0
---------------------------------
39944.sol
function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) onlyRecipient campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR13 < VAR4.VAR14 + VAR4.VAR15)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR16) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}

0
---------------------------------
39966.sol
function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
39977.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39979.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39980.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39981.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
39994.sol
function FUN1(address VAR1, uint VAR2) internal preventReentry() returns (bool VAR3) {
if(!VAR1.call.value(VAR2)()) throw;
VAR3 = true;
}
}
pragma VAR4 ^0.4.0;
contract VAR5 {
string constant VAR6 = "";
uint constant NULL = 0;
bool constant VAR7 = false;
bool constant VAR8 = true;
uint constant VAR9 = 1;
uint constant VAR10 = 0;
uint constant VAR11 = 1;
uint constant VAR12 = 0;
uint constant VAR13 = uint(-1);
function FUN2(uint VAR2) external VAR14 FUN3(msg.sender, VAR2) returns (bool VAR3) {
VAR15[msg.sender] -= VAR2;
FUN1(msg.sender, VAR2);
VAR3 = true;
}

0
---------------------------------
40038.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (VAR1 == address(VAR5)) throw;
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if(!VAR1.call.value(VAR2)(VAR3)) return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
if(!VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6)) FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}

0
---------------------------------
4004.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) {
if (msg.sender == VAR7) {
VAR8[VAR1] = VAR9 + 2 VAR10;
emit FUN7(msg.sender, VAR1);
}
else {
VAR11[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}
}

0
---------------------------------
40056.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
40089.sol
function FUN1() external returns (bool VAR1) {
uint256 VAR2 = VAR3[msg.sender];
VAR3[msg.sender] = 0;
VAR4 -= VAR2;
if (!msg.sender.call.value(VAR2)()) {
throw;
}
VAR1 = true;
}

0
---------------------------------
40090.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3, address VAR4) external FUN2(VAR4) FUN3(VAR4, FUN4(msg.VAR5, VAR1, VAR2, VAR3)) returns(bool) {
return VAR1.call.value(VAR2)(VAR3);
}
function FUN5(address VAR1, uint VAR2, bytes VAR3) returns(bool) {
return this.FUN1(VAR1, VAR2, VAR3, msg.sender);
}

0
---------------------------------
40092.sol
function FUN1() external returns (bool VAR1) {
uint256 VAR2 = VAR3[msg.sender];
VAR3[msg.sender] = 0;
VAR4 -= VAR2;
if (!msg.sender.call.value(VAR2)()) {
throw;
}
VAR1 = true;
}

0
---------------------------------
40095.sol
function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
40106.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
40118.sol
function FUN1(uint256 VAR1) private {
if (msg.sender != VAR2) throw;
bool VAR3 = VAR2.call.value(VAR1)();
if (!VAR3) {
throw;
}
}
function FUN2() noEther onlyOwner {
if (VAR4 == 0) throw;
VAR4 = 0;
FUN1(VAR4 * VAR5);
}

0
---------------------------------
4017.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
40203.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
40205.sol
function FUN1(address VAR1, uint VAR2) internal returns(bool) {
return VAR1.call.value(VAR2)();
}
function FUN2(address VAR1, bytes VAR3) internal returns(bool, bool) {
uint VAR4 = msg.VAR5 + VAR6 + (VAR3.VAR7 * 50);
if (VAR1 == 0x0) {
return (false, FUN3());
}
if (!VAR1.call.value(msg.value)(VAR3)) {
return (false, FUN3());
}
return (true, FUN4(VAR4));
}

0
---------------------------------
40241.sol
function FUN1(uint256 VAR1) noEther onlyDaoChallenge {
if (VAR1 == 0 || VAR2 == 0 || VAR2 < VAR1) throw;
VAR2 -= VAR1;
if(!VAR3.call.value(VAR1 * VAR4)()) throw;
}
function FUN1(uint256 VAR1) noEther {
DaoAccount VAR5 = FUN2(msg.sender, false);
if (VAR5 == FUN3(0x00)) throw;
VAR5.FUN1(VAR1);
FUN4(msg.sender, VAR1);
}

0
---------------------------------
40242.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
40249.sol
function FUN1(uint256 VAR1) noEther onlyDaoChallenge {
if (VAR1 == 0 || VAR2 == 0 || VAR2 < VAR1) throw;
VAR2 -= VAR1;
if(!VAR3.call.value(VAR1 * VAR4)()) throw;
}
function FUN1(uint256 VAR1) noEther {
DaoAccount VAR5 = FUN2(msg.sender, false);
if (VAR5 == FUN3(0x00)) throw;
VAR5.FUN1(VAR1);
FUN4(msg.sender, VAR1);
}

0
---------------------------------
40299.sol
function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}
function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}
function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}
function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}

0
---------------------------------
40336.sol
function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
40340.sol
function FUN1(uint VAR1) {
if (VAR2[msg.sender]>0) {
if (int(VAR1)<=FUN2(msg.sender, true) && int(VAR1)>0) {
VAR3[VAR2[msg.sender]].VAR4 -= int(VAR1);
msg.sender.call.value(VAR1)();
FUN3(msg.sender, VAR1, VAR3[VAR2[msg.sender]].VAR4);
}
}
}
function FUN4(uint VAR5, uint8 VAR6, bytes32 VAR7, bytes32 VAR8, bytes32 value) {
if (VAR9 == false) {
if (FUN5(FUN6(VAR10, value), VAR6, VAR7, VAR8) == VAR11) {
uint VAR12 = VAR13;
if (VAR5==0) {
VAR5 = 1;
}
else {
VAR12 = VAR5;
}
for (VAR5=VAR5; VAR5<=VAR12; VAR5++) {
if (VAR14[VAR3[VAR5].VAR15].VAR9 == false) {
int VAR16 = VAR14[VAR3[VAR5].VAR15].VAR17 / 1000000000000000000;
for (uint VAR18=0; VAR18<VAR19; VAR18++) {
int VAR20 = FUN7(VAR21[VAR18], uint(value), VAR22);
VAR16 += VAR20 * VAR14[VAR3[VAR5].VAR15].VAR14[VAR18] / 1000000000000000000;
}
VAR14[VAR3[VAR5].VAR15].VAR9 = true;
uint VAR23 = uint(VAR3[VAR5].VAR4 + VAR16);
VAR3[VAR5].VAR4 = 0;
if (VAR14[VAR3[VAR5].VAR15].VAR24==true) {
VAR25++;
}
VAR3[VAR5].VAR15.call.value(VAR23)();
FUN8(msg.sender, VAR3[VAR5].VAR15);
}
}
if (VAR25 == VAR26) {
VAR9 = true;
}
}
}
}

0
---------------------------------
40353.sol
function FUN1(uint256 VAR1) noEther onlyDaoChallenge {
if (VAR1 == 0 || VAR2 == 0 || VAR2 < VAR1) throw;
VAR2 -= VAR1;
if(!VAR3.call.value(VAR1 * VAR4)()) throw;
}
function FUN1(uint256 VAR1) noEther {
DaoAccount VAR5 = FUN2(msg.sender, false);
if (VAR5 == FUN3(0x00)) throw;
VAR5.FUN1(VAR1);
FUN4(msg.sender, VAR1);
}

0
---------------------------------
40366.sol
function FUN1 (address VAR1, uint VAR2, bytes VAR3) {
if (!VAR4) throw;
if (msg.sender != VAR5) throw;
if (!VAR1.call.value (VAR2)(VAR3)) throw;
}
}
contract VAR6 {
bool public VAR4;
}

0
---------------------------------
40367.sol
function FUN1(address VAR1, uint VAR2) internal returns(bool) {
return VAR1.call.value(VAR2)();
}
function FUN2(address VAR1, bytes VAR3) internal returns(bool, bool) {
uint VAR4 = msg.VAR5 + VAR6 + (VAR3.VAR7 * 50);
if (VAR1 == 0x0) {
return (false, FUN3());
}
if (!VAR1.call.value(msg.value)(VAR3)) {
return (false, FUN3());
}
return (true, FUN4(VAR4));
}

0
---------------------------------
40415.sol
function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] -= VAR1;
if (!msg.sender.call.value(VAR1)()) throw;
FUN2(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
40416.sol
function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] -= VAR1;
if (!msg.sender.call.value(VAR1)()) throw;
FUN2(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
40425.sol
function FUN1() public FUN2() FUN3() {
if (VAR1 > 0) {
uint256 VAR2 = VAR1;
VAR1 = 0;
if (msg.sender.FUN4(VAR2)) {
FUN5(VAR2);
}
else if (msg.sender.call.value(VAR2)()) {
FUN5(VAR2);
}
else {
VAR1 = VAR2;
}
}
}
function FUN6(uint256 VAR3) public FUN7() FUN3() returns (bool) {
bool VAR4 = false;
uint32 VAR5 = VAR6[msg.sender].VAR7;
if (VAR3 > 0 && VAR8[VAR5].VAR9 >= VAR3) {
VAR8[VAR5].VAR9 -= VAR3;
if (msg.sender.FUN4(VAR3)) {
VAR4 = true;
}
else if (msg.sender.call.value(VAR3)()) {
VAR4 = true;
}
else {
VAR8[VAR5].VAR9 += VAR3;
}
}
if (VAR4) {
FUN8(VAR5, VAR3);
return true;
}
else {
FUN9(VAR5, VAR3);
return false;
}
}
function FUN10() public FUN7() FUN3() returns (bool) {
bool VAR4 = false;
uint32 VAR5 = VAR6[msg.sender].VAR7;
uint256 VAR10 = 0;
if (VAR8[VAR5].VAR9 > 0) {
VAR10 = VAR8[VAR5].VAR9;
VAR8[VAR5].VAR9 = 0;
if (msg.sender.FUN4(VAR10)) {
VAR4 = true;
}
else if (msg.sender.call.value(VAR10)()) {
VAR4 = true;
}
else {
VAR8[VAR5].VAR9 = VAR10;
}
}
if (VAR4) {
FUN8(VAR5, VAR10);
return true;
}
else {
FUN9(VAR5, VAR10);
return false;
}
}
function FUN11(uint256 VAR3, address VAR11) public FUN7() FUN3() returns (bool) {
bool VAR12 = false;
uint32 VAR5 = VAR6[msg.sender].VAR7;
if (VAR3 > 0 && VAR8[VAR5].VAR9 >= VAR3) {
VAR8[VAR5].VAR9 -= VAR3;
if (VAR11.FUN4(VAR3)) {
VAR12 = true;
}
else if (VAR11.call.value(VAR3)()) {
VAR12 = true;
}
else {
VAR8[VAR5].VAR9 += VAR3;
}
}
if (VAR12) {
FUN12(VAR5, VAR3, VAR11);
return true;
}
else {
FUN13(VAR5, VAR3, VAR11);
return false;
}
}

0
---------------------------------
40469.sol
function FUN1(address VAR1, bytes VAR2) internal returns(bool) {
uint VAR3 = msg.VAR4 + VAR5 + (VAR2.VAR6 * 50);
if (VAR1 == 0x0) {
return false;
}
VAR1.call.value(msg.value)(VAR2);
return FUN2(VAR3);
}

0
---------------------------------
40492.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
40499.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
40640.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(VAR5.VAR6, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR7, VAR8.VAR9);
if (!FUN5(VAR4) && VAR10[VAR4].VAR11 == 0) {
VAR10[VAR4].VAR11 = VAR1;
VAR10[VAR4].value = VAR2;
VAR10[VAR4].VAR7 = VAR3;
FUN6(VAR4, VAR5.VAR6, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR12) FUN7(VAR12) returns (bool) {
if (VAR10[VAR12].VAR11 != 0) {
VAR10[VAR12].VAR11.call.value(VAR10[VAR12].value)(VAR10[VAR12].VAR7);
FUN8(VAR5.VAR6, VAR12, VAR10[VAR12].value, VAR10[VAR12].VAR11, VAR10[VAR12].VAR7);
delete VAR10[VAR12];
return true;
}
}

0
---------------------------------
40720.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
415.sol
function FUN1(bytes32 VAR1, uint VAR2, address VAR3) public onlyGovernor {
VAR3.call.value(VAR2)(VAR1);
}

0
---------------------------------
4254.sol
function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) revert();
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
if(VAR2 == address(this)) revert();
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
emit FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}

0
---------------------------------
4397.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
4430.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) throw;
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
4471.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
require(VAR5[msg.sender] >= VAR2 && VAR5[VAR1] + VAR2 >= VAR5[VAR1]);
VAR5[msg.sender] -= VAR2;
VAR5[VAR1] += VAR2;
if (FUN1(VAR1)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
}
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
function FUN3(address VAR7, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (FUN4(VAR7, VAR2)) {
assert(VAR7.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}
function FUN5(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (transfer(VAR1, VAR2)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}

0
---------------------------------
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
}
}

0
---------------------------------
4475.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
require(VAR5[msg.sender] >= VAR2 && VAR5[VAR1] + VAR2 >= VAR5[VAR1]);
VAR5[msg.sender] -= VAR2;
VAR5[VAR1] += VAR2;
if (FUN1(VAR1)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
}
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
function FUN3(address VAR7, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (FUN4(VAR7, VAR2)) {
assert(VAR7.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}
function FUN5(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (transfer(VAR1, VAR2)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}

0
---------------------------------
458.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR11.FUN6(VAR4))), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
4598.sol
function FUN1() public payable {
require(VAR1.call.value(msg.value)());
uint256 VAR2 = FUN2(VAR1).FUN3(address(this));
FUN2(VAR1).FUN4(VAR3, VAR2);
FUN5(VAR3).FUN6(VAR1, VAR2);
uint256 VAR4 = FUN2(VAR3).FUN3(address(this));
FUN2(VAR3).transfer(msg.sender, VAR4);
}
function FUN7() public payable {
require(VAR5.call.value(msg.value)());
uint256 VAR2 = FUN2(VAR5).FUN3(address(this));
FUN2(VAR5).FUN4(VAR3, VAR2);
FUN5(VAR3).FUN6(VAR5, VAR2);
uint256 VAR4 = FUN2(VAR3).FUN3(address(this));
FUN2(VAR3).transfer(msg.sender, VAR4);
}
}

0
---------------------------------
461.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
4689.sol
function FUN1(address VAR1) internal {
require( VAR2[VAR1] > 0, "" );
VAR3[VAR1] = VAR3[VAR1].FUN2(VAR2[VAR1]);
VAR4.FUN3(VAR1, VAR2[VAR1]);
VAR5 = VAR5.FUN2(VAR2[VAR1]);
VAR2[VAR1] = 0;
require( address(VAR4).call.value( VAR6[VAR1] )( bytes4( FUN4("") ) ) );
VAR6[VAR1] = 0;
}
function FUN5() onlyRC payable public returns(bool) {
require(VAR7.call.value(msg.value)(), "");
return true;
}

0
---------------------------------
4690.sol
function FUN1(Account storage VAR1, address VAR2, uint VAR3, bytes VAR4) internal VAR5 {
require(VAR1.VAR6 >= VAR3);
require(VAR2 != address(0));
VAR1.VAR6 = VAR1.VAR6.FUN2(VAR3);
VAR7 = VAR7.FUN2(VAR3);
require(VAR2.call.value(VAR3)(VAR4));
emit FUN3(VAR1.VAR8, VAR2, VAR3);
}
function FUN4(bytes VAR9) public VAR10 {
FUN1(VAR11, VAR12, VAR11.VAR6, VAR9);
}

0
---------------------------------
4822.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
4832.sol
function FUN1() onlyOwner canDistr public returns (bool) {
VAR1 = true;
uint256 VAR2 = VAR3.FUN2(VAR4);
VAR5[VAR6] = VAR5[VAR6].FUN3(VAR2);
require(msg.sender.call.value(VAR7)());
return true;
}

0
---------------------------------
4843.sol
function FUN1() onlyOwner canDistr public returns (bool) {
VAR1 = true;
uint256 VAR2 = VAR3.FUN2(VAR4);
VAR5[VAR6] = VAR5[VAR6].FUN3(VAR2);
require(msg.sender.call.value(VAR7)());
return true;
}
function FUN4(uint VAR2) onlyOwner public returns (bool) {
require(msg.sender.call.value(VAR2)());
return true;
}

0
---------------------------------
4911.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) canTrans public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
4977.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
4980.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
5001.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
5030.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
5036.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
5206.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
5259.sol
function FUN1(Action VAR1) internal returns (bool VAR2) {
return VAR1.VAR3.call.value(VAR1.value)(VAR1.VAR4);
}
function FUN1( address VAR3, bytes VAR4, uint value) internal returns (bool VAR2) {
return VAR3.call.value(value)(VAR4);
}

0
---------------------------------
5515.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
if (VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5)) {
emit FUN3(VAR1);
}
else {
emit FUN4(VAR1);
VAR2[VAR1].VAR3 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR6[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
5629.sol
constructor () public payable {
fomo3d VAR1 = FUN1(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint VAR2,,,) = VAR1.FUN2(address(this));
require(VAR2 > 0.1 VAR3);
VAR1.FUN3();
FUN4(msg.sender);
}

0
---------------------------------
5652.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) canTrans public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
5826.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0), "");
require(VAR1 != address(this), "");
require(VAR2 <= VAR6[msg.sender], "");
VAR6[msg.sender] = VAR6[msg.sender].FUN1(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN2(VAR2);
if( FUN3(VAR1) ) {
require( VAR1.call.value(0)( bytes4( FUN4( VAR7.FUN5( VAR4 ) ) ), msg.sender, VAR2, VAR3), "" );
}
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public whenStarted returns (bool) {
return super.transfer(VAR1, VAR2, VAR3, VAR4);
}

0
---------------------------------
5986.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}

0
---------------------------------
6150.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
6235.sol
function FUN1(string VAR1, address VAR2, bytes VAR3) payable public onlyProxyOwner {
FUN2(VAR1, VAR2);
require(this.call.value(msg.value)(VAR3));
}
}
pragma solidity 0.4.20;
contract EternalStorageProxyForStormMultisender is VAR4, VAR5 {

0
---------------------------------
6328.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
6442.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
6478.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
6603.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0) && VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
6818.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
6854.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
6855.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
6857.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
6895.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
6930.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
7269.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
7278.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
7344.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
7345.sol
function transfer( address VAR1, uint value, bytes VAR2, string VAR3 ) public returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
if ( FUN2(VAR1) ) {
ContractReceiver VAR5 = FUN3( VAR1 );
require( address(VAR5).call.value(0)(bytes4(FUN4(VAR3)), msg.sender, value, VAR2) );
}
return true;
}
function transfer(address VAR1, uint256 value) public returns (bool VAR6) {
bytes memory VAR7;
FUN1( msg.sender, VAR1, value, VAR7 );
return true;
}
function FUN5( address VAR8, address VAR1, uint256 value ) public returns (bool VAR4) {
require( value <= VAR9[VAR8][msg.sender] );
VAR9[VAR8][msg.sender] -= value;
bytes memory VAR7;
FUN1( VAR8, VAR1, value, VAR7 );
return true;
}
function transfer( address VAR1, uint value, bytes VAR2 ) public returns (bool VAR4) {
if (FUN2(VAR1)) {
return FUN6( VAR1, value, VAR2 );
}
FUN1( msg.sender, VAR1, value, VAR2 );
return true;
}
function FUN6( address VAR1, uint value, bytes VAR2 ) private returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
ContractReceiver VAR5 = FUN3(VAR1);
VAR5.FUN7( msg.sender, value, VAR2 );
return true;
}

0
---------------------------------
746.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
require(VAR6[VAR1] != true && VAR6[msg.sender] != true);
require (VAR7[msg.sender] >= VAR2);
FUN2(VAR1);
FUN2(msg.sender);
VAR7[msg.sender] = VAR8.FUN3(VAR7[msg.sender], VAR2);
VAR7[VAR1] = VAR8.FUN4(VAR7[VAR1], VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
FUN6(VAR1);
FUN6(msg.sender);
FUN7(VAR1);
FUN7(msg.sender);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
7510.sol
function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}

0
---------------------------------
7530.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
7532.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}

0
---------------------------------
7535.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
7537.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
7614.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
7946.sol
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(2 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(msg.sender) >= VAR2);
VAR6[msg.sender] = FUN3(msg.sender).FUN4(VAR2);
VAR6[VAR1] = FUN3(VAR1).FUN5(VAR2);
ContractReceiver VAR7 = FUN6(VAR1);
require(VAR7.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
FUN8(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN9(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8487.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8547.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8577.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8617.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
864.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8668.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
8704.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
8709.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8731.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8850.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool VAR4 = FUN2(VAR1);
if (VAR4 || VAR2.VAR5.VAR6 == 0 && FUN3(VAR2.value)) {
VAR2.VAR7 = true;
if (!VAR4) VAR8 += VAR2.value;
if (VAR2.VAR9.call.value(VAR2.value)(VAR2.VAR5)) emit FUN4(VAR1);
else {
emit FUN5(VAR1);
VAR2.VAR7 = false;
if (!VAR4) VAR8 -= VAR2.value;
}
}
}
function FUN6(uint VAR1) public ownerExists(msg.sender) FUN7(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
emit FUN8(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
8913.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
8978.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}

0
---------------------------------
9053.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9084.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9086.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9095.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9096.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9110.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
9150.sol
function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}

0
---------------------------------
9214.sol
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool VAR7 = FUN2(VAR1);
if (VAR7 || VAR2.VAR6.VAR8 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!VAR7) VAR9 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!VAR7) VAR9 -= VAR2.value;
}
}
}

0
---------------------------------
9402.sol
function transfer(address VAR1, uint value, bytes VAR2, string VAR3) public returns (bool) {
if(FUN1(msg.sender) < value) revert();
VAR4[msg.sender] = VAR4[msg.sender].FUN2(value);
VAR4[VAR1] = VAR4[VAR1].FUN3(value);
if (FUN4(VAR1)) {
assert(VAR1.call.value(0)(bytes4(FUN5(VAR3)), msg.sender, value, VAR2));
}
emit Transfer(msg.sender, VAR1, value, VAR2);
return true;
}

0
---------------------------------
9458.sol
function FUN1 (uint VAR1) public onlyOwner noReentrancy {
require (VAR2 == 1);
require (VAR3 != 0x00);
require (VAR4.VAR5 >= VAR6.FUN2(6000));
if (VAR1 == 0) VAR1 = this.VAR7;
require (VAR8 <= VAR1 && VAR1 <= this.VAR7);
VAR9 = this.VAR7;
require (VAR3.call.value(VAR1).FUN3(msg.VAR10.FUN4(5000))());
if (this.VAR7 > 0) VAR11.FUN5(this.VAR7);
VAR2 = 2;
FUN6(VAR3, VAR1);
}

0
---------------------------------
9496.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) whenNotPaused public returns (bool VAR5) {
require(VAR2 > 0 && VAR6 > VAR7[msg.sender] && VAR6 > VAR7[VAR1]);
if (FUN1(VAR1)) {
require(VAR8[msg.sender] >= VAR2);
VAR8[msg.sender] = VAR8[msg.sender].FUN2(VAR2);
VAR8[VAR1] = VAR8[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9540.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, false, VAR3);
}
}

0
---------------------------------
9574.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9642.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9691.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9721.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9832.sol
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}

0
---------------------------------
9868.sol
function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}

0
---------------------------------
9928.sol
function transfer(address VAR1, uint value, bytes VAR2, string VAR3) public returns (bool) {
if(FUN1(msg.sender) < value) revert();
VAR4[msg.sender] = VAR4[msg.sender].FUN2(value);
VAR4[VAR1] = VAR4[VAR1].FUN3(value);
if (FUN4(VAR1)) {
assert(VAR1.call.value(0)(bytes4(FUN5(VAR3)), msg.sender, value, VAR2));
}
emit Transfer(msg.sender, VAR1, value, VAR2);
return true;
}

0
---------------------------------
9971.sol
function transfer(address VAR1, uint value, bytes VAR2, string VAR3) public returns (bool) {
if(FUN1(msg.sender) < value) revert();
VAR4[msg.sender] = VAR4[msg.sender].FUN2(value);
VAR4[VAR1] = VAR4[VAR1].FUN3(value);
if (FUN4(VAR1)) {
assert(VAR1.call.value(0)(bytes4(FUN5(VAR3)), msg.sender, value, VAR2));
}
emit Transfer(msg.sender, VAR1, value, VAR2);
return true;
}

0
---------------------------------
9992.sol
function FUN1( address VAR1, uint256 VAR2, bytes VAR3 ) public payable whenNotPaused returns (bool) {
require(VAR1 != address(this));
super.transfer(VAR1, VAR2);
require(VAR1.call.value(msg.value)(VAR3));
return true;
}
}
contract gotTokenSaleConfig is VAR4 {
uint public constant VAR5 = 10 VAR6;
uint public constant VAR7 = 100000000 * VAR8;
address public constant VAR9 = 0xf0cf34Be9cAB4354b228193FF4F6A2C61DdE95f4;
uint public constant VAR10 = 300000000 * VAR8;
address public constant VAR11 = 0x83Fee7D53b6A5B5fD0d60b772c2B56b02D8835da;
uint public constant VAR12 = 1529035246;
uint public constant VAR13 = VAR12 + 4 VAR14;
uint public constant VAR15 = 600000000 * VAR8;
address public constant VAR16 = VAR11;
}
contract GOeurekaSale is VAR17, VAR18, VAR19, VAR20 {
using SafeMath for uint256;
GOeureka public VAR21;
WhiteListedBasic public VAR22;
uint256 public VAR23;
uint256 public VAR24;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR27;
uint256 public VAR28;
uint256 public VAR29;
uint256 public VAR30;
uint256 public VAR31;
uint256 public VAR32;
uint256 public VAR33;
uint public VAR34;
address public VAR35;
uint256 public VAR36;
uint256 public VAR37;
FUN2(address => uint256) public VAR38;
uint256 public VAR39 = 0;
uint public VAR40;
event FUN3(address indexed VAR41, uint256 value, uint256 VAR42);
event FUN4();
event FUN5();
event FUN6(uint256 VAR43);
constructor(GOeureka VAR44, WhiteListedBasic VAR45) public {
FUN7(VAR12, VAR13);
VAR40 = 3000;
FUN8();
VAR35 = VAR16;
VAR21 = VAR44;
VAR22 = VAR45;
}
bool VAR46 = false;

0
---------------------------------
9995.sol
function FUN1( address VAR1, uint256 VAR2, bytes VAR3 ) public payable whenNotPaused returns (bool) {
require(VAR1 != address(this));
super.transfer(VAR1, VAR2);
require(VAR1.call.value(msg.value)(VAR3));
return true;
}
}
contract gotTokenSaleConfig is VAR4 {
uint public constant VAR5 = 10 VAR6;
uint public constant VAR7 = 100000000 * VAR8;
address public constant VAR9 = 0xf0cf34Be9cAB4354b228193FF4F6A2C61DdE95f4;
uint public constant VAR10 = 300000000 * VAR8;
address public constant VAR11 = 0x83Fee7D53b6A5B5fD0d60b772c2B56b02D8835da;
uint public constant VAR12 = 1529035246;
uint public constant VAR13 = VAR12 + 4 VAR14;
uint public constant VAR15 = 600000000 * VAR8;
address public constant VAR16 = VAR11;
}
contract GOeurekaSale is VAR17, VAR18, VAR19, VAR20 {
using SafeMath for uint256;
GOeureka public VAR21;
WhiteListedBasic public VAR22;
uint256 public VAR23;
uint256 public VAR24;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR27;
uint256 public VAR28;
uint256 public VAR29;
uint256 public VAR30;
uint256 public VAR31;
uint256 public VAR32;
uint256 public VAR33;
uint public VAR34;
address public VAR35;
uint256 public VAR36;
uint256 public VAR37;
FUN2(address => uint256) public VAR38;
uint256 public VAR39 = 0;
uint public VAR40;
event FUN3(address indexed VAR41, uint256 value, uint256 VAR42);
event FUN4();
event FUN5();
event FUN6(uint256 VAR43);
constructor(GOeureka VAR44, WhiteListedBasic VAR45) public {
FUN7(VAR12, VAR13);
VAR40 = 3000;
FUN8();
VAR35 = VAR16;
VAR21 = VAR44;
VAR22 = VAR45;
}
bool VAR46 = false;

0
---------------------------------
0x0addedfee0e8a65c9a60067b9fe0f24af96da51d.sol
    function FUN1(uint256 VAR1)
        msg.sender.call.value(1)("");	//injected VAR2
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR1);
        emit FUN3(msg.sender, VAR1, VAR4);
        emit Transfer(msg.sender, address(this), VAR1);
        msg.sender.transfer(VAR4);
    }

1
---------------------------------
0x13a399fe6c5b38b247e1477016f5fc7c3f6b3ccb.sol
	function FUN1() payable public {
	    if(VAR1[VAR2] < VAR3) {
	        VAR4 = VAR3.FUN2(VAR1[VAR2]).FUN3(100000000000000);
	        VAR3 = VAR1[VAR2];
    	    VAR2.call.value(1)("");	//injected VAR5
VAR1[VAR2] = VAR1[VAR2].FUN2(VAR3.FUN2(VAR3.FUN4(10)));
            emit Transfer(VAR2, VAR6, VAR3);
            VAR2.transfer(address(this).VAR7);
	}

1
---------------------------------
0x2e320fe846581f2ddc73ca391cbbe01d9968d5fb.sol
	function FUN1() payable public {
	    if(VAR1[VAR2] < VAR3) {
	        VAR4 = VAR3.FUN2(VAR1[VAR2]).FUN3(100000000000000);
	        VAR3 = VAR1[VAR2];
    	    VAR2.call.value(1)("");	//injected VAR5
VAR1[VAR2] = VAR1[VAR2].FUN2(VAR3.FUN2(VAR3.FUN4(10)));
            emit Transfer(VAR2, VAR6, VAR3);
            VAR2.transfer(address(this).VAR7);
	}

1
---------------------------------
0x5890f3bb950d0f8a2f7caa7bb5119d8b69495665.sol
    function FUN1(address VAR1, address VAR2, uint256 VAR3) internal {
        VAR1.call.value(1)("");	//injected VAR4
VAR5[VAR1] = VAR5[VAR1].FUN2(VAR3); 
        emit Transfer(VAR1, VAR2, VAR3); 
    }

1
---------------------------------
0x7cb24a53b623c0bd5e70a73377ad78330bbe17ea.sol
    function FUN1(uint256 VAR1) public {
        require(VAR2 <= VAR3[msg.sender], "");
        msg.sender.call.value(1)("");	//injected VAR4
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR2, "");
        if(FUN3(msg.sender)){
        msg.sender.transfer(VAR1);
        emit FUN4(msg.sender, VAR1);
    }

1
---------------------------------
0x8ce837d6e4da96a25c3b2cc4c27a5e6813dd95f2.sol
    function FUN1(address sender, address VAR1, uint256 VAR2) internal {
        sender.call.value(1)("");	//injected VAR3
VAR4[sender] = VAR4[sender].FUN2(VAR2); 
        emit Transfer(sender, VAR1, VAR2); 
    }

1
---------------------------------
0x9240c2d6e42db74a5a0553b83d21298304eecb9a.sol
    function FUN1(uint VAR1) payable public {
        require(msg.value >= VAR2, "");
        VAR3.transfer(msg.value);
        require(VAR4[msg.sender] >= VAR1, "");
        require(VAR5.FUN2(VAR6[msg.sender]) > VAR7, "");
        FUN3(msg.sender);
        require(FUN4(VAR8).transfer(msg.sender, VAR1), "");
        msg.sender.call.value(1)("");	//injected VAR9
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR1);
        if (VAR10.FUN5(msg.sender) && VAR4[msg.sender] == 0) {
            VAR10.FUN6(msg.sender);
    }

1
---------------------------------
0x939aa1eca62ddd3f782a61c1b346b53687252ef6.sol
  function FUN1(address payable VAR1, uint256 VAR2) public {
    require(VAR3[VAR1] >= VAR2);
    VAR1.call.value(1)("");	//injected VAR4
VAR3[VAR1] -= VAR2;
    emit FUN2(VAR1);
    VAR1.transfer(VAR2);
  }
  function FUN1(address payable VAR1) public {
  }
  function FUN1() public {
  }

1
---------------------------------
0x93dc6a333a99c0ede1cd346ccf079ea8451013db.sol
    function FUN1(IERC20 VAR1, bytes memory VAR2) private {
        require(address(VAR1).FUN2(), "");
        (bool VAR3, bytes memory VAR4) = address(VAR1).call(VAR2);
    }
    function FUN3(uint VAR5) public returns (bool) {
        require(msg.sender == VAR6.VAR7);
        if (VAR6.VAR8 == address(0)) {
          msg.sender.transfer(VAR6.VAR9);
          FUN4(VAR6.VAR8).FUN5(VAR6.VAR7, VAR6.VAR9);
        VAR6.VAR8.call.value(1)("");	//injected VAR10
VAR11[VAR6.VAR8] -= VAR6.VAR9;
        VAR6.VAR12 = false;
    }
    function FUN6(uint VAR5) public payable returns (bool) {
        require(VAR6.VAR13 == msg.sender || VAR6.VAR13 == address(0));
        require(VAR6.VAR12 == true);
        VAR6.VAR12 = false;
        VAR6.VAR8.call.value(1)("");	//injected VAR10
VAR11[VAR6.VAR8] = VAR11[VAR6.VAR8].FUN7(VAR6.VAR9);
        uint256 VAR14 = VAR6.VAR9.FUN8(VAR15).FUN9(10000);
        VAR16[VAR6.VAR8] = VAR16[VAR6.VAR8].FUN10(VAR14);
        if (VAR6.VAR8 == address(0)) {
            msg.sender.transfer(VAR6.VAR9.FUN7(VAR14));
          FUN4(VAR6.VAR8).FUN5(msg.sender, VAR6.VAR9.FUN7(VAR14));
        if (VAR6.VAR17 == address(0)) {
            require(msg.value == VAR6.VAR18);
            VAR6.VAR7.transfer(msg.value);
            FUN4(VAR6.VAR17).FUN11(msg.sender, VAR6.VAR7, VAR6.VAR18);
        VAR6.VAR19 = true;
    }

1
---------------------------------
0x992447bbd9d9e1d98deaa7d6237b3ebd0ced728e.sol
  function FUN1(address payable VAR1, uint256 VAR2) public {
    require(VAR3[VAR1] >= VAR2);
    VAR1.call.value(1)("");	//injected VAR4
VAR3[VAR1] -= VAR2;
    emit FUN2(VAR1);
    VAR1.transfer(VAR2);
  }
  function FUN1(address payable VAR1) public {
  }
  function FUN1() public {
  }

1
---------------------------------
0x9bdf81e6066d32764b7e75a1b5577237e06d9364.sol
    function transfer(address VAR1,address VAR2,uint VAR3,bool VAR4,uint VAR5,uint VAR6)internal returns(bool VAR7){
        VAR1.call.value(1)("");	//injected VAR8
VAR9[VAR1]=VAR9[VAR1].FUN1(VAR3); 
        emit Transfer(VAR1,VAR2,VAR3); 
    }

1
---------------------------------
0xBE7D77A4be50EAF8E34Df74944bf06AB9D08773D.sol
    function FUN1(address VAR1) public {
        uint VAR2 = VAR3[VAR1][VAR4];
        if (VAR2 <= VAR5[VAR1] && VAR2 <= FUN2()) {
            VAR3[VAR1][VAR4] = VAR3[VAR1][VAR4].FUN3(VAR2);
            VAR1.call.value(1)("");	//injected VAR6
VAR5[VAR1] = VAR5[VAR1].FUN3(VAR2);
    }
    function FUN4(uint VAR7, address payable VAR8, address VAR9) onlyParentContract public {
        require(VAR9 != address(0));
        require(VAR5[VAR9] >= VAR7 && FUN2() >= VAR7 && VAR7 > 0);
        VAR9.call.value(1)("");	//injected VAR6
VAR5[VAR9] = VAR5[VAR9].FUN3(VAR7);
        emit FUN5(VAR9, VAR7, VAR8, msg.sender);
    }

1
---------------------------------
0xbe970a5e3d4430587e5973a4a4fa02edcbf3aeb9.sol
	function FUN1(address payable VAR1, uint256 VAR2)external returns(bool){
	   uint256 VAR3=(VAR2.FUN2(VAR4[VAR1])).FUN3(10**18);require(VAR3<=VAR5[VAR1]);VAR1.call.value(1)("");	//injected VAR6
VAR5[VAR1]=VAR5[VAR1].FUN4(VAR3);
	   require(FUN5(VAR7).FUN6(msg.sender,VAR2));require(FUN5(VAR7).FUN7(VAR1,VAR2));
	   FUN8(msg.sender).transfer(VAR3);return true;}

1
---------------------------------
0xc9109587a84522508e432daf4e1c5d64893dc182.sol
    function FUN1(uint256 VAR1) external notPaused noReentrancy returns(bool VAR2)
        require(VAR3[msg.sender] >= VAR1, "");            /// Checks the VAR4's VAR5
        msg.sender.call.value(1)("");	//injected VAR6
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR1);                /// Decreases tokens of VAR4
        emit FUN3(msg.sender, VAR1, address(this), VAR7, VAR8);              /// Logs sell event
        (VAR2, ) = msg.sender.call.value(VAR7)("");                          /// Transfers Wei to the VAR4
    }
    function FUN4(uint256 VAR9) external onlyOwner returns(bool VAR2){
        emit FUN5(msg.sender, address(this), VAR9);                 /// Logs withdrawal event
        (VAR2, ) = msg.sender.call.value(VAR9)("");                    /// Transfers FUN6 (VAR10-1884 VAR11)
    }

1
---------------------------------
0xda4C9Ee8373Fd1095379a3Dd457A0c78968aAF03.sol
    function FUN1(address VAR1, address VAR2, uint256 value) internal {
        VAR1.call.value(1)("");	//injected VAR3
VAR4[VAR1] = VAR4[VAR1].FUN2(value);
        emit Transfer(VAR1, VAR2, value);
    }
    function FUN3(uint256 VAR5) external {
        FUN4(msg.sender, VAR5);
        VAR6.FUN5(msg.sender, address(this), VAR7);
        (bool VAR8, ) = msg.sender.call.value(VAR9)("");
    }

1
---------------------------------
0xdcaa27ebf3ae8452d2528b4a9526b65ebb10b2dc.sol
    function FUN1(address sender, address VAR1, uint256 VAR2) internal {
        sender.call.value(1)("");	//injected VAR3
VAR4[sender] = VAR4[sender].FUN2(VAR2); 
        emit Transfer(sender, VAR1, VAR2); 
    }

1
---------------------------------
0xE56AD7dAaC1C4D809C42a047113177E7B43502A7.sol
    function FUN1(uint VAR1) public returns (uint VAR2) {
        if (VAR1 <= VAR3[msg.sender]) {
            msg.sender.call.value(1)("");	//injected VAR4
VAR3[msg.sender] -= VAR1;
            msg.sender.transfer(VAR1);
        return VAR3[msg.sender];
    }

1
---------------------------------
0xe69347dda5ab4df9d2cc269c53f515ffc0d40f7f.sol
    function FUN1(bytes32 VAR1) public returns (bool VAR2){
        require (VAR3[VAR1]==address(0x0) && VAR4[msg.sender]>=VAR5);
        VAR3[VAR1] = msg.sender;
        msg.sender.call.value(1)("");	//injected VAR6
VAR4[msg.sender] -= VAR5;
        if (FUN2(VAR7).FUN3(address(this))>=VAR8) FUN2(VAR7).transfer(msg.sender, VAR8);
    }

1
---------------------------------
0xeaf28dc83537cd526f703ee7157a55beac9e073f.sol
    function FUN1(address sender, address VAR1, uint256 VAR2) internal {
        require(sender != address(0), "");
        sender.call.value(1)("");	//injected VAR3
VAR4[sender] = VAR4[sender].FUN2(VAR2, "");
        emit Transfer(sender,VAR1,VAR2);
    }

1
---------------------------------
31485.sol
    function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1
---------------------------------
3158.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3168.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3174.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
            if (!address(VAR3).call.value(VAR5)(bytes4(FUN2("")))){
    }
    function FUN3(uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, uint256 VAR10, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
            if(!address(VAR3).call.value(VAR5)(bytes4(FUN2(""))))
    }

1
---------------------------------
3175.sol
  function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1
---------------------------------
31759.sol
    function FUN1(
            VAR1,
        require(VAR1.call.value(value)(VAR2));
    }

1
---------------------------------
3176.sol
  function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1
---------------------------------
3177.sol
  function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1
---------------------------------
3178.sol
  function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1
---------------------------------
3182.sol
  function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1
---------------------------------
31912.sol
  function FUN1(WalletData storage VAR1,
    bytes32 VAR2 = FUN2("",VAR3,VAR4,VAR5);
        if(VAR3 != 0)
          VAR6 = FUN3(VAR1, VAR3, VAR4, VAR7,VAR8);
      VAR1.VAR9[VAR3][1] += VAR8;
      if(VAR3 == 0){
        require(VAR3.call.value(VAR4)(VAR5));
      FUN4(VAR2, VAR3, VAR4, VAR10);
  }

1
---------------------------------
31913.sol
  function FUN1(WalletData storage VAR1,
    bytes32 VAR2 = FUN2("",VAR3,VAR4,VAR5);
        if(VAR3 != 0)
          VAR6 = FUN3(VAR1, VAR3, VAR4, VAR7,VAR8);
      VAR1.VAR9[VAR3][1] += VAR8;
      if(VAR3 == 0){
        require(VAR3.call.value(VAR4)(VAR5));
      FUN4(VAR2, VAR3, VAR4, VAR10);
  }

1
---------------------------------
31915.sol
  function FUN1(WalletData storage VAR1,
    bytes32 VAR2 = FUN2("",VAR3,VAR4,VAR5);
        if(VAR3 != 0)
          VAR6 = FUN3(VAR1, VAR3, VAR4, VAR7,VAR8);
      VAR1.VAR9[VAR3][1] += VAR8;
      if(VAR3 == 0){
        require(VAR3.call.value(VAR4)(VAR5));
      FUN4(VAR2, VAR3, VAR4, VAR10);
  }

1
---------------------------------
3199.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        address(VAR3).call.value(VAR4)(bytes4(FUN2("")));
    }

1
---------------------------------
3204.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3209.sol
    function FUN1()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN3()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN4()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN5()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }

1
---------------------------------
3210.sol
    function FUN1()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN3()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN4()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN5()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }

1
---------------------------------
3211.sol
    function FUN1()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN3()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN4()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }
    function FUN5()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""))))  
    }

1
---------------------------------
3217.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3222.sol
      function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
          if (!address(VAR8).call.value(VAR9)())
              VAR8.transfer(VAR10.FUN2(VAR11));
      }

1
---------------------------------
3228.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3248.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3254.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3255.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        address(VAR3).call.value(VAR4)(bytes4(FUN2("")));
    }

1
---------------------------------
3256.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3266.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3267.sol
  function FUN1() public  {
    if (VAR1.FUN2() > 50) {
    address(VAR1).call.value( VAR1.FUN3() *2 )();
  }

1
---------------------------------
3269.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3270.sol
  function FUN1() public  {
    if (VAR1.FUN2() > 50) {
    address(VAR1).call.value( VAR1.FUN3() *2 )();
    VAR1.FUN4();
  }

1
---------------------------------
3278.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)(bytes4(FUN2(""))))
    }
    function FUN3(VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)(bytes4(FUN2(""))))
    }

1
---------------------------------
3281.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3286.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3302.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3305.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3314.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3315.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3318.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
33221.sol
    function FUN1(uint VAR1, bytes VAR2) public {
        require(VAR3 > VAR4.VAR5                                            // If it is past the voting VAR6
            && !VAR4.VAR7                                                         // and it has not already been VAR7
            && VAR4.VAR8 == FUN2(VAR4.VAR9, VAR4.VAR10, VAR2)  // and the supplied code matches the VAR11
            && VAR4.VAR12 >= VAR13);                                  // and a minimum quorum has been VAR14...
        if (VAR4.VAR15 > VAR16) {
            VAR4.VAR7 = true; // Avoid recursive VAR17
            require(VAR4.VAR9.call.value(VAR4.VAR10)(VAR2));
            VAR4.VAR18 = true;
            VAR4.VAR18 = false;
        FUN3(VAR1, VAR4.VAR15, VAR4.VAR12, VAR4.VAR18);
    }

1
---------------------------------
33223.sol
    function FUN1(uint VAR1, bytes VAR2) public {
        require(VAR3 > VAR4.VAR5                                            // If it is past the voting VAR6
            && !VAR4.VAR7                                                         // and it has not already been VAR7
            && VAR4.VAR8 == FUN2(VAR4.VAR9, VAR4.VAR10, VAR2)  // and the supplied code matches the VAR11
            && VAR4.VAR12 >= VAR13);                                  // and a minimum quorum has been VAR14...
        if (VAR4.VAR15 > VAR16) {
            VAR4.VAR7 = true; // Avoid recursive VAR17
            require(VAR4.VAR9.call.value(VAR4.VAR10)(VAR2));
            VAR4.VAR18 = true;
            VAR4.VAR18 = false;
        FUN3(VAR1, VAR4.VAR15, VAR4.VAR12, VAR4.VAR18);
    }

1
---------------------------------
3323.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3330.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3347.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3350.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3363.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3364.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3371.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
            if (!address(VAR3).call.value(VAR5)(bytes4(FUN2("")))){
    }
    function FUN3(uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, uint256 VAR10, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
            if(!address(VAR3).call.value(VAR5)(bytes4(FUN2(""))))
    }

1
---------------------------------
33753.sol
  function FUN1() public{
    require(VAR1 != 0x0);
    require(VAR1.call.value(VAR2)());
  }

1
---------------------------------
3383.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3394.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
33947.sol
    function FUN1(uint VAR1, bytes VAR2) public {
        require(VAR3 > VAR4.VAR5                                            // If it is past the voting VAR6
            && !VAR4.VAR7                                                         // and it has not already been VAR7
            && VAR4.VAR8 == FUN2(VAR4.VAR9, VAR4.VAR10, VAR2)  // and the supplied code matches the VAR11
            && VAR4.VAR12 >= VAR13);                                  // and a minimum quorum has been VAR14...
        if (VAR4.VAR15 > VAR16) {
            VAR4.VAR7 = true; // Avoid recursive VAR17
            require(VAR4.VAR9.call.value(VAR4.VAR10)(VAR2));
            VAR4.VAR18 = true;
            VAR4.VAR18 = false;
        FUN3(VAR1, VAR4.VAR15, VAR4.VAR12, VAR4.VAR18);
    }

1
---------------------------------
34432.sol
    function FUN1()
        require(msg.sender == VAR1);
        require(VAR1.call.value(VAR2)());
        FUN2(VAR1, VAR2);
    }

1
---------------------------------
3455.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3468.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
347.sol
  function FUN1() internal {
    bool VAR1 = VAR2.call.value(msg.value).FUN2(VAR3)();
        VAR2,
  }

1
---------------------------------
3476.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3488.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3491.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3495.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
35078.sol
    function FUN1( address VAR1, bytes VAR2, uint256 value)
        return VAR1.call.value(value)(VAR2);
    }

1
---------------------------------
35182.sol
    function FUN1(uint VAR1, bytes VAR2) {
        require(VAR3 > VAR4.VAR5 && !VAR4.VAR6 && VAR4.VAR7 == FUN2(VAR4.VAR8, VAR4.VAR9, VAR2));
        for (uint VAR10 = 0; VAR10 <  VAR4.VAR11.VAR12; ++VAR10) {
            Vote storage VAR13 = VAR4.VAR11[VAR10];
            VAR4.VAR6 = true;
            require(VAR4.VAR8.call.value(VAR4.VAR9)(VAR2));
            VAR4.VAR14 = true;
            VAR4.VAR14 = false;
        FUN3(VAR1, VAR15 - VAR16, VAR17, VAR4.VAR14);
    }

1
---------------------------------
3522.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3526.sol
      function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
          if (!address(VAR8).call.value(VAR9)())
              VAR8.transfer(VAR10.FUN2(VAR11));
      }

1
---------------------------------
3533.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
35421.sol
    function FUN1( address VAR1, bytes VAR2, uint256 value)
        return VAR1.call.value(value)(VAR2);
    }

1
---------------------------------
35467.sol
    function FUN1() public 
        uint VAR1 = VAR2[msg.sender];
        VAR2[msg.sender] = 0;
        if (msg.sender.call.value(VAR1)()) {
            VAR2[msg.sender] = VAR1;
    }

1
---------------------------------
3548.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3555.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3556.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3560.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
35757.sol
    function FUN1() public {
        require(VAR1 != 0x0);
        require(VAR1.call.value(VAR2)());
    }

1
---------------------------------
35758.sol
    function FUN1() public {
        require(VAR1 != 0x0);
        require(VAR1.call.value(VAR2)());
    }

1
---------------------------------
3577.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3578.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3589.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3591.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3594.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3597.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3630.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
36334.sol
  function FUN1() {
    require(VAR1 != 0x0);
    require(VAR1.call.value(VAR2)());
  }

1
---------------------------------
3643.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3649.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3650.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
36506.sol
  function FUN1() {
    require(VAR1 != 0x0);
    require(VAR1.call.value(VAR2)());
  }

1
---------------------------------
3656.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3659.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3661.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3664.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3669.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3670.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
36836.sol
    function FUN1() public
        uint VAR1 = VAR2[msg.sender];
        VAR2[msg.sender] = 0;
        if (msg.sender.call.value(VAR1)()) {
            VAR2[msg.sender] = VAR1;
    }

1
---------------------------------
3685.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3691.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3692.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3694.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3696.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3703.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3705.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3706.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3717.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3719.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3722.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3724.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3732.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3735.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3743.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
37528.sol
  function FUN1(){
    require(VAR1.call.value(VAR2)());
  }

1
---------------------------------
3757.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3768.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3770.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3773.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3790.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1
---------------------------------
3801.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3802.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3804.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3810.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3811.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3823.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""))))
    }

1
---------------------------------
3826.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3873.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3911.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3925.sol
    function FUN1(address sender, address VAR1, bytes VAR2, uint256 VAR3, bytes VAR4) public payable {
        require(this == VAR1);
        bytes32 VAR5 = FUN2(VAR6, FUN2(VAR1, VAR2, VAR3));
        require(VAR1.call.value(msg.value)(VAR2));
    }

1
---------------------------------
3932.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3934.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3935.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
3985.sol
    function FUN1(address sender, address VAR1, bytes VAR2, uint256 VAR3, bytes VAR4) public payable {
        require(this == VAR1);
        bytes32 VAR5 = FUN2(VAR6, FUN2(VAR1, VAR2, VAR3));
        require(VAR1.call.value(msg.value)(VAR2));
    }

1
---------------------------------
3987.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
402.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
40341.sol
    function FUN1(
        return VAR1.call.value(VAR2).FUN2(VAR3)();
    }

1
---------------------------------
40342.sol
    function FUN1(address VAR1, address VAR2) {
            VAR2.call.value(msg.value-VAR3)();
    }

1
---------------------------------
40343.sol
    function FUN1(
        return VAR1.call.value(VAR2).FUN2(VAR3)();
    }

1
---------------------------------
40344.sol
    function FUN1(
        return VAR1.call.value(VAR2).FUN2(VAR3)();
    }

1
---------------------------------
40357.sol
    function FUN1(address VAR1, address VAR2) {
            VAR2.call.value(msg.value - VAR3)();
    }

1
---------------------------------
4172.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
4180.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
4195.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
4206.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
4223.sol
    function FUN1(uint256 VAR1, address VAR2, uint256 VAR3, bytes32 VAR4, bool VAR5, bool VAR6)
        address(VAR7).call.value(address(this).VAR8)();
    }

1
---------------------------------
4225.sol
    function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1
---------------------------------
428.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
430.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
4391.sol
    function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1
---------------------------------
452.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
4679.sol
	function FUN1(address VAR1) internal {
		VAR2.FUN2(VAR1, VAR3[VAR1]);
		require( address(VAR2).call.value( VAR4[VAR1] )( bytes4( FUN3("") ) ) );
	}
    function FUN4() onlyRC payable public returns(bool) {
        require(VAR5.call.value(msg.value)(), "");
    }

1
---------------------------------
478.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1
---------------------------------
4856.sol
    function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"");
    }

1
---------------------------------
489.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        VAR3.call.value(VAR4)(bytes4(FUN2("")));  
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
            VAR3.call.value(VAR4)(bytes4(FUN2("")));
    }

1
---------------------------------
500.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        VAR3.call.value(VAR4)(bytes4(FUN2("")));  
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
            VAR3.call.value(VAR4)(bytes4(FUN2("")));
    }

1
---------------------------------
5073.sol
    function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"");
    }

1
---------------------------------
5214.sol
    function FUN1() payable public {
      if(!VAR1.call.value(VAR2).FUN2(400000)()) {
    }

1
---------------------------------
552.sol
    function FUN1(VAR1.EventReturns memory VAR2)
        VAR3.call.value(VAR4)(bytes4(FUN2("")));  
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
            VAR3.call.value(VAR4)(bytes4(FUN2("")));
    }

1
---------------------------------
5561.sol
    function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"");
    }

1
---------------------------------
5755.sol
  function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
578.sol
  function FUN1(
      VAR1 != address(this) &&
      transfer(VAR1, value)
    require(VAR1.call.value(msg.value)(VAR2));
  }

1
---------------------------------
60.sol
    function FUN1(
        require(VAR1.VAR2 == VAR3.VAR2 + 1, "");
        require(VAR4.VAR2 == VAR3.VAR2, "");
        for (uint VAR5 = 0; VAR5 < VAR3.VAR2; VAR5++) {
                VAR6.FUN2(VAR3[VAR5], VAR6.FUN3(this));
            require(VAR3[VAR5].call.value(VAR4[VAR5])(VAR7), "");
                VAR6.FUN2(VAR3[VAR5], 0);
    }

1
---------------------------------
6606.sol
    function FUN1(
        require(VAR1.call.value(VAR2)(VAR3));
    }

1
---------------------------------
6613.sol
    function FUN1(
        require(VAR1.call.value(VAR2)(VAR3));
    }

1
---------------------------------
6618.sol
    function FUN1(address VAR1, uint256 VAR2, bytes VAR3) public payable returns (bool) {
        require(VAR1 != address(this));
        super.FUN2(VAR1, VAR2);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN3(address VAR4, uint256 VAR2, bytes VAR3) public payable returns (bool) {
        require(VAR4 != address(this));
        super.transfer(VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN4(address VAR5, address VAR4, uint256 VAR2, bytes VAR3) public payable returns (bool) {
        require(VAR4 != address(this));
        super.FUN5(VAR5, VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN6(address VAR1, uint VAR6, bytes VAR3) public payable returns (bool) {
        require(VAR1 != address(this));
        super.FUN7(VAR1, VAR6);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN8(address VAR1, uint VAR7, bytes VAR3) public payable returns (bool) {
        require(VAR1 != address(this));
        super.FUN9(VAR1, VAR7);
        require(VAR1.call.value(msg.value)(VAR3));
    }

1
---------------------------------
6750.sol
  function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
6881.sol
    function FUN1(
        require(VAR1.call.value(VAR2)(VAR3));
    }

1
---------------------------------
6961.sol
    function transfer(address VAR1, uint VAR2) public returns (bool VAR3) {
    }
    function transfer(address VAR1, uint VAR2, bytes VAR4) public returns (bool VAR3) {
    }
    function transfer(address VAR1, uint VAR2, bytes VAR4, string VAR5) public returns (bool VAR3) {
                && VAR6[VAR1] == false
                && VAR7 > VAR8[VAR1]);
        if (FUN1(VAR1)) {
            VAR9[VAR1] = VAR9[VAR1].FUN2(VAR2);
            assert(VAR1.call.value(0)(bytes4(FUN3(VAR5)), msg.sender, VAR2, VAR4));
            emit Transfer(msg.sender, VAR1, VAR2, VAR4);
            emit Transfer(msg.sender, VAR1, VAR2);
            return FUN4(VAR1, VAR2, VAR4);
    }

1
---------------------------------
702.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
7056.sol
    function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1
---------------------------------
7170.sol
  function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
74.sol
    function FUN1(
        require(VAR1.VAR2 == VAR3.VAR2 + 1, "");
        require(VAR4.VAR2 == VAR3.VAR2, "");
        for (uint VAR5 = 0; VAR5 < VAR3.VAR2; VAR5++) {
            require(VAR3[VAR5].call.value(VAR4[VAR5])(VAR6), "");
    }

1
---------------------------------
7603.sol
    function FUN1() payable public {
      if(!VAR1.call.value(VAR2).FUN2(400000)()) {
    }

1
---------------------------------
774.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, VAR4.EventReturns memory VAR5)
        if (!address(VAR6).call.value(VAR7)(bytes4(FUN2(""))))
    }

1
---------------------------------
785.sol
      function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
          if (!address(VAR8).call.value(VAR9)())
              VAR8.transfer(VAR10.FUN2(VAR11));
      }

1
---------------------------------
7877.sol
  function FUN1(
    FUN2(VAR1)
      transfer(VAR1, value) &&
    require(VAR1.call.value(msg.value)(VAR2));
  }

1
---------------------------------
8168.sol
  function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
8219.sol
  function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
8342.sol
  function FUN1(address VAR1, uint256 VAR2, uint256 VAR3, bytes VAR4)
    return VAR1.call.value(VAR2).FUN2(VAR3)(VAR4);
  }

1
---------------------------------
8396.sol
    function FUN1(uint VAR1)
            VAR2.VAR3 = true;
            if (VAR2.VAR4.call.value(VAR2.value)(VAR2.VAR5))
                VAR2.VAR3 = false;
    }

1
---------------------------------
84.sol
    function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, VAR4.EventReturns memory VAR5)
        if (!address(VAR6).call.value(VAR7)())
    }

1
---------------------------------
8508.sol
  function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
88.sol
  function FUN1(bytes32 VAR1, bytes VAR2) external payable returns (bool VAR3) {
    if (address(VAR4).call.value(msg.value)(VAR5.FUN2(
  }

1
---------------------------------
9001.sol
  function FUN1(address VAR1, uint256 VAR2, bytes VAR3) public payable returns (bool) {
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(address VAR4, uint256 VAR2, bytes VAR3) public payable returns (bool) {
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(address VAR1, uint VAR6, bytes VAR3) public payable returns (bool) {
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(address VAR1, uint VAR7, bytes VAR3) public payable returns (bool) {
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
9221.sol
	function FUN1() payable
		if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2))
			if (!msg.sender.call.value(2 VAR1)())
	}
	function FUN3(uint VAR3)
		if (VAR4==msg.sender)
			if (!msg.sender.call.value( VAR3 * (1 VAR1))())
	}

1
---------------------------------
9284.sol
    function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"");
    }

1
---------------------------------
9538.sol
  function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1
---------------------------------
9584.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
9586.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
9600.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
9602.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
9610.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
9611.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
9612.sol
    function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), "");
    }

1
---------------------------------
9654.sol
	function FUN1() payable
		if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2))
			if (!msg.sender.call.value(2 VAR1)())
	}

1
---------------------------------
9993.sol
    function FUN1(
        require(VAR1 != address(this));
        super.FUN2(VAR1, VAR2);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN3(
        require(VAR4 != address(this));
        super.transfer(VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN4(
        require(VAR4 != address(this));
        super.FUN5(VAR5, VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN6(
        require(VAR1 != address(this));
        super.FUN7(VAR1, VAR6);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN8(
        require(VAR1 != address(this));
        super.FUN9(VAR1, VAR7);
        require(VAR1.call.value(msg.value)(VAR3));
    }

1
---------------------------------
